Основная сущность — Event. Вот её предлагаемая структура:

typescript
// entity/Event.ts
@Entity()
export class Event {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column()
  title: string;

  @Column('text')
  description: string;

  // --- ДАТЫ --- //
  // Тип даты: фиксированная, плавающая, ежегодная
  @Column({ type: 'enum', enum: EventDateType, default: EventDateType.FIXED })
  dateType: EventDateType;

  // Для фиксированных дат (например, "12 июня 2025")
  @Column({ type: 'timestamptz', nullable: true })
  startDate: Date;

  @Column({ type: 'timestamptz', nullable: true })
  endDate: Date;

  // Для плавающих дат (например, "последние выходные августа")
  @Column({ nullable: true })
  floatingDateRule: string; // Можно хранить как JSON или текстовое описание

  // --- ГЕОЛОКАЦИЯ --- //
  @Column({ type: 'float' })
  latitude: number;

  @Column({ type: 'float' })
  longitude: number;

  @Column()
  locationTitle: string; // "ЦПКиО им. Горького", "Набережная Суздаля"

  @Column({ nullable: true })
  address: string;

  // --- КАТЕГОРИИ И СЕЗОННОСТЬ --- //
  @Column({ type: 'simple-array' })
  categories: string[]; // ['food-festival', 'cultural', 'free', 'for-kids']

  @Column({ type: 'simple-array', nullable: true })
  seasons: string[]; // ['summer', 'august']

  // --- ВИЗУАЛ И КОНТЕНТ --- //
  @Column('text', { array: true, default: [] })
  imageUrls: string[]; // Ссылки на загруженные фото

  @Column({ type: 'jsonb', default: [] })
  archive: { year: number; photoUrl: string; description: string }[]; // Архив прошлых лет

  // --- ОРГАНИЗАЦИЯ И СТАТУС --- //
  @ManyToOne(() => User)
  @JoinColumn()
  createdBy: User; // Кто создал событие

  @Column({ default: false })
  isVerified: boolean; // Подтверждено модератором/админом

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;
}

// Enum для типа даты
export enum EventDateType {
  FIXED = 'fixed', // Конкретная дата
  FLOATING = 'floating', // Плавающая дата ("последняя суббота августа")
  ANNUAL = 'annual', // Ежегодное (каждый год в одно и то же число)
}
2. Логика обработки "плавающих дат"
Это самая сложная часть. Реализуем хелпер-функцию, которая будет вычислять конкретные даты для текущего года на основе текстового правила.

typescript
// utils/dateCalculator.ts
export const calculateFloatingDate = (rule: string, year: number): { start: Date; end?: Date } => {
  // Пример rule: "last weekend of August"
  const rules = rule.toLowerCase().split(' ');
  const monthName = rules.find(word => months[word]);
  const monthIndex = months[monthName]; // Получаем индекс месяца (0-11)

  if (rules.includes('last')) {
    if (rules.includes('weekend')) {
      // Логика для последних выходных августа
      const lastDay = new Date(year, monthIndex + 1, 0); // Последний день месяца
      let day = lastDay.getDate();
      while (day > 0) {
        const currentDate = new Date(year, monthIndex, day);
        if (currentDate.getDay() === 0) { // Нашли воскресенье
          const saturday = new Date(year, monthIndex, day - 1);
          return { start: saturday, end: currentDate };
        }
        day--;
      }
    }
  }
  // ... другие правила (first, second, third, etc.)
  // Fallback
  return { start: new Date(year, monthIndex, 1) };
};

const months = {
  january: 0, february: 1, march: 2, april: 3, may: 4, june: 5,
  july: 6, august: 7, september: 8, october: 9, november: 10, december: 11
};
3. API Endpoints (Node.js + Express)
typescript
// routes/events.ts
router.get('/', async (req: Request, res: Response) => {
  // Фильтрация по категориям, дате, местоположению
  const { category, near, startDate, endDate } = req.query;
  const events = await eventService.getFilteredEvents({ category, near, startDate, endDate });
  res.json(events);
});

router.get('/:id', async (req: Request, res: Response) => {
  const event = await eventService.getEventById(req.params.id);
  if (!event) {
    throw new NotFoundError('Event not found');
  }
  res.json(event);
});

router.post('/', authMiddleware, async (req: Request, res: Response) => {
  // Валидация входящих данных с помощью class-validator
  const eventData: CreateEventDto = req.body;
  const event = await eventService.createEvent(eventData, req.user);
  res.status(201).json(event);
});
4. Интерфейс конструктора событий (Frontend, React + Vite)
Состояние компонента конструктора:

typescript
const [eventData, setEventData] = useState({
  title: '',
  description: '',
  dateType: 'fixed',
  // ... остальные поля
});
Визуальная структура модального окна (условно):

tsx
<Modal isOpen={isOpen} onClose={onClose} size="4xl">
  <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
    {/* Левая колонка: Форма */}
    <div>
      <Input label="Название события" value={eventData.title} onChange={...} />
      <TextArea label="Описание" value={eventData.description} />
      
      {/* Селектор типа даты */}
      <Select label="Тип даты" options={[
        { value: 'fixed', label: 'Конкретная дата' },
        { value: 'floating', label: 'Плавающая дата' },
        { value: 'annual', label: 'Ежегодное' }
      ]} />
      
      {eventData.dateType === 'fixed' && (
        <DatePicker label="Дата начала" />
      )}
      {eventData.dateType === 'floating' && (
        <Input label="Правило (напр.: 'последние выходные августа')" />
      )}
      
      <MapPicker onLocationSelect={...} />
    </div>
    
    {/* Правая колонка: Предпросмотр */}
    <div className="border rounded-lg p-4">
      <h3 className="text-lg font-semibold mb-4">Предпросмотр</h3>
      <EventPreviewCard eventData={eventData} />
    </div>
  </div>
  
  {/* Нижняя панель: Загрузка фото и действия */}
  <div className="mt-6">
    <ImageUploader onUpload={...} />
    <Button onClick={handleSave}>Сохранить событие</Button>
  </div>
</Modal>
5. Карточка события (Превью)
Для карточки события используйте компонент, который показывает:

Галерею фото с превью

Рассчитанные даты (для плавающих — "Ежегодно, последние выходные августа")

Интерактивную карту (Leaflet)

Кнопки "Участвую", "В избранное"

Блок "Архив" с историей прошлых лет

6. Планирование встреч внутри события
Создайте отдельную сущность EventMeetup:

typescript
@Entity()
export class EventMeetup {
  @PrimaryGeneratedColumn()
  id: number;

  @ManyToOne(() => Event)
  event: Event;

  @Column()
  title: string;

  @Column('text')
  description: string;

  @Column({ type: 'timestamptz' })
  time: Date;

  @Column({ type: 'float' })
  latitude: number;

  @Column({ type: 'float' })
  longitude: number;

  @ManyToMany(() => User)
  @JoinTable()
  participants: User[];
}