Отличная идея! Я разработаю для вас концепцию «Центра влияния» — это будет действительно захватывающий и мотивирующий раздел. Вот подробный план:

🎯 КОНЦЕПЦИЯ «ЦЕНТР ВЛИЯНИЯ»
Комментарий для раздела: «Интерактивная вселенная достижений и влияния путешественника — персональный космос роста, где каждое действие превращается в звезду на карте личного развития, а сообщество становится галактикой взаимного вдохновения»

🏗️ Архитектура компонентов
1. InfluenceHub.jsx — главный контейнер
// Основной компонент с анимированным фоном и орбитальной навигацией
- Particle system background
- Floating navigation spheres
- Dynamic theme switching
- Smooth transitions между секциями
2. PersonalGalaxy.jsx — личная вселенная пользователя
// 3D визуализация достижений как созвездий
- Constellation map достижений
- Animated star formation при новых достижениях
- Interactive planet для каждой категории активности
- Zoom-эффекты при наведении
3. InfluenceMetrics.jsx — метрики влияния
// Живые графики и статистика
- Animated circular progress bars
- Wave-форма активности
- Pulsing indicators для трендов
- Morphing charts при изменении периода
4. AchievementOrbit.jsx — Орбита достижений
// Вращающиеся достижения вокруг аватара
- Orbital animation system
- Glowing badges с particle effects
- Unlock animations
- Achievement chains visualization
5. CommunityPulse.jsx — пульс сообщества
// Живая визуализация активности сообщества
- Heartbeat-анимация активности
- Flowing connections между пользователями
- Real-time activity streams
- Collaborative achievement celebrations
6. TrendNebula.jsx — Туманность трендов
// Облако трендовых направлений
- Morphing cloud visualization
- Color-shifting по популярности
- Interactive trend exploration
- Predictive trend indicators
7. MotivationEngine.jsx — двигатель мотивации
// Персонализированные вызовы и цели
- Dynamic challenge generation
- Progress rocket animation
- Fuel gauge для мотивации
- Boost effects при достижениях
8. InfluenceLeaderboard.jsx — Доска лидеров
// Подиум с голографическими эффектами
- 3D podium с particle effects
- Avatar holograms
- Smooth ranking transitions
- Crown и aura effects для топов
🎨 ВИЗУАЛЬНЫЕ ЭФФЕКТЫ И АНИМАЦИЯ
9. ParticleSystem.jsx — система частиц
// Фоновые эффекты и реакции на действия
- Floating particles
- Interaction responses
- Achievement explosions
- Ambient animations
10. HolographicUI.jsx — голографический интерфейс
// Футуристические UI элементы
- Glowing borders
- Holographic buttons
- Neon text effects
- Transparent panels с blur
🎮 Геймификация
11. QuestSystem.jsx — система квестов
// Динамические задания и челленджи
- Quest generation algorithm
- Progress tracking
- Reward animations
- Chain quest visualization
12. PowerUpCenter.jsx — Центр усилений
// Временные бусты и способности
- Power-up inventory
- Activation effects
- Cooldown timers
- Combination system
📊 АНАЛИТИКА И СТАТИСТИКА
13. InsightCrystal.jsx — Кристалл инсайтов
// Интерактивная аналитика
- Crystal-like data visualization
- Faceted information display
- Rotation interactions
- Data drilling effects
14. TravelDNA.jsx — ДНК путешественника
// Уникальный профиль активности
- Helix visualization
- Personality traits mapping
- Evolution timeline
- Compatibility matching
🌟 СОЦИАЛЬНОЕ ВЗАИМОДЕЙСТВИЕ
15. InfluenceNetwork.jsx — Сеть влияния
// Визуализация связей и влияния
- Network graph с анимацией
- Influence flow visualization
- Connection strength indicators
- Collaborative project highlights
16. MentorshipPortal.jsx — портал наставничества
// Система менторства и обучения
- Mentor-student connections
- Knowledge transfer visualization
- Skill tree progression
- Wisdom sharing rewards
🎯 Мотивационные механизмы
17. DreamBoard.jsx — Доска мечты
// Визуализация целей и мечт
- Vision board с интерактивностью
- Goal manifestation tracking
- Dream achievement celebrations
- Inspiration gallery
18. LegacyBuilder.jsx — Строитель наследия
// Долгосрочное влияние и вклад
- Legacy timeline
- Impact measurement
- Contribution visualization
- Future projection
🔮 ДОПОЛНИТЕЛЬНЫЕ ФУНКЦИИ
19. SeasonalEvents.jsx — Сезонные события
// Временные события и празднования
- Event calendar integration
- Seasonal themes
- Limited-time challenges
- Community celebrations
20. PersonalMuseum.jsx — Личный музей
// Коллекция воспоминаний и достижений
- 3D gallery space
- Memory artifacts
- Story preservation
- Interactive exhibitions
Этот «Центр влияния» станет настоящим магнитом для пользователей — местом, где они будут чувствовать свой рост, влияние и принадлежность к сообществу путешественников!

Хотите, чтобы я детально проработал код для любого из этих компонентов?

да, продолжай, напиши код для каждого файла
Отлично! Создам код для каждого компонента. Начну с основных файлов:

1. InfluenceHub.jsx — главный контейнер
import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import PersonalGalaxy from './PersonalGalaxy';
import InfluenceMetrics from './InfluenceMetrics';
import AchievementOrbit from './AchievementOrbit';
import CommunityPulse from './CommunityPulse';
import TrendNebula from './TrendNebula';
import MotivationEngine from './MotivationEngine';
import ParticleSystem from './ParticleSystem';
import './InfluenceHub.css';

const InfluenceHub = () => {
  const [activeSection, setActiveSection] = useState('galaxy');
  const [userLevel, setUserLevel] = useState(15);
  const [influencePoints, setInfluencePoints] = useState(2847);
  const [theme, setTheme] = useState('cosmic');

  const sections = [
    { id: 'galaxy', name: 'Личная Галактика', icon: '🌌', component: PersonalGalaxy },
    { id: 'metrics', name: 'Метрики Влияния', icon: '📊', component: InfluenceMetrics },
    { id: 'achievements', name: 'Орбита Достижений', icon: '🏆', component: AchievementOrbit },
    { id: 'community', name: 'Пульс Сообщества', icon: '💫', component: CommunityPulse },
    { id: 'trends', name: 'Туманность Трендов', icon: '🌠', component: TrendNebula },
    { id: 'motivation', name: 'Двигатель Мотивации', icon: '🚀', component: MotivationEngine }
  ];

  const containerVariants = {
    hidden: { opacity: 0 },
    visible: {
      opacity: 1,
      transition: {
        duration: 1,
        staggerChildren: 0.2
      }
    }
  };

  const orbitalVariants = {
    hidden: { scale: 0, rotate: -180 },
    visible: {
      scale: 1,
      rotate: 0,
      transition: {
        type: "spring",
        stiffness: 100,
        damping: 15
      }
    }
  };

  return (
    <motion.div 
      className="influence-hub"
      variants={containerVariants}
      initial="hidden"
      animate="visible"
    >
      <ParticleSystem theme={theme} />
      
      {/* Центральный аватар пользователя */}
      <motion.div className="central-avatar">
        <div className="avatar-container">
          <div className="avatar-image">
            <img src="/api/avatar" alt="User Avatar" />
          </div>
          <div className="level-ring">
            <span className="level-number">{userLevel}</span>
          </div>
          <div className="influence-aura">
            <div className="aura-pulse"></div>
          </div>
        </div>
        <div className="influence-counter">
          <motion.span
            key={influencePoints}
            initial={{ scale: 1.2, color: '#00ff88' }}
            animate={{ scale: 1, color: '#ffffff' }}
            transition={{ duration: 0.5 }}
          >
            {influencePoints.toLocaleString()} IP
          </motion.span>
        </div>
      </motion.div>

      {/* Орбитальная навигация */}
      <div className="orbital-navigation">
        {sections.map((section, index) => {
          const angle = (index * 60) - 90; // Распределяем по кругу
          const radius = 200;
          const x = Math.cos(angle * Math.PI / 180) * radius;
          const y = Math.sin(angle * Math.PI / 180) * radius;

          return (
            <motion.div
              key={section.id}
              className={`nav-sphere ${activeSection === section.id ? 'active' : ''}`}
              style={{
                transform: `translate(${x}px, ${y}px)`
              }}
              variants={orbitalVariants}
              whileHover={{ 
                scale: 1.2, 
                boxShadow: '0 0 30px rgba(0, 255, 136, 0.8)' 
              }}
              whileTap={{ scale: 0.9 }}
              onClick={() => setActiveSection(section.id)}
            >
              <div className="sphere-icon">{section.icon}</div>
              <div className="sphere-label">{section.name}</div>
              <div className="sphere-glow"></div>
            </motion.div>
          );
        })}
      </div>

      {/* Контент секций */}
      <AnimatePresence mode="wait">
        <motion.div
          key={activeSection}
          className="section-content"
          initial={{ opacity: 0, y: 50, rotateX: -15 }}
          animate={{ opacity: 1, y: 0, rotateX: 0 }}
          exit={{ opacity: 0, y: -50, rotateX: 15 }}
          transition={{ duration: 0.6, ease: "easeInOut" }}
        >
          {React.createElement(
            sections.find(s => s.id === activeSection)?.component || PersonalGalaxy,
            { userLevel, influencePoints, setInfluencePoints }
          )}
        </motion.div>
      </AnimatePresence>

      {/* Переключатель темы */}
      <motion.div 
        className="theme-switcher"
        whileHover={{ scale: 1.1 }}
        whileTap={{ scale: 0.9 }}
      >
        <button onClick={() => setTheme(theme === 'cosmic' ? 'neon' : 'cosmic')}>
          {theme === 'cosmic' ? '🌙' : '⚡'}
        </button>
      </motion.div>
    </motion.div>
  );
};

export default InfluenceHub;
2. PersonalGalaxy.jsx — личная вселенная пользователя
import React, { useState, useEffect, useRef } from 'react';
import { motion } from 'framer-motion';
import * as THREE from 'three';
import './PersonalGalaxy.css';

const PersonalGalaxy = ({ userLevel, influencePoints }) => {
  const mountRef = useRef(null);
  const sceneRef = useRef(null);
  const [selectedConstellation, setSelectedConstellation] = useState(null);
  const [achievements, setAchievements] = useState([]);

  const constellations = [
    {
      id: 'explorer',
      name: 'Исследователь',
      stars: 12,
      completed: 8,
      color: '#00ff88',
      position: { x: 0, y: 0, z: 0 },
      achievements: ['Первое путешествие', 'Новая страна', 'Экстремальный маршрут']
    },
    {
      id: 'social',
      name: 'Социальная Звезда',
      stars: 15,
      completed: 11,
      color: '#ff6b6b',
      position: { x: 50, y: 30, z: -20 },
      achievements: ['100 друзей', 'Организатор встречи', 'Популярный блог']
    },
    {
      id: 'mentor',
      name: 'Наставник',
      stars: 10,
      completed: 6,
      color: '#4ecdc4',
      position: { x: -40, y: -25, z: 15 },
      achievements: ['Первый ученик', 'Мудрый совет', 'Гид года']
    }
  ];

  useEffect(() => {
    if (!mountRef.current) return;

    // Инициализация Three.js сцены
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
    
    renderer.setSize(800, 600);
    renderer.setClearColor(0x000000, 0);
    mountRef.current.appendChild(renderer.domElement);

    // Создание звездного поля
    const starGeometry = new THREE.BufferGeometry();
    const starCount = 1000;
    const positions = new Float32Array(starCount * 3);
    const colors = new Float32Array(starCount * 3);

    for (let i = 0; i < starCount * 3; i += 3) {
      positions[i] = (Math.random() - 0.5) * 200;
      positions[i + 1] = (Math.random() - 0.5) * 200;
      positions[i + 2] = (Math.random() - 0.5) * 200;

      colors[i] = Math.random();
      colors[i + 1] = Math.random();
      colors[i + 2] = Math.random();
    }

    starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    starGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    const starMaterial = new THREE.PointsMaterial({
      size: 2,
      vertexColors: true,
      transparent: true,
      opacity: 0.8
    });

    const stars = new THREE.Points(starGeometry, starMaterial);
    scene.add(stars);

    // Создание созвездий
    constellations.forEach(constellation => {
      const group = new THREE.Group();
      
      // Создание звезд созвездия
      for (let i = 0; i < constellation.stars; i++) {
        const starGeometry = new THREE.SphereGeometry(0.5, 8, 8);
        const starMaterial = new THREE.MeshBasicMaterial({
          color: constellation.color,
          transparent: true,
          opacity: i < constellation.completed ? 1 : 0.3
        });
        
        const star = new THREE.Mesh(starGeometry, starMaterial);
        star.position.set(
          Math.random() * 20 - 10,
          Math.random() * 20 - 10,
          Math.random() * 10 - 5
        );
        
        group.add(star);
      }

      group.position.set(
        constellation.position.x,
        constellation.position.y,
        constellation.position.z
      );
      
      scene.add(group);
    });

    camera.position.z = 50;
    sceneRef.current = { scene, camera, renderer, stars };

    // Анимационный цикл
    const animate = () => {
      requestAnimationFrame(animate);
      
      stars.rotation.x += 0.001;
      stars.rotation.y += 0.002;
      
      renderer.render(scene, camera);
    };
    animate();

    return () => {
      if (mountRef.current && renderer.domElement) {
        mountRef.current.removeChild(renderer.domElement);
      }
      renderer.dispose();
    };
  }, []);

  const handleConstellationClick = (constellation) => {
    setSelectedConstellation(constellation);
  };

  return (
    <div className="personal-galaxy">
      <motion.div 
        className="galaxy-header"
        initial={{ opacity: 0, y: -30 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.8 }}
      >
        <h2>Ваша Личная Галактика</h2>
        <div className="galaxy-stats">
          <div className="stat-item">
            <span className="stat-value">{constellations.length}</span>
            <span className="stat-label">Созвездий</span>
          </div>
          <div className="stat-item">
            <span className="stat-value">
              {constellations.reduce((acc, c) => acc + c.completed, 0)}
            </span>
            <span className="stat-label">Звезд зажжено</span>
          </div>
          <div className="stat-item">
            <span className="stat-value">{userLevel}</span>
            <span className="stat-label">Уровень</span>
          </div>
        </div>
      </motion.div>

      <div className="galaxy-container">
        <div className="three-canvas" ref={mountRef}></div>
        
        <div className="constellation-controls">
          {constellations.map((constellation, index) => (
            <motion.div
              key={constellation.id}
              className={`constellation-card ${selectedConstellation?.id === constellation.id ? 'selected' : ''}`}
              initial={{ opacity: 0, x: -50 }}
              animate={{ opacity: 1, x: 0 }}
              transition={{ delay: index * 0.2 }}
              onClick={() => handleConstellationClick(constellation)}
              whileHover={{ scale: 1.05, boxShadow: `0 10px 30px ${constellation.color}40` }}
            >
              <div className="constellation-icon" style={{ color: constellation.color }}>
                ⭐
              </div>
              <div className="constellation-info">
                <h4>{constellation.name}</h4>
                <div className="progress-bar">
                  <div 
                    className="progress-fill"
                    style={{ 
                      width: `${(constellation.completed / constellation.stars) * 100}%`,
                      backgroundColor: constellation.color
                    }}
                  ></div>
                </div>
                <span className="progress-text">
                  {constellation.completed}/{constellation.stars} звезд
                </span>
              </div>
            </motion.div>
          ))}
        </div>
      </div>

      {selectedConstellation && (
        <motion.div
          className="constellation-detail"
          initial={{ opacity: 0, scale: 0.8 }}
          animate={{ opacity: 1, scale: 1 }}
          exit={{ opacity: 0, scale: 0.8 }}
        >
          <div className="detail-header">
            <h3>{selectedConstellation.name}</h3>
            <button 
              className="close-btn"
              onClick={() => setSelectedConstellation(null)}
            >
              ✕
            </button>
          </div>
          <div className="achievements-list">
            {selectedConstellation.achievements.map((achievement, index) => (
              <motion.div
                key={index}
                className="achievement-item"
                initial={{ opacity: 0, x: -20 }}
                animate={{ opacity: 1, x: 0 }}
                transition={{ delay: index * 0.1 }}
              >
                <div className="achievement-icon">🏆</div>
                <span>{achievement}</span>
              </motion.div>
            ))}
          </div>
        </motion.div>
      )}
    </div>
  );
};

export default PersonalGalaxy;
3. InfluenceMetrics.jsx — метрики влияния
import React, { useState, useEffect } from 'react';
import { motion } from 'framer-motion';
import { LineChart, Line, XAxis, YAxis, CartesianGrid, ResponsiveContainer, RadialBarChart, RadialBar, PieChart, Pie, Cell } from 'recharts';
import './InfluenceMetrics.css';

const InfluenceMetrics = ({ userLevel, influencePoints, setInfluencePoints }) => {
  const [selectedPeriod, setSelectedPeriod] = useState('week');
  const [metrics, setMetrics] = useState({});
  const [isAnimating, setIsAnimating] = useState(false);

  const periods = [
    { id: 'week', label: 'Неделя', icon: '📅' },
    { id: 'month', label: 'Месяц', icon: '🗓️' },
    { id: 'year', label: 'Год', icon: '📆' }
  ];

  const influenceData = [
    { name: 'Пн', value: 120, trend: 'up' },
    { name: 'Вт', value: 180, trend: 'up' },
    { name: 'Ср', value: 150, trend: 'down' },
    { name: 'Чт', value: 220, trend: 'up' },
    { name: 'Пт', value: 280, trend: 'up' },
    { name: 'Сб', value: 350, trend: 'up' },
    { name: 'Вс', value: 320, trend: 'down' }
  ];

  const categoryData = [
    { name: 'Путешествия', value: 35, color: '#00ff88', icon: '✈️' },
    { name: 'Общение', value: 25, color: '#ff6b6b', icon: '💬' },
    { name: 'Планирование', value: 20, color: '#4ecdc4', icon: '📋' },
    { name: 'Блоги', value: 15, color: '#ffd93d', icon: '📝' },
    { name: 'Карты', value: 5, color: '#a8e6cf', icon: '🗺️' }
  ];

  const radialData = [
    { name: 'Влияние', value: 75, fill: '#00ff88' },
    { name: 'Активность', value: 60, fill: '#ff6b6b' },
    { name: 'Социальность', value: 85, fill: '#4ecdc4' },
    { name: 'Креативность', value: 70, fill: '#ffd93d' }
  ];

  useEffect(() => {
    // Симуляция загрузки данных
    setIsAnimating(true);
    setTimeout(() => {
      setMetrics({
        totalInfluence: influencePoints,
        weeklyGrowth: 15.3,
        engagement: 89.2,
        reach: 1247
      });
      setIsAnimating(false);
    }, 1000);
  }, [selectedPeriod, influencePoints]);

  const MetricCard = ({ title, value, suffix = '', trend, icon, color = '#00ff88' }) => (
    <motion.div
      className="metric-card"
      whileHover={{ scale: 1.05, boxShadow: `0 10px 30px ${color}40` }}
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ duration: 0.5 }}
    >
      <div className="metric-header">
        <span className="metric-icon">{icon}</span>
        <span className="metric-title">{title}</span>
      </div>
      <div className="metric-value">
        <motion.span
          key={value}
          initial={{ scale: 1.2, color: color }}
          animate={{ scale: 1, color: '#ffffff' }}
          transition={{ duration: 0.6 }}
        >
          {typeof value === 'number' ? value.toLocaleString() : value}
        </motion.span>
        <span className="metric-suffix">{suffix}</span>
      </div>
      {trend && (
        <div className={`metric-trend ${trend > 0 ? 'positive' : 'negative'}`}>
          <span className="trend-icon">{trend > 0 ? '↗️' : '↘️'}</span>
          <span className="trend-value">{Math.abs(trend)}%</span>
        </div>
      )}
      <div className="metric-glow" style={{ backgroundColor: color }}></div>
    </motion.div>
  );

  const WaveAnimation = ({ data, color = '#00ff88' }) => (
    <div className="wave-container">
      <svg width="100%" height="60" className="wave-svg">
        <defs>
          <linearGradient id={`waveGradient-${color}`} x1="0%" y1="0%" x2="100%" y2="0%">
            <stop offset="0%" stopColor={color} stopOpacity="0.8" />
            <stop offset="50%" stopColor={color} stopOpacity="1" />
            <stop offset="100%" stopColor={color} stopOpacity="0.8" />
          </linearGradient>
        </defs>
        <motion.path
          d={`M0,30 ${data.map((point, i) => `L${i * 50},${30 - point.value / 10}`).join(' ')} L350,30 L350,60 L0,60 Z`}
          fill={`url(#waveGradient-${color})`}
          initial={{ pathLength: 0 }}
          animate={{ pathLength: 1 }}
          transition={{ duration: 2, ease: "easeInOut" }}
        />
      </svg>
    </div>
  );

  return (
    <div className="influence-metrics">
      <motion.div 
        className="metrics-header"
        initial={{ opacity: 0, y: -30 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.8 }}
      >
        <h2>Метрики Влияния</h2>
        <div className="period-selector">
          {periods.map(period => (
            <motion.button
              key={period.id}
              className={`period-btn ${selectedPeriod === period.id ? 'active' : ''}`}
              onClick={() => setSelectedPeriod(period.id)}
              whileHover={{ scale: 1.05 }}
              whileTap={{ scale: 0.95 }}
            >
              <span className="period-icon">{period.icon}</span>
              {period.label}
            </motion.button>
          ))}
        </div>
      </motion.div>

      <div className="metrics-grid">
        <MetricCard
          title="Общее Влияние"
          value={metrics.totalInfluence}
          suffix="IP"
          trend={12.5}
          icon="⚡"
          color="#00ff88"
        />
        <MetricCard
          title="Рост за Период"
          value={metrics.weeklyGrowth}
          suffix="%"
          trend={8.3}
          icon="📈"
          color="#ff6b6b"
        />
        <MetricCard
          title="Вовлеченность"
          value={metrics.engagement}
          suffix="%"
          trend={-2.1}
          icon="💫"
          color="#4ecdc4"
        />
        <MetricCard
          title="Охват"
          value={metrics.reach}
          trend={15.7}
          icon="🌍"
          color="#ffd93d"
        />
      </div>

      <div className="charts-container">
        <motion.div 
          className="chart-section"
          initial={{ opacity: 0, x: -50 }}
          animate={{ opacity: 1, x: 0 }}
          transition={{ delay: 0.3 }}
        >
          <h3>Динамика Влияния</h3>
          <div className="chart-wrapper">
            <ResponsiveContainer width="100%" height={300}>
              <LineChart data={influenceData}>
                <CartesianGrid strokeDasharray="3 3" stroke="#333" />
                <XAxis dataKey="name" stroke="#888" />
                <YAxis stroke="#888" />
                <Line 
                  type="monotone" 
                  dataKey="value" 
                  stroke="#00ff88" 
                  strokeWidth={3}
                  dot={{ fill: '#00ff88', strokeWidth: 2, r: 6 }}
                  activeDot={{ r: 8, stroke: '#00ff88', strokeWidth: 2 }}
                />
              </LineChart>
            </ResponsiveContainer>
          </div>
          <WaveAnimation data={influenceData} color="#00ff88" />
        </motion.div>

        <motion.div 
          className="chart-section"
          initial={{ opacity: 0, x: 50 }}
          animate={{ opacity: 1, x: 0 }}
          transition={{ delay: 0.5 }}
        >
          <h3>Распределение по Категориям</h3>
          <div className="chart-wrapper">
            <ResponsiveContainer width="100%" height={300}>
              <PieChart>
                <Pie
                  data={categoryData}
                  cx="50%"
                  cy="50%"
                  innerRadius={60}
                  outerRadius={120}
                  paddingAngle={5}
                  dataKey="value"
                >
                  {categoryData.map((entry, index) => (
                    <Cell key={`cell-${index}`} fill={entry.color} />
                  ))}
                </Pie>
              </PieChart>
            </ResponsiveContainer>
          </div>
          <div className="category-legend">
            {categoryData.map((category, index) => (
              <motion.div
                key={category.name}
                className="legend-item"
                initial={{ opacity: 0, y: 10 }}
                animate={{ opacity: 1, y: 0 }}
                transition={{ delay: 0.7 + index * 0.1 }}
              >
                <span className="legend-icon">{category.icon}</span>
                <span className="legend-name">{category.name}</span>
                <span className="legend-value" style={{ color: category.color }}>
                  {category.value}%
                </span>
              </motion.div>
            ))}
          </div>
        </motion.div>
      </div>

      <motion.div 
        className="radial-metrics"
        initial={{ opacity: 0, y: 50 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ delay: 0.7 }}
      >
        <h3>Профиль Активности</h3>
        <div className="radial-container">
          <ResponsiveContainer width="100%" height={400}>
            <RadialBarChart cx="50%" cy="50%" innerRadius="20%" outerRadius="80%" data={radialData}>
              <RadialBar
                minAngle={15}
                label={{ position: 'insideStart', fill: '#fff' }}
                background
                clockWise
                dataKey="value"
              />
            </RadialBarChart>
          </ResponsiveContainer>
        </div>
      </motion.div>

      {/* Пульсирующие индикаторы трендов */}
      <div className="trend-indicators">
        {['🔥', '⚡', '🌟', '💎'].map((emoji, index) => (
          <motion.div
            key={index}
            className="trend-indicator"
            animate={{
              scale: [1, 1.2, 1],
              opacity: [0.7, 1, 0.7]
            }}
            transition={{
              duration: 2,
              repeat: Infinity,
              delay: index * 0.5
            }}
          >
            {emoji}
          </motion.div>
        ))}
      </div>
    </div>
  );
};

export default InfluenceMetrics;
4. AchievementOrbit.jsx — Орбита достижений
import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import './AchievementOrbit.css';

const AchievementOrbit = ({ userLevel, influencePoints, setInfluencePoints }) => {
  const [selectedAchievement, setSelectedAchievement] = useState(null);
  const [unlockedAchievements, setUnlockedAchievements] = useState([]);
  const [showUnlockAnimation, setShowUnlockAnimation] = useState(false);

  const achievements = [
    {
      id: 'first_journey',
      name: 'Первое Путешествие',
      description: 'Совершите свое первое путешествие',
      icon: '🌍',
      rarity: 'common',
      points: 100,
      unlocked: true,
      category: 'travel',
      orbit: 1,
      angle: 0
    },
    {
      id: 'social_butterfly',
      name: 'Социальная Бабочка',
      description: 'Заведите 50 новых друзей',
      icon: '🦋',
      rarity: 'rare',
      points: 250,
      unlocked: true,
      category: 'social',
      orbit: 1,
      angle: 60
    },
    {
      id: 'master_planner',
      name: 'Мастер Планирования',
      description: 'Создайте 10 детальных маршрутов',
      icon: '📋',
      rarity: 'epic',
      points: 500,
      unlocked: true,
      category: 'planning',
      orbit: 1,
      angle: 120
    },
    {
      id: 'blog_master',
      name: 'Мастер Блогов',
      description: 'Напишите 25 популярных постов',
      icon: '✍️',
      rarity: 'rare',
      points: 300,
      unlocked: false,
      category: 'content',
      orbit: 2,
      angle: 30
    },
    {
      id: 'explorer_legend',
      name: 'Легенда Исследователя',
      description: 'Посетите 50 уникальных мест',
      icon: '🏔️',
      rarity: 'legendary',
      points: 1000,
      unlocked: false,
      category: 'travel',
      orbit: 2,
      angle: 90
    },
    {
      id: 'community_leader',
      name: 'Лидер Сообщества',
      description: 'Станьте модератором 3 чатов',
      icon: '👑',
      rarity: 'epic',
      points: 750,
      unlocked: false,
      category: 'social',
      orbit: 2,
      angle: 150
    }
  ];

  const rarityColors = {
    common: '#888888',
    rare: '#0099ff',
    epic: '#9933ff',
    legendary: '#ff6600'
  };

  const rarityGlow = {
    common: '0 0 10px #888888',
    rare: '0 0 20px #0099ff',
    epic: '0 0
  const rarityGlow = {
    common: '0 0 10px #888888',
    rare: '0 0 20px #0099ff',
    epic: '0 0 30px #9933ff',
    legendary: '0 0 40px #ff6600'
  };

  useEffect(() => {
    setUnlockedAchievements(achievements.filter(a => a.unlocked));
  }, []);

  const handleAchievementClick = (achievement) => {
    if (achievement.unlocked) {
      setSelectedAchievement(achievement);
    }
  };

  const unlockAchievement = (achievementId) => {
    const achievement = achievements.find(a => a.id === achievementId);
    if (achievement && !achievement.unlocked) {
      achievement.unlocked = true;
      setUnlockedAchievements(prev => [...prev, achievement]);
      setInfluencePoints(prev => prev + achievement.points);
      setShowUnlockAnimation(true);
      
      setTimeout(() => setShowUnlockAnimation(false), 3000);
    }
  };

  const getOrbitRadius = (orbit) => {
    return orbit === 1 ? 150 : 220;
  };

  const getAchievementPosition = (achievement) => {
    const radius = getOrbitRadius(achievement.orbit);
    const angle = achievement.angle * Math.PI / 180;
    return {
      x: Math.cos(angle) * radius,
      y: Math.sin(angle) * radius
    };
  };

  const AchievementBadge = ({ achievement, index }) => {
    const position = getAchievementPosition(achievement);
    const isUnlocked = achievement.unlocked;

    return (
      <motion.div
        className={`achievement-badge ${isUnlocked ? 'unlocked' : 'locked'} ${achievement.rarity}`}
        style={{
          transform: `translate(${position.x}px, ${position.y}px)`,
          boxShadow: isUnlocked ? rarityGlow[achievement.rarity] : 'none'
        }}
        initial={{ scale: 0, rotate: -180 }}
        animate={{ 
          scale: 1, 
          rotate: 0,
          y: [0, -5, 0]
        }}
        transition={{
          scale: { delay: index * 0.1, type: "spring", stiffness: 200 },
          rotate: { delay: index * 0.1, duration: 0.8 },
          y: { 
            duration: 2, 
            repeat: Infinity, 
            delay: index * 0.3,
            ease: "easeInOut"
          }
        }}
        whileHover={isUnlocked ? { 
          scale: 1.2, 
          boxShadow: `${rarityGlow[achievement.rarity]}, 0 0 50px ${rarityColors[achievement.rarity]}80`
        } : {}}
        onClick={() => handleAchievementClick(achievement)}
      >
        <div className="badge-icon">
          {achievement.icon}
        </div>
        <div className="badge-glow"></div>
        {!isUnlocked && <div className="lock-overlay">🔒</div>}
        
        {/* Частицы для разблокированных достижений */}
        {isUnlocked && (
          <div className="particle-system">
            {[...Array(8)].map((_, i) => (
              <motion.div
                key={i}
                className="particle"
                animate={{
                  scale: [0, 1, 0],
                  opacity: [0, 1, 0],
                  x: Math.cos(i * 45 * Math.PI / 180) * 30,
                  y: Math.sin(i * 45 * Math.PI / 180) * 30
                }}
                transition={{
                  duration: 2,
                  repeat: Infinity,
                  delay: i * 0.2
                }}
              />
            ))}
          </div>
        )}
      </motion.div>
    );
  };

  const UnlockAnimation = () => (
    <AnimatePresence>
      {showUnlockAnimation && (
        <motion.div
          className="unlock-animation"
          initial={{ opacity: 0, scale: 0 }}
          animate={{ opacity: 1, scale: 1 }}
          exit={{ opacity: 0, scale: 0 }}
        >
          <motion.div
            className="unlock-burst"
            animate={{
              scale: [1, 3, 1],
              rotate: [0, 360],
              opacity: [1, 0.5, 1]
            }}
            transition={{ duration: 2, repeat: 2 }}
          >
            ✨
          </motion.div>
          <motion.h3
            initial={{ y: 50, opacity: 0 }}
            animate={{ y: 0, opacity: 1 }}
            transition={{ delay: 0.5 }}
          >
            Достижение Разблокировано!
          </motion.h3>
        </motion.div>
      )}
    </AnimatePresence>
  );

  return (
    <div className="achievement-orbit">
      <motion.div 
        className="orbit-header"
        initial={{ opacity: 0, y: -30 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.8 }}
      >
        <h2>Орбита Достижений</h2>
        <div className="orbit-stats">
          <div className="stat-item">
            <span className="stat-value">{unlockedAchievements.length}</span>
            <span className="stat-label">Разблокировано</span>
          </div>
          <div className="stat-item">
            <span className="stat-value">{achievements.length}</span>
            <span className="stat-label">Всего</span>
          </div>
          <div className="stat-item">
            <span className="stat-value">
              {unlockedAchievements.reduce((sum, a) => sum + a.points, 0)}
            </span>
            <span className="stat-label">Очков получено</span>
          </div>
        </div>
      </motion.div>

      <div className="orbit-container">
        {/* Центральный аватар */}
        <motion.div 
          className="central-avatar"
          animate={{ rotate: 360 }}
          transition={{ duration: 20, repeat: Infinity, ease: "linear" }}
        >
          <div className="avatar-ring">
            <div className="avatar-image">
              <img src="/api/avatar" alt="User Avatar" />
            </div>
            <div className="level-indicator">
              <span>{userLevel}</span>
            </div>
          </div>
        </motion.div>

        {/* Орбитальные кольца */}
        <div className="orbit-ring orbit-1"></div>
        <div className="orbit-ring orbit-2"></div>

        {/* Достижения */}
        {achievements.map((achievement, index) => (
          <AchievementBadge 
            key={achievement.id} 
            achievement={achievement} 
            index={index}
          />
        ))}

        {/* Анимация разблокировки */}
        <UnlockAnimation />
      </div>

      {/* Детали выбранного достижения */}
      <AnimatePresence>
        {selectedAchievement && (
          <motion.div
            className="achievement-detail"
            initial={{ opacity: 0, y: 50, scale: 0.8 }}
            animate={{ opacity: 1, y: 0, scale: 1 }}
            exit={{ opacity: 0, y: 50, scale: 0.8 }}
            transition={{ type: "spring", stiffness: 300, damping: 30 }}
          >
            <div className="detail-header">
              <div 
                className={`detail-icon ${selectedAchievement.rarity}`}
                style={{ boxShadow: rarityGlow[selectedAchievement.rarity] }}
              >
                {selectedAchievement.icon}
              </div>
              <div className="detail-info">
                <h3>{selectedAchievement.name}</h3>
                <p>{selectedAchievement.description}</p>
                <div className="detail-meta">
                  <span className={`rarity ${selectedAchievement.rarity}`}>
                    {selectedAchievement.rarity.toUpperCase()}
                  </span>
                  <span className="points">+{selectedAchievement.points} IP</span>
                </div>
              </div>
              <button 
                className="close-btn"
                onClick={() => setSelectedAchievement(null)}
              >
                ✕
              </button>
            </div>
            
            <div className="achievement-progress">
              <div className="progress-bar">
                <motion.div 
                  className="progress-fill"
                  initial={{ width: 0 }}
                  animate={{ width: selectedAchievement.unlocked ? '100%' : '0%' }}
                  transition={{ duration: 1, delay: 0.3 }}
                  style={{ backgroundColor: rarityColors[selectedAchievement.rarity] }}
                />
              </div>
              <span className="progress-text">
                {selectedAchievement.unlocked ? 'Завершено' : 'В процессе'}
              </span>
            </div>
          </motion.div>
        )}
      </AnimatePresence>

      {/* Легенда редкости */}
      <motion.div 
        className="rarity-legend"
        initial={{ opacity: 0, x: 50 }}
        animate={{ opacity: 1, x: 0 }}
        transition={{ delay: 1 }}
      >
        <h4>Редкость</h4>
        {Object.entries(rarityColors).map(([rarity, color]) => (
          <div key={rarity} className="legend-item">
            <div 
              className="legend-color" 
              style={{ backgroundColor: color, boxShadow: `0 0 10px ${color}` }}
            ></div>
            <span>{rarity.charAt(0).toUpperCase() + rarity.slice(1)}</span>
          </div>
        ))}
      </motion.div>

      {/* Кнопка для тестирования разблокировки */}
      <motion.button
        className="test-unlock-btn"
        onClick={() => unlockAchievement('blog_master')}
        whileHover={{ scale: 1.05 }}
        whileTap={{ scale: 0.95 }}
      >
        🎁 Разблокировать достижение
      </motion.button>
    </div>
  );
};

export default AchievementOrbit;
5. CommunityPulse.jsx — пульс сообщества
import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import './CommunityPulse.css';

const CommunityPulse = ({ userLevel, influencePoints }) => {
  const [pulseData, setPulseData] = useState([]);
  const [activeUsers, setActiveUsers] = useState([]);
  const [communityEvents, setCommunityEvents] = useState([]);
  const [selectedEvent, setSelectedEvent] = useState(null);
  const [heartbeatIntensity, setHeartbeatIntensity] = useState(1);

  const mockUsers = [
    { id: 1, name: 'Анна Путешественница', avatar: '👩‍🦰', status: 'online', activity: 'Планирует маршрут в Японию', influence: 1250 },
    { id: 2, name: 'Максим Исследователь', avatar: '👨‍🦱', status: 'active', activity: 'Ведет блог из Исландии', influence: 980 },
    { id: 3, name: 'Елена Гид', avatar: '👩‍🦳', status: 'online', activity: 'Отвечает в чате новичков', influence: 2100 },
    { id: 4, name: 'Дмитрий Фотограф', avatar: '👨‍🦲', status: 'away', activity: 'Загружает фото из Норвегии', influence: 750 }
  ];

  const mockEvents = [
    {
      id: 1,
      type: 'achievement',
      user: 'Анна Путешественница',
      action: 'получила достижение "Мастер Планирования"',
      time: '2 мин назад',
      icon: '🏆',
      color: '#ffd93d'
    },
    {
      id: 2,
      type: 'social',
      user: 'Максим Исследователь',
      action: 'создал новый чат "Северное сияние"',
      time: '5 мин назад',
      icon: '💬',
      color: '#4ecdc4'
    },
    {
      id: 3,
      type: 'content',
      user: 'Елена Гид',
      action: 'опубликовала пост "Секреты Альп"',
      time: '8 мин назад',
      icon: '📝',
      color: '#ff6b6b'
    },
    {
      id: 4,
      type: 'travel',
      user: 'Дмитрий Фотограф',
      action: 'отметился в локации "Лофотенские острова"',
      time: '12 мин назад',
      icon: '📍',
      color: '#00ff88'
    }
  ];

  useEffect(() => {
    setActiveUsers(mockUsers);
    setCommunityEvents(mockEvents);
    
    // Симуляция пульса сообщества
    const pulseInterval = setInterval(() => {
      const newIntensity = 0.5 + Math.random() * 1.5;
      setHeartbeatIntensity(newIntensity);
      
      // Добавляем новые события случайно
      if (Math.random() > 0.7) {
        const newEvent = {
          id: Date.now(),
          type: ['achievement', 'social', 'content', 'travel'][Math.floor(Math.random() * 4)],
          user: mockUsers[Math.floor(Math.random() * mockUsers.length)].name,
          action: 'выполнил новое действие',
          time: 'только что',
          icon: ['🏆', '💬', '📝', '📍'][Math.floor(Math.random() * 4)],
          color: ['#ffd93d', '#4ecdc4', '#ff6b6b', '#00ff88'][Math.floor(Math.random() * 4)]
        };
        
        setCommunityEvents(prev => [newEvent, ...prev.slice(0, 9)]);
      }
    }, 3000);

    return () => clearInterval(pulseInterval);
  }, []);

  const HeartbeatVisualization = () => (
    <div className="heartbeat-container">
      <motion.div
        className="heartbeat-core"
        animate={{
          scale: [1, 1.2 * heartbeatIntensity, 1],
          opacity: [0.8, 1, 0.8]
        }}
        transition={{
          duration: 1.5,
          repeat: Infinity,
          ease: "easeIn
        transition={{
          duration: 1.5,
          repeat: Infinity,
          ease: "easeInOut"
        }}
      >
        <div className="pulse-ring pulse-ring-1"></div>
        <div className="pulse-ring pulse-ring-2"></div>
        <div className="pulse-ring pulse-ring-3"></div>
        <div className="heartbeat-icon">💓</div>
      </motion.div>
      
      <div className="pulse-intensity">
        <span>Активность сообщества</span>
        <div className="intensity-bar">
          <motion.div 
            className="intensity-fill"
            animate={{ width: `${heartbeatIntensity * 50}%` }}
            style={{ backgroundColor: heartbeatIntensity > 1.2 ? '#ff6b6b' : '#00ff88' }}
          />
        </div>
      </div>
    </div>
  );

  const UserConnection = ({ user, index }) => (
    <motion.div
      className={`user-connection ${user.status}`}
      initial={{ opacity: 0, scale: 0 }}
      animate={{ opacity: 1, scale: 1 }}
      transition={{ delay: index * 0.1 }}
      whileHover={{ scale: 1.1, zIndex: 10 }}
    >
      <div className="connection-line"></div>
      <div className="user-node">
        <div className="user-avatar">{user.avatar}</div>
        <div className={`status-indicator ${user.status}`}></div>
        <motion.div
          className="influence-aura"
          animate={{
            scale: [1, 1.1, 1],
            opacity: [0.5, 0.8, 0.5]
          }}
          transition={{
            duration: 2,
            repeat: Infinity,
            delay: index * 0.3
          }}
          style={{ 
            backgroundColor: user.influence > 1500 ? '#ffd93d' : 
                            user.influence > 1000 ? '#00ff88' : '#4ecdc4'
          }}
        />
      </div>
      <div className="user-info">
        <div className="user-name">{user.name}</div>
        <div className="user-activity">{user.activity}</div>
        <div className="user-influence">{user.influence} IP</div>
      </div>
    </motion.div>
  );

  const ActivityStream = () => (
    <div className="activity-stream">
      <h3>Поток Активности</h3>
      <div className="stream-container">
        <AnimatePresence>
          {communityEvents.map((event, index) => (
            <motion.div
              key={event.id}
              className={`activity-item ${event.type}`}
              initial={{ opacity: 0, x: -50, scale: 0.8 }}
              animate={{ opacity: 1, x: 0, scale: 1 }}
              exit={{ opacity: 0, x: 50, scale: 0.8 }}
              transition={{ delay: index * 0.05 }}
              onClick={() => setSelectedEvent(event)}
              whileHover={{ scale: 1.02, boxShadow: `0 5px 20px ${event.color}40` }}
            >
              <div 
                className="activity-icon"
                style={{ backgroundColor: event.color }}
              >
                {event.icon}
              </div>
              <div className="activity-content">
                <div className="activity-text">
                  <strong>{event.user}</strong> {event.action}
                </div>
                <div className="activity-time">{event.time}</div>
              </div>
              <motion.div
                className="activity-ripple"
                animate={{
                  scale: [1, 2],
                  opacity: [0.5, 0]
                }}
                transition={{
                  duration: 2,
                  repeat: Infinity,
                  delay: index * 0.2
                }}
                style={{ backgroundColor: event.color }}
              />
            </motion.div>
          ))}
        </AnimatePresence>
      </div>
    </div>
  );

  const CollaborativeAchievements = () => {
    const achievements = [
      { name: 'Глобальная Экспедиция', progress: 75, participants: 234, icon: '🌍' },
      { name: 'Миллион Фотографий', progress: 60, participants: 1847, icon: '📸' },
      { name: 'Сеть Наставников', progress: 90, participants: 89, icon: '🎓' }
    ];

    return (
      <div className="collaborative-achievements">
        <h3>Коллективные Достижения</h3>
        {achievements.map((achievement, index) => (
          <motion.div
            key={achievement.name}
            className="collab-achievement"
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: index * 0.2 }}
            whileHover={{ scale: 1.05 }}
          >
            <div className="achievement-header">
              <span className="achievement-icon">{achievement.icon}</span>
              <div className="achievement-info">
                <h4>{achievement.name}</h4>
                <span className="participants">{achievement.participants} участников</span>
              </div>
            </div>
            <div className="progress-container">
              <div className="progress-bar">
                <motion.div
                  className="progress-fill"
                  initial={{ width: 0 }}
                  animate={{ width: `${achievement.progress}%` }}
                  transition={{ duration: 1.5, delay: index * 0.3 }}
                />
              </div>
              <span className="progress-text">{achievement.progress}%</span>
            </div>
          </motion.div>
        ))}
      </div>
    );
  };

  return (
    <div className="community-pulse">
      <motion.div 
        className="pulse-header"
        initial={{ opacity: 0, y: -30 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.8 }}
      >
        <h2>Пульс Сообщества</h2>
        <div className="community-stats">
          <div className="stat-item">
            <span className="stat-value">{activeUsers.length}</span>
            <span className="stat-label">Онлайн</span>
          </div>
          <div className="stat-item">
            <span className="stat-value">1,247</span>
            <span className="stat-label">Всего участников</span>
          </div>
          <div className="stat-item">
            <span className="stat-value">89</span>
            <span className="stat-label">Стран</span>
          </div>
        </div>
      </motion.div>

      <div className="pulse-visualization">
        <HeartbeatVisualization />
        
        <div className="network-container">
          <div className="network-center">
            <motion.div
              className="community-core"
              animate={{ rotate: 360 }}
              transition={{ duration: 30, repeat: Infinity, ease: "linear" }}
            >
              🌐
            </motion.div>
          </div>
          
          {activeUsers.map((user, index) => {
            const angle = (index * 90) * Math.PI / 180;
            const radius = 120;
            return (
              <div
                key={user.id}
                style={{
                  position: 'absolute',
                  left: '50%',
                  top: '50%',
                  transform: `translate(-50%, -50%) translate(${Math.cos(angle) * radius}px, ${Math.sin(angle) * radius}px)`
                }}
              >
                <UserConnection user={user} index={index} />
              </div>
            );
          })}
        </div>
      </div>

      <div className="pulse-content">
        <ActivityStream />
        <CollaborativeAchievements />
      </div>

      {/* Детали события */}
      <AnimatePresence>
        {selectedEvent && (
          <motion.div
            className="event-detail-overlay"
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            onClick={() => setSelectedEvent(null)}
          >
            <motion.div
              className="event-detail"
              initial={{ scale: 0.8, y: 50 }}
              animate={{ scale: 1, y: 0 }}
              exit={{ scale: 0.8, y: 50 }}
              onClick={(e) => e.stopPropagation()}
            >
              <div className="detail-header">
                <div 
                  className="detail-icon"
                  style={{ backgroundColor: selectedEvent.color }}
                >
                  {selectedEvent.icon}
                </div>
                <div className="detail-info">
                  <h3>{selectedEvent.user}</h3>
                  <p>{selectedEvent.action}</p>
                  <span className="detail-time">{selectedEvent.time}</span>
                </div>
                <button 
                  className="close-btn"
                  onClick={() => setSelectedEvent(null)}
                >
                  ✕
                </button>
              </div>
              
              <div className="detail-actions">
                <motion.button
                  className="action-btn like"
                  whileHover={{ scale: 1.05 }}
                  whileTap={{ scale: 0.95 }}
                >
                  👍 Поддержать
                </motion.button>
                <motion.button
                  className="action-btn comment"
                  whileHover={{ scale: 1.05 }}
                  whileTap={{ scale: 0.95 }}
                >
                  💬 Комментировать
                </motion.button>
                <motion.button
                  className="action-btn share"
                  whileHover={{ scale: 1.05 }}
                  whileTap={{ scale: 0.95 }}
                >
                  📤 Поделиться
                </motion.button>
              </div>
            </motion.div>
          </motion.div>
        )}
      </AnimatePresence>

      {/* Плавающие частицы активности */}
      <div className="activity-particles">
        {[...Array(20)].map((_, i) => (
          <motion.div
            key={i}
            className="activity-particle"
            animate={{
              y: [-20, -100],
              opacity: [0, 1, 0],
              scale: [0.5, 1, 0.5]
            }}
            transition={{
              duration: 3,
              repeat: Infinity,
              delay: i * 0.2,
              ease: "easeOut"
            }}
            style={{
              left: `${Math.random() * 100}%`,
              animationDelay: `${Math.random() * 3}s`
            }}
          >
            {['✨', '💫', '⭐', '🌟'][Math.floor(Math.random() * 4)]}
          </motion.div>
        ))}
      </div>
    </div>
  );
};

export default CommunityPulse;
6. TrendNebula.jsx — Туманность трендов
import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import './TrendNebula.css';

const TrendNebula = ({ userLevel, influencePoints }) => {
  const [trends, setTrends] = useState([]);
  const [selectedTrend, setSelectedTrend] = useState(null);
  const [nebulaIntensity, setNebulaIntensity] = useState(1);
  const [filterCategory, setFilterCategory] = useState('all');

  const trendData = [
    {
      id: 'sustainable_travel',
      name: 'Экологичные Путешествия',
      category: 'travel',
      popularity: 85,
      growth: 23,
      participants: 1247,
      color: '#00ff88',
      icon: '🌱',
      description: 'Путешествия с минимальным воздействием на окружающую среду',
      tags: ['эко', 'природа', 'ответственность'],
      size: 'large'
    },
    {
      id: 'digital_nomad',
      name: 'Цифровое Кочевничество',
      category: 'lifestyle',
      popularity: 92,
      growth: 45,
      participants: 2156,
      color: '#4ecdc4',
      icon: '💻',
      description: 'Работа из любой точки мира',
      tags: ['удаленка', 'свобода', 'технологии'],
      size: 'large'
    },
    {
      id: 'micro_adventures',
      name: 'Микро-Приключения',
      category: 'adventure',
      popularity: 67,
      growth: 12,
      participants: 834,
      color: '#ff6b6b',
      icon: '🎒',
      description: 'Короткие приключения рядом с домом',
      tags: ['локально', 'быстро', 'доступно'],
      size: 'medium'
    },
    {
      id: 'food_tourism',
      name: 'Гастрономический Туризм',
      category: 'culture',
      popularity: 78,
      growth: 18,
      participants: 1456,
      color: '#ffd93d',
      icon: '🍜',
      description: 'Путешествия ради кулинарных открытий',
      tags: ['еда', 'культура', 'традиции'],
      size: 'medium'
    },
    {
      id: 'wellness_retreats',
      name: 'Велнес Ретриты',
      category: 'health',
      popularity: 71,
      growth: 31,
      participants: 967,
      color: '#a8e6cf',
      icon: '🧘',
      description: 'Путешествия для восстановления и здоровья',
      tags: ['здоровье', 'медитация', 'релакс'],
      size: 'medium'
    },
    {
      id: 'space_tourism',
      name: 'Космический Туризм',
      category: 'future',
      popularity: 34,
      growth: 156,
      participants: 89,
      color: '#9933ff',
      icon: '🚀',
      description: 'Будущее путешествий за пределы Земли',
      tags: ['космос', 'будущее', 'технологии'],
      size: 'small'
    }
  ];

  const categories = [
    { id: 'all', name: 'Все', icon: '🌌' },
    { id: 'travel', name: 'Путешествия', icon: '✈️' },
    { id: 'lifestyle', name: 'Образ жизни', icon: '🏠' },
    { id: 'adventure', name: 'Приключения', icon: '⛰️' },
    { id: 'culture', name: 'Культура', icon: '🎭' },
    { id: 'health', name: 'Здоровье', icon: '💚' },
    { id: 'future', name: 'Будущее', icon: '🔮' }
  ];

  useEffect(() => {
    setTrends(trendData);
    
    // Симуляция изменения интенсивности туманности
    const nebulaInterval = setInterval(() => {
      setNebulaIntensity(0.5 + Math.random() * 1.5);
    }, 2000);

    return () => clearInterval(nebulaInterval);
  }, []);

  const filteredTrends = filterCategory === 'all' 
    ? trends 
    : trends.filter(trend => trend.category === filterCategory);

  const getTrendPosition = (index, total) => {
    const angle = (index * 360 / total) * Math.PI / 180;
    const radius = 150 + Math.random() * 100;
    return {
      x: Math.cos(angle) * radius,
      y: Math.sin(angle) * radius
    };
  };

  const getTrendSize = (trend) => {
    const baseSize = trend.size === 'large' ? 80 : trend.size === 'medium' ? 60 : 40;
    const popularityMultiplier = 1 + (trend.popularity / 100) * 0.5;
    return baseSize * popularityMultiplier;
  };

  const TrendCloud = ({ trend, index, total }) => {
    const position = getTrendPosition(index, total);
    const size = getTrendSize(trend);
    
    return (
      <motion.div
        className={`trend-cloud ${trend.size}`}
        style={{
          transform: `translate(${position.x}px, ${position.y}px)`,
          width: size,
          height: size
        }}
        initial={{ opacity: 0, scale: 0 }}
        animate={{ 
          opacity: 0.7 + (trend.popularity / 100) * 0.3,
          scale: 1,
          y: [0, -10, 0]
        }}
        transition={{
          scale: { delay: index * 0.1, type: "spring" },
          y: { 
            duration: 3 + Math.random() * 2, 
            repeat: Infinity, 
            delay: index * 0.2 
          }
        }}
        whileHover={{ 
          scale: 1.2, 
          opacity: 1,
          boxShadow: `0 0 30px ${trend.color}80`
        }}
        onClick={() => setSelectedTrend(trend)}
      >
        <div 
          className="cloud-core"
          style={{ backgroundColor: trend.color }}
        >
          <span className="cloud-icon">{trend.icon}</span>
        </div>
        
        <div className="cloud-glow" style={{ backgroundColor: trend.color }}></div>
        
        <motion.div
          className="popularity-ring"
          animate={{ rotate: 360 }}
          transition={{ duration: 10, repeat: Infinity, ease: "linear" }}
          style={{ borderColor: trend.color }}
        />
        
        <div className="trend-info">
          <div className="trend-name">{trend.name}</div>
          <div className="trend-stats">
            <span className="popularity">{trend.popularity}%</span>
            <span className={`growth ${trend.growth > 20 ? 'high' : 'normal'}`}>
              +{trend.growth}%
            </span>
          </div>
        </div>

        {/* Частицы для популярных трендов */}
        {trend.popularity > 80 && (
          <div className="trend-particles">
            {[...Array(6)].map((_, i) => (
              <motion.div
                key={i}
                className="trend-particle"
                animate={{
                  scale: [0, 1, 0],
                  opacity: [0, 1, 0],
                  x: Math.cos(i * 60 * Math.PI / 180) * 20,
                  y: Math.sin(i * 60 * Math.PI / 180) * 20
                }}
                transition={{
                  duration: 2,
                  repeat: Infinity,
                  delay: i * 0.3
                }}
                style={{ backgroundColor: trend.color }}
              />
            ))}
          </div>
        )}
      </motion.div>
    );
  };

  const NebulaBackground = () => (
    <div className="nebula-background">
      <motion.div
        className="nebula-layer nebula-1"
        animate={{
          scale: [1, 1.1, 1],
          opacity: [0.3, 0.5, 0.3],
          rotate: [0, 360]
        }}
        transition={{
          duration: 20,
          repeat: Infinity,
          ease: "linear"
        }}
        style={{ filter: `blur(${nebulaIntensity * 2}px)` }}
      />
      <motion.div
        className="nebula-layer nebula-2"
        animate={{
          scale: [1.1, 1, 1.1],
          opacity: [0.2, 0.4, 0.2],
          rotate: [360, 0]
        }}
        transition={{
          duration: 25,
          repeat: Infinity,
          ease: "linear"
        }}
        style={{ filter: `blur(${nebulaIntensity * 3}px)` }}
      />
    </div>
  );

  const TrendPredictor = () => {
    const predictions = [
      { trend: 'VR Путешествия', probability: 78, timeframe: '2024' },
      { trend: 'Подводный Туризм', probability: 45, timeframe: '2025' },
      { trend: 'Лунные Экскурсии', probability: 12, timeframe: '2030' }
    ];

    return (
      <motion.div
        className="trend-predictor"
        initial={{ opacity: 0, x: 50 }}
        animate={{ opacity: 1, x: 0 }}
        transition={{ delay: 1 }}
      >
        <h3>Предсказания Трендов</h3>
        {predictions.map((prediction, index) => (
          <motion.div
            key={prediction.trend}
            className="prediction-item"
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 1.2 + index * 0.2 }}
          >
            <div className="prediction-info">
              <span className="prediction-name">{prediction.trend}</span>
              <span className="prediction-timeframe">{prediction.timeframe}</span>
            </div>
            <div className="probability-bar">
              <motion.div
                className="probability-fill"
                initial={{ width: 0 }}
                animate={{ width: `${prediction.probability}%` }}
                transition={{ duration: 1.5, delay: 1.5 + index * 0.2 }}
                style={{ 
                  backgroundColor: prediction.probability > 60 ? '#00ff88' : 
                                 prediction.probability > 30 ? '#ffd93d' : '#ff6b6b'
                }}
              />
            </div>
            <span className="probability-value">{prediction.probability}%</span>
          </motion.div>
        ))}
      </motion.div>
    );
  };

  return (
    <div className="trend-nebula">
      <motion.div 
        className="nebula-header"
        initial={{ opacity: 0, y: -30 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.8 }}
      >
        <h2>Туманность Трендов</h2>
        <div className="category-filters">
          {categories.map(category => (
            <motion.button
              key={category.id}
              className={`filter-btn ${filterCategory === category.id ? 'active' : ''}`}
              onClick={() => setFilterCategory(category.id)}
              whileHover={{ scale: 1.05 }}
              whileTap={{ scale: 0.95 }}
            >
              <span className="filter-icon">{category.icon}</span>
              {category.name}
            </motion.button>
          ))}
        </div>
      </motion.div>

      <div className="nebula-container">
        <NebulaBackground />
        
        <div className="trends-space">
          <AnimatePresence>
            {filteredTrends.map((trend, index) => (
              <TrendCloud 
                key={trend.id} 
                trend={trend} 
                index={index}
                total={filteredTrends.length}
              />
            ))}
          </AnimatePresence>
        </div>

        <TrendPredictor />
      </div>

      {/* Детали выбранного тренда */}
      <AnimatePresence>
        {selectedTrend && (
          <motion.div
            className="trend-detail-overlay"
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            onClick={() => setSelectedTrend(null)}
          >
            <motion.div
              className="trend-detail"
              initial={{ scale: 0.8, y: 50 }}
              animate={{ scale: 1, y: 0 }}
              exit={{ scale: 0.8, y: 50 }}
              onClick={(e) => e.stopPropagation()}
            >
              <div className="detail-header">
                <div 
                  className="detail-icon"
                  style={{ backgroundColor: selectedTrend.color }}
                >
                  {selectedTrend.icon}
                </div>
                <div className="detail-info">
                  <h3>{selectedTrend.name}</h3>
                  <p>{selectedTrend.description}</p>
                </div>
                <button 
                  className="close-btn"
                  onClick={() => setSelectedTrend(null)}
                >
                  ✕
                </button>
              </div>
              
              <div className="detail-stats">
                <div className="stat-item">
                  <span className="stat-label">Популярность</span>
                  <div className="stat-bar">
                    <motion.div
                      className="stat-fill"
                      initial={{ width: 0 }}
                      animate={{ width: `${selectedTrend.popularity}%` }}
                      style={{ backgroundColor: selectedTrend.color }}
                    />
                  </div>
                  <span className="stat-value">{selectedTrend.popularity}%</span>
                </div>
                
                <div className="stat-item">
                  <span className="stat-label">Рост</span>
                  <div className="stat-bar">
                    <motion.div
                      className="stat-fill"
                      initial={{ width: 0 }}
                      animate={{ width: `${Math.min(selectedTrend.growth, 100)}%` }}
                      style={{ backgroundColor: '#00ff88' }}
                    />
                  </div>
                  <span className="stat-value">+{selectedTrend.growth}%</span>
                </div>
                
                <div className="stat-item">
                  <span className="stat-label">Участники</span>
                  <span className="stat-value">{selectedTrend.participants.toLocaleString()}</span>
                </div>
              </div>

              <div className="detail-tags">
                {selectedTrend.tags.map(tag => (
                  <span key={tag} className="tag" style={{ borderColor: selectedTrend.color }}>
                    #{tag}
                  </span>
                ))}
              </div>

              <div className="detail-actions">
                <motion.button
                  className="action-btn join"
                  style={{ backgroundColor: selectedTrend.color }}
                  whileHover={{ scale: 1.05 }}
                  whileTap={{ scale: 0.95 }}
                >
                  🚀 Присоединиться
                </motion.button>
                <motion.button
                  className="action-btn follow"
                  whileHover={{ scale: 1.05 }}
                  whileTap={{ scale: 0.95 }}
                >
                  👁️ Следить
                </motion.button>
                <motion.button
                  className="action-btn share"
                  whileHover={{ scale: 1.05 }}
                  whileTap={{ scale: 0.95 }}
                >
                  📤 Поделиться
                </motion.button>
              </div>
            </motion.div>
          </motion.div>
        )}
      </AnimatePresence>

      {/* Индикатор активности туманности */}
      <motion.div
        className="nebula-intensity-indicator"
        animate={{
          opacity: [0.5, 1, 0.5],
          scale: [1, 1.1, 1]
        }}
        transition={{
          duration: 2,
          repeat: Infinity
        }}
      >
        <div className="intensity-core">
          <span>🌌</span>
        </div>
        <div className="intensity-label">
          Активность: {Math.round(nebulaIntensity * 100)}%
        </div>
      </motion.div>
    </div>
  );
};

export default TrendNebula;
7. MotivationEngine.jsx — двигатель мотивации
import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import './MotivationEngine.css';

const MotivationEngine = ({ userLevel, influencePoints, setInfluencePoints }) => {
  const [fuelLevel, setFuelLevel] = useState(75);
  const [engineState, setEngineState] = useState('idle'); // idle, charging, boosted
  const [activeChallenges, setActiveChallenges] = useState([]);
  const [completedGoals, setCompletedGoals] = useState([]);
  const [motivationQuote, setMotivationQuote] = useState('');
  const [boostMultiplier, setBoostMultiplier] = useState(1);

  const motivationQuotes = [
    "Путешествие в тысячу миль начинается с одного шага",
    "Мир - это книга, и те, кто не путешествует, читают только одну страницу",
    "Приключения ждут тех, кто готов их искать",
    "Каждое путешествие меняет нас навсегда",
    "Границы существуют только в нашем воображении"
  ];

  const challenges = [
    {
      id: 'daily_post',
      title: 'Ежедневный Пост',
      description: 'Опубликуйте пост о своих путешествиях',
      type: 'daily',
      reward: 50,
      progress: 0,
      target: 1,
      icon: '📝',
      difficulty: 'easy',
      timeLeft: '18:30:45'
    },
    {
      id: 'new_connection',
      title: 'Новые Связи',
      description: 'Познакомьтесь с 3 новыми путешественниками',
      type: 'social',
      reward: 150,
      progress: 1,
      target: 3,
      icon: '🤝',
      difficulty: 'medium',
      timeLeft: '2 дня'
    },

    {
      id: 'route_master',
      title: 'Мастер Маршрутов',
      description: 'Создайте 5 детальных маршрутов',
      type: 'planning',
      reward: 300,
      progress: 2,
      target: 5,
      icon: '🗺️',
      difficulty: 'hard',
      timeLeft: '1 неделя'
    },
    {
      id: 'photo_challenge',
      title: 'Фото Челлендж',
      description: 'Загрузите 10 уникальных фотографий',
      type: 'content',
      reward: 200,
      progress: 7,
      target: 10,
      icon: '📸',
      difficulty: 'medium',
      timeLeft: '3 дня'
    },
    {
      id: 'mentor_help',
      title: 'Помощь Новичкам',
      description: 'Помогите 2 новичкам с планированием',
      type: 'mentoring',
      reward: 400,
      progress: 0,
      target: 2,
      icon: '🎓',
      difficulty: 'hard',
      timeLeft: '5 дней'
    }
  ];

  const goals = [
    {
      id: 'level_20',
      title: 'Достичь 20 уровня',
      description: 'Поднимите свой уровень до 20',
      progress: userLevel,
      target: 20,
      reward: 1000,
      icon: '⭐',
      category: 'progression'
    },
    {
      id: 'influence_5k',
      title: '5000 Очков Влияния',
      description: 'Накопите 5000 очков влияния',
      progress: influencePoints,
      target: 5000,
      reward: 500,
      icon: '⚡',
      category: 'influence'
    },
    {
      id: 'countries_10',
      title: '10 Стран',
      description: 'Посетите 10 разных стран',
      progress: 6,
      target: 10,
      reward: 750,
      icon: '🌍',
      category: 'travel'
    }
  ];

  useEffect(() => {
    setActiveChallenges(challenges);
    setMotivationQuote(motivationQuotes[Math.floor(Math.random() * motivationQuotes.length)]);
    
    // Симуляция изменения уровня топлива
    const fuelInterval = setInterval(() => {
      setFuelLevel(prev => {
        const newLevel = Math.max(0, prev - 1 + Math.random() * 3);
        if (newLevel < 20) {
          setEngineState('low');
        } else if (newLevel > 80) {
          setEngineState('boosted');
        } else {
          setEngineState('normal');
        }
        return newLevel;
      });
    }, 5000);

    return () => clearInterval(fuelInterval);
  }, []);

  const completeChallenge = (challengeId) => {
    const challenge = activeChallenges.find(c => c.id === challengeId);
    if (challenge) {
      setInfluencePoints(prev => prev + challenge.reward * boostMultiplier);
      setActiveChallenges(prev => prev.filter(c => c.id !== challengeId));
      setFuelLevel(prev => Math.min(100, prev + 15));
      
      // Эффект завершения
      setEngineState('charging');
      setTimeout(() => setEngineState('normal'), 2000);
    }
  };

  const activateBoost = () => {
    if (fuelLevel >= 50) {
      setBoostMultiplier(2);
      setFuelLevel(prev => prev - 50);
      setEngineState('boosted');
      
      setTimeout(() => {
        setBoostMultiplier(1);
        setEngineState('normal');
      }, 30000); // 30 секунд буста
    }
  };

  const EngineCore = () => (
    <div className="engine-core">
      <motion.div
        className={`engine-reactor ${engineState}`}
        animate={{
          scale: engineState === 'boosted' ? [1, 1.2, 1] : [1, 1.05, 1],
          rotate: 360
        }}
        transition={{
          scale: { duration: 1, repeat: Infinity },
          rotate: { duration: engineState === 'boosted' ? 2 : 4, repeat: Infinity, ease: "linear" }
        }}
      >
        <div className="reactor-core">
          <span className="reactor-icon">🚀</span>
        </div>
        <div className="reactor-rings">
          <div className="ring ring-1"></div>
          <div className="ring ring-2"></div>
          <div className="ring ring-3"></div>
        </div>
      </motion.div>
      
      <div className="fuel-gauge">
        <div className="gauge-container">
          <motion.div
            className="fuel-fill"
            animate={{ height: `${fuelLevel}%` }}
            style={{
              backgroundColor: fuelLevel > 60 ? '#00ff88' : 
                             fuelLevel > 30 ? '#ffd93d' : '#ff6b6b'
            }}
          />
          <div className="gauge-markers">
            {[25, 50, 75].map(mark => (
              <div key={mark} className="marker" style={{ bottom: `${mark}%` }} />
            ))}
          </div>
        </div>
        <div className="fuel-label">
          <span>Топливо</span>
          <span className="fuel-value">{Math.round(fuelLevel)}%</span>
        </div>
      </div>
    </div>
  );

  const ChallengeCard = ({ challenge, index }) => {
    const progressPercent = (challenge.progress / challenge.target) * 100;
    const isCompleted = challenge.progress >= challenge.target;
    
    const difficultyColors = {
      easy: '#00ff88',
      medium: '#ffd93d',
      hard: '#ff6b6b'
    };

    return (
      <motion.div
        className={`challenge-card ${challenge.difficulty} ${isCompleted ? 'completed' : ''}`}
        initial={{ opacity: 0, x: -50 }}
        animate={{ opacity: 1, x: 0 }}
        transition={{ delay: index * 0.1 }}
        whileHover={{ scale: 1.02, boxShadow: `0 10px 30px ${difficultyColors[challenge.difficulty]}40` }}
      >
        <div className="challenge-header">
          <div className="challenge-icon">{challenge.icon}</div>
          <div className="challenge-info">
            <h4>{challenge.title}</h4>
            <p>{challenge.description}</p>
          </div>
          <div className={`difficulty-badge ${challenge.difficulty}`}>
            {challenge.difficulty.toUpperCase()}
          </div>
        </div>
        
        <div className="challenge-progress">
          <div className="progress-bar">
            <motion.div
              className="progress-fill"
              initial={{ width: 0 }}
              animate={{ width: `${progressPercent}%` }}
              style={{ backgroundColor: difficultyColors[challenge.difficulty] }}
            />
          </div>
          <span className="progress-text">
            {challenge.progress}/{challenge.target}
          </span>
        </div>
        
        <div className="challenge-footer">
          <div className="reward">
            <span className="reward-icon">💎</span>
            <span className="reward-value">
              +{challenge.reward * boostMultiplier} IP
            </span>
            {boostMultiplier > 1 && (
              <span className="boost-indicator">x{boostMultiplier}</span>
            )}
          </div>
          <div className="time-left">
            <span className="time-icon">⏰</span>
            <span>{challenge.timeLeft}</span>
          </div>
        </div>
        
        {isCompleted && (
          <motion.button
            className="complete-btn"
            onClick={() => completeChallenge(challenge.id)}
            whileHover={{ scale: 1.05 }}
            whileTap={{ scale: 0.95 }}
            animate={{
              boxShadow: ['0 0 0 rgba(0,255,136,0)', '0 0 20px rgba(0,255,136,0.8)', '0 0 0 rgba(0,255,136,0)']
            }}
            transition={{ duration: 2, repeat: Infinity }}
          >
            ✅ Завершить
          </motion.button>
        )}
      </motion.div>
    );
  };

  const GoalTracker = () => (
    <div className="goal-tracker">
      <h3>Долгосрочные Цели</h3>
      {goals.map((goal, index) => {
        const progressPercent = Math.min((goal.progress / goal.target) * 100, 100);
        const isCompleted = goal.progress >= goal.target;
        
        return (
          <motion.div
            key={goal.id}
            className={`goal-item ${isCompleted ? 'completed' : ''}`}
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: index * 0.2 }}
          >
            <div className="goal-header">
              <span className="goal-icon">{goal.icon}</span>
              <div className="goal-info">
                <h4>{goal.title}</h4>
                <p>{goal.description}</p>
              </div>
            </div>
            
            <div className="goal-progress">
              <div className="progress-container">
                <div className="progress-bar">
                  <motion.div
                    className="progress-fill"
                    initial={{ width: 0 }}
                    animate={{ width: `${progressPercent}%` }}
                    transition={{ duration: 1.5, delay: index * 0.3 }}
                  />
                </div>
                <span className="progress-value">
                  {goal.progress.toLocaleString()}/{goal.target.toLocaleString()}
                </span>
              </div>
              
              {isCompleted && (
                <motion.div
                  className="completion-badge"
                  initial={{ scale: 0 }}
                  animate={{ scale: 1 }}
                  transition={{ type: "spring", stiffness: 500, delay: 0.5 }}
                >
                  🏆
                </motion.div>
              )}
            </div>
          </motion.div>
        );
      })}
    </div>
  );

  return (
    <div className="motivation-engine">
      <motion.div 
        className="engine-header"
        initial={{ opacity: 0, y: -30 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.8 }}
      >
        <h2>Двигатель Мотивации</h2>
        <motion.div
          className="motivation-quote"
          key={motivationQuote}
          initial={{ opacity: 0, scale: 0.8 }}
          animate={{ opacity: 1, scale: 1 }}
          transition={{ duration: 1 }}
        >
          <span className="quote-icon">💫</span>
          <p>"{motivationQuote}"</p>
        </motion.div>
      </motion.div>

      <div className="engine-dashboard">
        <EngineCore />
        
        <div className="engine-controls">
          <motion.button
            className={`boost-btn ${fuelLevel < 50 ? 'disabled' : ''}`}
            onClick={activateBoost}
            disabled={fuelLevel < 50 || boostMultiplier > 1}
            whileHover={fuelLevel >= 50 ? { scale: 1.05 } : {}}
            whileTap={fuelLevel >= 50 ? { scale: 0.95 } : {}}
          >
            <span className="boost-icon">⚡</span>
            <span>Активировать Буст</span>
            <span className="boost-cost">(-50 топлива)</span>
          </motion.button>
          
          {boostMultiplier > 1 && (
            <motion.div
              className="boost-indicator"
              initial={{ opacity: 0, scale: 0 }}
              animate={{ opacity: 1, scale: 1 }}
              exit={{ opacity: 0, scale: 0 }}
            >
              <span className="boost-text">БУСТ АКТИВЕН!</span>
              <span className="boost-multiplier">x{boostMultiplier}</span>
            </motion.div>
          )}
        </div>
      </div>

      <div className="challenges-section">
        <h3>Активные Вызовы</h3>
        <div className="challenges-grid">
          {activeChallenges.map((challenge, index) => (
            <ChallengeCard key={challenge.id} challenge={challenge} index={index} />
          ))}
        </div>
      </div>

      <GoalTracker />

      {/* Эффекты двигателя */}
      <div className="engine-effects">
        {engineState === 'boosted' && (
          <motion.div
            className="boost-particles"
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
          >
            {[...Array(20)].map((_, i) => (
              <motion.div
                key={i}
                className="boost-particle"
                animate={{
                  y: [-20, -100],
                  opacity: [0, 1, 0],
                  scale: [0.5, 1, 0.5]
                }}
                transition={{
                  duration: 1,
                  repeat: Infinity,
                  delay: i * 0.1
                }}
                style={{
                  left: `${Math.random() * 100}%`,
                  backgroundColor: '#00ff88'
                }}
              />
            ))}
          </motion.div>
        )}
        
        {engineState === 'charging' && (
          <motion.div
            className="charging-effect"
            animate={{
              scale: [1, 1.5, 1],
              opacity: [0.5, 1, 0.5]
            }}
            transition={{ duration: 2 }}
          >
            ⚡
          </motion.div>
        )}
      </div>
    </div>
  );
};

export default MotivationEngine;
Продолжить работу с остальными компонентами? У нас ещё осталось:

Система частиц.jsx
Голографический рисунок.jsx
QuestSystem.jsx
PowerUpCenter.jsx
InsightCrystal.jsx
TravelDNA.jsx
Сеть влияния.jsx
Портал наставников.jsx
Доска мечты.jsx
LegacyBuilder.jsx
Сезонные события.jsx
Персональный музей.jsx
И CSS-файлы для стилизации всех компонентов.


8. ParticleSystem.jsx — система частиц
import React, { useEffect, useRef } from 'react';
import { motion } from 'framer-motion';
import './ParticleSystem.css';

const ParticleSystem = ({ theme = 'cosmic', intensity = 1, interactive = true }) => {
  const canvasRef = useRef(null);
  const particlesRef = useRef([]);
  const mouseRef = useRef({ x: 0, y: 0 });
  const animationRef = useRef();

  const themes = {
    cosmic: {
      colors: ['#00ff88', '#4ecdc4', '#ff6b6b', '#ffd93d', '#9933ff'],
      particleCount: 150,
      speed: 0.5,
      size: { min: 1, max: 4 },
      glow: true
    },
    neon: {
      colors: ['#ff0080', '#00ffff', '#ffff00', '#ff8000', '#8000ff'],
      particleCount: 200,
      speed: 0.8,
      size: { min: 2, max: 6 },
      glow: true
    },
    minimal: {
      colors: ['#ffffff', '#cccccc', '#999999'],
      particleCount: 80,
      speed: 0.3,
      size: { min: 1, max: 2 },
      glow: false
    }
  };

  const currentTheme = themes[theme] || themes.cosmic;

  class Particle {
    constructor(canvas) {
      this.canvas = canvas;
      this.reset();
      this.life = Math.random();
      this.maxLife = 1;
      this.decay = 0.005 + Math.random() * 0.01;
    }

    reset() {
      this.x = Math.random() * this.canvas.width;
      this.y = Math.random() * this.canvas.height;
      this.vx = (Math.random() - 0.5) * currentTheme.speed;
      this.vy = (Math.random() - 0.5) * currentTheme.speed;
      this.size = currentTheme.size.min + Math.random() * (currentTheme.size.max - currentTheme.size.min);
      this.color = currentTheme.colors[Math.floor(Math.random() * currentTheme.colors.length)];
      this.originalSize = this.size;
      this.pulsePhase = Math.random() * Math.PI * 2;
    }

    update(mouseX, mouseY) {
      // Движение частицы
      this.x += this.vx * intensity;
      this.y += this.vy * intensity;

      // Интерактивность с мышью
      if (interactive) {
        const dx = mouseX - this.x;
        const dy = mouseY - this.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance < 100) {
          const force = (100 - distance) / 100;
          this.vx += (dx / distance) * force * 0.01;
          this.vy += (dy / distance) * force * 0.01;
          this.size = this.originalSize * (1 + force);
        } else {
          this.size = this.originalSize;
        }
      }

      // Пульсация
      this.pulsePhase += 0.02;
      const pulse = Math.sin(this.pulsePhase) * 0.3 + 1;
      this.size = this.originalSize * pulse;

      // Жизненный цикл
      this.life -= this.decay;
      if (this.life <= 0) {
        this.reset();
        this.life = this.maxLife;
      }

      // Границы экрана
      if (this.x < 0 || this.x > this.canvas.width) this.vx *= -1;
      if (this.y < 0 || this.y > this.canvas.height) this.vy *= -1;
    }

    draw(ctx) {
      const alpha = this.life;
      
      if (currentTheme.glow) {
        // Эффект свечения
        ctx.shadowColor = this.color;
        ctx.shadowBlur = this.size * 2;
      }
      
      ctx.globalAlpha = alpha;
      ctx.fillStyle = this.color;
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
      ctx.fill();
      
      // Дополнительное внутреннее свечение
      if (currentTheme.glow) {
        ctx.globalAlpha = alpha * 0.5;
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size * 0.3, 0, Math.PI * 2);
        ctx.fill();
      }
      
      ctx.shadowBlur = 0;
      ctx.globalAlpha = 1;
    }
  }

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    
    const resizeCanvas = () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    };

    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // Инициализация частиц
    particlesRef.current = [];
    for (let i = 0; i < currentTheme.particleCount; i++) {
      particlesRef.current.push(new Particle(canvas));
    }

    // Обработка движения мыши
    const handleMouseMove = (e) => {
      mouseRef.current.x = e.clientX;
      mouseRef.current.y = e.clientY;
    };

    if (interactive) {
      window.addEventListener('mousemove', handleMouseMove);
    }

    // Анимационный цикл
    const animate = () => {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Градиентный фон
      const gradient = ctx.createRadialGradient(
        canvas.width / 2, canvas.height / 2, 0,
        canvas.width / 2, canvas.height / 2, Math.max(canvas.width, canvas.height)
      );
      gradient.addColorStop(0, 'rgba(0, 0, 0, 0.1)');
      gradient.addColorStop(1, 'rgba(0, 0, 0, 0.3)');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Обновление и отрисовка частиц
      particlesRef.current.forEach(particle => {
        particle.update(mouseRef.current.x, mouseRef.current.y);
        particle.draw(ctx);
      });

      // Соединительные линии между близкими частицами
      if (theme === 'cosmic') {
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
        ctx.lineWidth = 1;
        
        for (let i = 0; i < particlesRef.current.length; i++) {
          for (let j = i + 1; j < particlesRef.current.length; j++) {
            const p1 = particlesRef.current[i];
            const p2 = particlesRef.current[j];
            const dx = p1.x - p2.x;
            const dy = p1.y - p2.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < 100) {
              const alpha = (100 - distance) / 100 * 0.2;
              ctx.globalAlpha = alpha;
              ctx.beginPath();
              ctx.moveTo(p1.x, p1.y);
              ctx.lineTo(p2.x, p2.y);
              ctx.stroke();
            }
          }
        }
        ctx.globalAlpha = 1;
      }

      animationRef.current = requestAnimationFrame(animate);
    };

    animate();

    return () => {
      window.removeEventListener('resize', resizeCanvas);
      if (interactive) {
        window.removeEventListener('mousemove', handleMouseMove);
      }
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
      }
    };
  }, [theme, intensity, interactive]);

  // Эффекты взрыва для достижений
  const createExplosion = (x, y, color = '#00ff88') => {
    const explosionParticles = [];
    for (let i = 0; i < 20; i++) {
      const angle = (i / 20) * Math.PI * 2;
      const speed = 2 + Math.random() * 3;
      explosionParticles.push({
        x, y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        life: 1,
        color,
        size: 3 + Math.random() * 3
      });
    }
    
    // Добавляем взрывные частицы к основному массиву
    particlesRef.current.push(...explosionParticles.map(p => {
      const particle = new Particle(canvasRef.current);
      Object.assign(particle, p);
      return particle;
    }));
  };

  return (
    <>
      <canvas
        ref={canvasRef}
        className="particle-canvas"
        style={{
          position: 'fixed',
          top: 0,
          left: 0,
          width: '100%',
          height: '100%',
          pointerEvents: 'none',
          zIndex: -1
        }}
      />
      
      {/* Дополнительные CSS частицы для особых эффектов */}
      <div className="css-particles">
        {[...Array(10)].map((_, i) => (
          <motion.div
            key={i}
            className="floating-particle"
            animate={{
              y: [-20, -100],
              opacity: [0, 1, 0],
              scale: [0.5, 1, 0.5]
            }}
            transition={{
              duration: 3 + Math.random() * 2,
              repeat: Infinity,
              delay: i * 0.5
            }}
            style={{
              left: `${Math.random() * 100}%`,
              animationDelay: `${Math.random() * 3}s`
            }}
          >
            {['✨', '💫', '⭐', '🌟'][Math.floor(Math.random() * 4)]}
          </motion.div>
        ))}
      </div>
    </>
  );
};

export default ParticleSystem;
9. HolographicUI.jsx — голографический интерфейс
import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import './HolographicUI.css';

const HolographicUI = ({ children, variant = 'panel', glowColor = '#00ff88', ...props }) => {
  const [isHovered, setIsHovered] = useState(false);
  const [scanlinePosition, setScanlinePosition] = useState(0);

  useEffect(() => {
    const interval = setInterval(() => {
      setScanlinePosition(prev => (prev + 1) % 100);
    }, 50);
    
    return () => clearInterval(interval);
  }, []);

  const variants = {
    panel: {
      background: 'rgba(0, 255, 136, 0.05)',
      border: `1px solid ${glowColor}40`,
      backdropFilter: 'blur(10px)',
      boxShadow: `0 0 20px ${glowColor}20, inset 0 0 20px ${glowColor}10`
    },
    button: {
      background: `linear-gradient(45deg, ${glowColor}20, transparent)`,
      border: `1px solid ${glowColor}60`,
      backdropFilter: 'blur(5px)',
      boxShadow: `0 0 15px ${glowColor}30`
    },
    card: {
      background: 'rgba(0, 0, 0, 0.7)',
      border: `1px solid ${glowColor}50`,
      backdropFilter: 'blur(15px)',
      boxShadow: `0 0 30px ${glowColor}25, inset 0 0 30px ${glowColor}15`
    }
  };

  const HolographicButton = ({ children, onClick, disabled = false, ...buttonProps }) => (
    <motion.button
      className={`holographic-button ${disabled ? 'disabled' : ''}`}
      style={variants.button}
      onMouseEnter={() => setIsHovered(true)}
      onMouseLeave={() => setIsHovered(false)}
      onClick={onClick}
      whileHover={!disabled ? {
        scale: 1.05,
        boxShadow: `0 0 25px ${glowColor}50, inset 0 0 15px ${glowColor}20`,
        textShadow: `0 0 10px ${glowColor}`
      } : {}}
      whileTap={!disabled ? { scale: 0.95 } : {}}
      disabled={disabled}
      {...buttonProps}
    >
      <div className="button-content">
        {children}
      </div>
      <div 
        className="button-glow"
        style={{ backgroundColor: glowColor }}
      />
      <motion.div
        className="button-scanline"
        animate={{ x: isHovered ? '100%' : '-100%' }}
        transition={{ duration: 0.6, ease: "easeInOut" }}
        style={{ backgroundColor: glowColor }}
      />
      <div className="button-grid">
        {[...Array(20)].map((_, i) => (
          <div key={i} className="grid-dot" />
        ))}
      </div>
    </motion.button>
  );

  const HolographicPanel = ({ children, title, ...panelProps }) => (
    <motion.div
      className="holographic-panel"
      style={variants.panel}
      initial={{ opacity: 0, scale: 0.9 }}
      animate={{ opacity: 1, scale: 1 }}
      transition={{ duration: 0.5 }}
      {...panelProps}
    >
      {title && (
        <div className="panel-header">
          <h3 className="panel-title">{title}</h3>
          <div className="header-line" style={{ backgroundColor: glowColor }} />
        </div>
      )}
      
      <div className="panel-content">
        {children}
      </div>
      
      <motion.div
        className="panel-scanline"
        animate={{ y: `${scanlinePosition}%` }}
        style={{ backgroundColor: glowColor }}
      />
      
      <div className="panel-corners">
        <div className="corner corner-tl" style={{ borderColor: glowColor }} />
        <div className="corner corner-tr" style={{ borderColor: glowColor }} />
        <div className="corner corner-bl" style={{ borderColor: glowColor }} />
        <div className="corner corner-br" style={{ borderColor: glowColor }} />
      </div>
      
      <div className="panel-grid">
        {[...Array(100)].map((_, i) => (
          <motion.div
            key={i}
            className="grid-cell"
            animate={{
              opacity: [
            animate={{
              opacity: [0.1, 0.3, 0.1]
            }}
            transition={{
              duration: 2,
              repeat: Infinity,
              delay: i * 0.02
            }}
          />
        ))}
      </div>
    </motion.div>
  );

  const HolographicCard = ({ children, title, subtitle, icon, ...cardProps }) => (
    <motion.div
      className="holographic-card"
      style={variants.card}
      whileHover={{
        scale: 1.02,
        boxShadow: `0 0 40px ${glowColor}35, inset 0 0 40px ${glowColor}20`
      }}
      {...cardProps}
    >
      {(title || icon) && (
        <div className="card-header">
          {icon && (
            <motion.div
              className="card-icon"
              animate={{ rotate: 360 }}
              transition={{ duration: 10, repeat: Infinity, ease: "linear" }}
            >
              {icon}
            </motion.div>
          )}
          <div className="card-titles">
            {title && <h4 className="card-title">{title}</h4>}
            {subtitle && <p className="card-subtitle">{subtitle}</p>}
          </div>
        </div>
      )}
      
      <div className="card-content">
        {children}
      </div>
      
      <div className="card-hologram">
        <motion.div
          className="hologram-line"
          animate={{
            scaleX: [0, 1, 0],
            opacity: [0, 1, 0]
          }}
          transition={{
            duration: 3,
            repeat: Infinity,
            ease: "easeInOut"
          }}
          style={{ backgroundColor: glowColor }}
        />
      </div>
      
      <div className="card-data-stream">
        {[...Array(5)].map((_, i) => (
          <motion.div
            key={i}
            className="data-bit"
            animate={{
              x: [-20, 300],
              opacity: [0, 1, 0]
            }}
            transition={{
              duration: 2,
              repeat: Infinity,
              delay: i * 0.4
            }}
            style={{ backgroundColor: glowColor }}
          />
        ))}
      </div>
    </motion.div>
  );

  const HolographicInput = ({ placeholder, value, onChange, type = 'text', ...inputProps }) => (
    <div className="holographic-input-container">
      <motion.input
        className="holographic-input"
        type={type}
        placeholder={placeholder}
        value={value}
        onChange={onChange}
        style={{
          background: 'rgba(0, 0, 0, 0.5)',
          border: `1px solid ${glowColor}40`,
          color: glowColor,
          backdropFilter: 'blur(5px)'
        }}
        whileFocus={{
          borderColor: glowColor,
          boxShadow: `0 0 15px ${glowColor}50`,
          textShadow: `0 0 5px ${glowColor}`
        }}
        {...inputProps}
      />
      <motion.div
        className="input-glow"
        style={{ backgroundColor: glowColor }}
        animate={{
          opacity: [0.2, 0.5, 0.2]
        }}
        transition={{
          duration: 2,
          repeat: Infinity
        }}
      />
      <div className="input-grid">
        {[...Array(10)].map((_, i) => (
          <div key={i} className="input-dot" />
        ))}
      </div>
    </div>
  );

  const HolographicProgress = ({ value, max = 100, label, showValue = true }) => {
    const percentage = (value / max) * 100;
    
    return (
      <div className="holographic-progress">
        {label && <div className="progress-label">{label}</div>}
        <div className="progress-container">
          <div 
            className="progress-track"
            style={{ border: `1px solid ${glowColor}30` }}
          >
            <motion.div
              className="progress-fill"
              style={{ backgroundColor: glowColor }}
              initial={{ width: 0 }}
              animate={{ width: `${percentage}%` }}
              transition={{ duration: 1, ease: "easeOut" }}
            />
            <motion.div
              className="progress-glow"
              style={{ backgroundColor: glowColor }}
              animate={{
                opacity: [0.5, 1, 0.5],
                scaleY: [1, 1.2, 1]
              }}
              transition={{
                duration: 2,
                repeat: Infinity
              }}
            />
          </div>
          {showValue && (
            <div className="progress-value" style={{ color: glowColor }}>
              {Math.round(percentage)}%
            </div>
          )}
        </div>
        <div className="progress-particles">
          {[...Array(3)].map((_, i) => (
            <motion.div
              key={i}
              className="progress-particle"
              animate={{
                x: [0, percentage * 2],
                opacity: [0, 1, 0]
              }}
              transition={{
                duration: 2,
                repeat: Infinity,
                delay: i * 0.5
              }}
              style={{ backgroundColor: glowColor }}
            />
          ))}
        </div>
      </div>
    );
  };

  const HolographicBadge = ({ children, variant = 'default', pulse = false }) => {
    const badgeColors = {
      default: glowColor,
      success: '#00ff88',
      warning: '#ffd93d',
      error: '#ff6b6b',
      info: '#4ecdc4'
    };

    return (
      <motion.div
        className={`holographic-badge ${variant}`}
        style={{
          backgroundColor: `${badgeColors[variant]}20`,
          border: `1px solid ${badgeColors[variant]}60`,
          color: badgeColors[variant],
          boxShadow: `0 0 10px ${badgeColors[variant]}30`
        }}
        animate={pulse ? {
          scale: [1, 1.1, 1],
          opacity: [0.8, 1, 0.8]
        } : {}}
        transition={pulse ? {
          duration: 2,
          repeat: Infinity
        } : {}}
      >
        {children}
        <div 
          className="badge-glow"
          style={{ backgroundColor: badgeColors[variant] }}
        />
      </motion.div>
    );
  };

  const HolographicTooltip = ({ children, content, position = 'top' }) => {
    const [isVisible, setIsVisible] = useState(false);

    return (
      <div 
        className="holographic-tooltip-container"
        onMouseEnter={() => setIsVisible(true)}
        onMouseLeave={() => setIsVisible(false)}
      >
        {children}
        <AnimatePresence>
          {isVisible && (
            <motion.div
              className={`holographic-tooltip ${position}`}
              style={{
                background: 'rgba(0, 0, 0, 0.9)',
                border: `1px solid ${glowColor}60`,
                color: glowColor,
                boxShadow: `0 0 20px ${glowColor}40`
              }}
              initial={{ opacity: 0, scale: 0.8 }}
              animate={{ opacity: 1, scale: 1 }}
              exit={{ opacity: 0, scale: 0.8 }}
              transition={{ duration: 0.2 }}
            >
              {content}
              <div 
                className="tooltip-glow"
                style={{ backgroundColor: glowColor }}
              />
            </motion.div>
          )}
        </AnimatePresence>
      </div>
    );
  };

  // Экспорт компонентов для использования
  const components = {
    Button: HolographicButton,
    Panel: HolographicPanel,
    Card: HolographicCard,
    Input: HolographicInput,
    Progress: HolographicProgress,
    Badge: HolographicBadge,
    Tooltip: HolographicTooltip
  };

  // Если передан variant, возвращаем соответствующий компонент
  if (variant === 'button') return <HolographicButton {...props}>{children}</HolographicButton>;
  if (variant === 'panel') return <HolographicPanel {...props}>{children}</HolographicPanel>;
  if (variant === 'card') return <HolographicCard {...props}>{children}</HolographicCard>;

  // По умолчанию возвращаем объект с компонентами
  return components;
};

// Экспорт отдельных компонентов
export const HoloButton = (props) => <HolographicUI variant="button" {...props} />;
export const HoloPanel = (props) => <HolographicUI variant="panel" {...props} />;
export const HoloCard = (props) => <HolographicUI variant="card" {...props} />;

export default HolographicUI;
10. QuestSystem.jsx — система квестов
import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { HoloCard, HoloButton, HoloProgress } from './HolographicUI';
import './QuestSystem.css';

const QuestSystem = ({ userLevel, influencePoints, setInfluencePoints }) => {
  const [activeQuests, setActiveQuests] = useState([]);
  const [completedQuests, setCompletedQuests] = useState([]);
  const [availableQuests, setAvailableQuests] = useState([]);
  const [selectedQuest, setSelectedQuest] = useState(null);
  const [questChains, setQuestChains] = useState([]);

  const questTypes = {
    daily: { color: '#00ff88', icon: '📅', multiplier: 1 },
    weekly: { color: '#4ecdc4', icon: '🗓️', multiplier: 2 },
    epic: { color: '#ff6b6b', icon: '⚔️', multiplier: 5 },
    legendary: { color: '#ffd93d', icon: '👑', multiplier: 10 },
    chain: { color: '#9933ff', icon: '🔗', multiplier: 3 }
  };

  const questCategories = {
    exploration: { name: 'Исследование', icon: '🗺️', color: '#00ff88' },
    social: { name: 'Социальное', icon: '👥', color: '#4ecdc4' },
    content: { name: 'Контент', icon: '📝', color: '#ff6b6b' },
    mentoring: { name: 'Наставничество', icon: '🎓', color: '#ffd93d' },
    achievement: { name: 'Достижения', icon: '🏆', color: '#9933ff' }
  };

  const mockQuests = [
    {
      id: 'daily_explorer',
      title: 'Ежедневный Исследователь',
      description: 'Отметьтесь в 3 новых локациях сегодня',
      type: 'daily',
      category: 'exploration',
      difficulty: 'easy',
      progress: 1,
      target: 3,
      reward: { ip: 100, items: ['🗺️ Карта исследователя'] },
      timeLimit: '18:45:30',
      requirements: { level: 1 },
      status: 'active'
    },
    {
      id: 'social_butterfly',
      title: 'Социальная Бабочка',
      description: 'Заведите 5 новых друзей в сообществе',
      type: 'weekly',
      category: 'social',
      difficulty: 'medium',
      progress: 2,
      target: 5,
      reward: { ip: 300, items: ['👥 Значок коммуникатора'] },
      timeLimit: '3 дня',
      requirements: { level: 5 },
      status: 'active'
    },
    {
      id: 'content_creator',
      title: 'Создатель Контента',
      description: 'Опубликуйте 10 качественных постов о путешествиях',
      type: 'epic',
      category: 'content',
      difficulty: 'hard',
      progress: 7,
      target: 10,
      reward: { ip: 1000, items: ['✍️ Перо мастера', '📸 Профессиональная камера'] },
      timeLimit: '1 неделя',
      requirements: { level: 10, achievements: ['first_post'] },
      status: 'active'
    },
    {
      id: 'mentor_master',
      title: 'Мастер Наставник',
      description: 'Помогите 20 новичкам с планированием маршрутов',
      type: 'legendary',
      category: 'mentoring',
      difficulty: 'legendary',
      progress: 0,
      target: 20,
      reward: { ip: 2500, items: ['👑 Корона наставника', '🎓 Диплом мудреца'] },
      timeLimit: '1 месяц',
      requirements: { level: 20, completedQuests: 50 },
      status: 'available'
    }
  ];

  const questChainData = [
    {
      id: 'explorer_path',
      name: 'Путь Исследователя',
      description: 'Станьте легендарным исследователем',
      quests: [
        { id: 'first_journey', title: 'Первое Путешествие', completed: true },
        { id: 'country_collector', title: 'Коллекционер Стран', completed: true },
        { id: 'continent_master', title: 'Мастер Континентов', completed: false, current: true },
        { id: 'world_explorer', title: 'Исследователь Мира', completed: false },
        { id: 'legend_explorer', title: 'Легенда Исследований', completed: false }
      ],
      progress: 2,
      totalReward: { ip: 5000, title: 'Легендарный Исследователь' }
    }
  ];

  useEffect(() => {
    setActiveQuests(mockQuests.filter(q => q.status === 'active'));
    setAvailableQuests(mockQuests.filter(q => q.status === 'available'));
    setQuestChains(questChainData);
  }, []);

  const acceptQuest = (questId) => {
    const quest = availableQuests.find(q => q.id === questId);
    if (quest && userLevel >= quest.requirements.level) {
      quest.status = 'active';
      setActiveQuests(prev => [...prev, quest]);
      setAvailableQuests(prev => prev.filter(q => q.id !== questId));
    }
  };

  const completeQuest = (questId) => {
    const quest = activeQuests.find(q => q.id === questId);
    if (quest && quest.progress >= quest.target) {
      quest.status = 'completed';
      quest.completedAt = new Date();
      
      setInfluencePoints(prev => prev + quest.reward.ip);
      setActiveQuests(prev => prev.filter(q => q.id !== questId));
      setCompletedQuests(prev => [...prev, quest]);
      
      // Проверяем цепочки квестов
      updateQuestChains(questId);
    }
  };

  const updateQuestChains = (completedQuestId) => {
    setQuestChains(prev => prev.map(chain => {
      const questIndex = chain.quests.findIndex(q => q.id === completedQuestId);
      if (questIndex !== -1) {
        const updatedChain = { ...chain };
        updatedChain.quests[questIndex].completed = true;
        updatedChain.quests[questIndex].current = false;
        
        // Активируем следующий квест в цепочке
        if (questIndex + 1 < updatedChain.quests.length) {
          updatedChain.quests[questIndex + 1].current = true;
        }
        
        updatedChain.progress = updatedChain.quests.filter(q => q.completed).length;
        return updatedChain;
      }
      return chain;
    }));
  };

  const QuestCard = ({ quest, type = 'active' }) => {
    const questType = questTypes[quest.type];
    const category = questCategories[quest.category];
    const progressPercent = (quest.progress / quest.target) * 100;
    const canComplete = quest.progress >= quest.target;
    const canAccept = userLevel >= quest.requirements.level;

    const difficultyColors = {
      easy: '#00ff88',
      medium: '#ffd93d',
      hard: '#ff6b6b',
      legendary: '#9933ff'
    };

    return (
      <HoloCard
        title={quest.title}
        subtitle={category.name}
        icon={category.icon}
        glowColor={questType.color}
      >
        <div className="quest-content">
          <p className="quest-description">{quest.description}</p>
          
          <div className="quest-meta">
            <div className="quest-type">
              <span className="type-icon">{questType.icon}</span>
              <span className="type-name">{quest.type.toUpperCase()}</span>
            </div>
            <div 
              className={`quest-difficulty ${quest.difficulty}`}
              style={{ color: difficultyColors[quest.difficulty] }}
            >
              {quest.difficulty.toUpperCase()}
            </div>
          </div>

          {type === 'active' && (
            <div className="quest-progress-section">
              <HoloProgress
                value={quest.progress}
                max={quest.target}
                label="Прогресс"
                glowColor={questType.color}
              />
              <div className="progress-text">
                {quest.progress}/{quest.target}
              </div>
            </div>
          )}

          <div className="quest-rewards">
            <h4>Награды:</h4>
            <div className="reward-list">
              <div className="reward-item">
                <span className="reward-icon">💎</span>
                <span className="reward-value">+{quest.reward.ip} IP</span>
              </div>
              {quest.reward.items?.map((item, index) => (
                <div key={index} className="reward-item">
                  <span className="reward-text">{item}</span>
                </div>
              ))}
            </div>
          </div>

          {quest.timeLimit && (
            <div className="quest-timer">
              <span className="timer-icon">⏰</span>
              <span className="timer-text">Осталось: {quest.timeLimit}</span>
            </div>
          )}

          <div className="quest-requirements">
            <span className="req-label">Требования:</span>
            <span className="req-level">Уровень {quest.requirements.level}</span>
          </div>
        </div>

        <div className="quest-actions">
          {type === 'active' && (
            <HoloButton
              onClick={() => canComplete && completeQuest(quest.id)}
              disabled={!canComplete}
              glowColor={canComplete ? '#00ff88' : '#666666'}
            >
              {canComplete ? '✅ Завершить' : '⏳ В процессе'}
            </HoloButton>
          )}
          
          {type === 'available' && (
            <HoloButton
              onClick={() => canAccept && acceptQuest(quest.id)}
              disabled={!canAccept}
              glowColor={canAccept ? questType.color : '#666666'}
            >
              {canAccept ? '🚀 Принять' : '🔒 Недоступно'}
            </HoloButton>
          )}
          
          <HoloButton
            onClick={() => setSelectedQuest(quest)}
            glowColor="#4ecdc4"
          >
            📋 Детали
          </HoloButton>
        </div>
      </HoloCard>
    );
  };

  const QuestChain = ({ chain }) => (
    <div className="quest-chain">
      <div className="chain-header">
        <h3>{chain.name}</h3>
        <p>{chain.description}</p>
        <HoloProgress
          value={chain.progress}
          max={chain.quests.length}
          label={`Прогресс цепочки: ${chain.progress}/${chain.quests.length}`}
          glowColor="#9933ff"
        />
      </div>
      
      <div className="chain-quests">
        {chain.quests.map((quest, index) => (
          <motion.div
            key={quest.id}
            className={`chain-quest ${quest.completed ? 'completed' : ''} ${quest.current ? 'current' : ''}`}
            initial={{ opacity: 0, x: -20 }}
            animate={{ opacity: 1, x: 0 }}
            transition={{ delay: index * 0.1 }}
          >
            <div className="quest-node">
              <div className="node-icon">
                {quest.completed ? '✅' : quest.current ? '🎯' : '⭕'}
              </div>
              <div className="node-connector" />
            </div>
            <div className="quest-info">
              <h4>{quest.title}</h4>
              <div className="quest-status">
                {quest.completed ? 'Завершено' : quest.current ? 'Активно' : 'Заблокировано'}
              </div>
            </div>
          </motion.div>
        ))}
      </div>
      
      <div className="chain-reward">
        <h4>Финальная награда:</h4>
        <div className="final-reward">
          <span>💎 +{chain.totalReward.ip} IP</span>
          <span>🏆 {chain.totalReward.title}</span>
        </div>
      </div>
    </div>
  );

  const QuestGenerator = () => {
    const [generatedQuest, setGeneratedQuest] = useState(null);
    const [isGenerating, setIsGenerating] = useState(false);

    const generateRandomQuest = () => {
      setIsGenerating(true);
      
      setTimeout(() => {
        const categories = Object.keys(questCategories);
        const types = Object.keys(questTypes);
        const difficulties = ['easy', 'medium', 'hard'];
        
        const randomQuest = {
          id: `generated_${Date.now()}`,
          title: `Случайный Квест ${Math.floor(Math.random() * 1000)}`,
          description: 'Автоматически сгенерированное задание',
          type: types[Math.floor(Math.random() * types.length)],
          category: categories[Math.floor(Math.random() * categories.length)],
          difficulty: difficulties[Math.floor(Math.random() * difficulties.length)],
          progress: 0,
          target: Math.floor(Math.random() * 10) + 1,
          reward: { ip: Math.floor(Math.random() * 500) + 100 },
          timeLimit: '24 часа',
          requirements: { level: Math.floor(Math.random() * 10) + 1 },
          status: 'available'
        };
        
        setGeneratedQuest(randomQuest);
        setIsGenerating(false);
      }, 2000);
    };

    return (
      <div className="quest-generator">
        <h3>Генератор Квестов</h3>
        <p>Создайте персонализированный квест на основе вашей активности</p>
        
        <HoloButton
          onClick={generateRandomQuest}
          disabled={isGenerating}
          glowColor="#ffd93d"
        >
          {isGenerating ? '🔄 Генерация...' : '🎲 Сгенерировать квест'}
        </HoloButton>
        
        {generatedQuest && (
          <motion.div
            initial={{ opacity: 0, scale: 0.8 }}
            animate={{ opacity: 1, scale: 1 }}
            className="generated-quest"
          >
            <QuestCard quest={generatedQuest} type="available" />
          </motion.div>
        )}
      </div>
    );
  };

  return (
    <div className="quest-system">
      <motion.div 
        className="quest-header"
        initial={{ opacity: 0, y: -30 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.8 }}
      >
        <h2>Система Квестов</h2>
        <div className="quest-stats">
          <div className="stat-item">
            <span className="stat-value">{activeQuests.length}</span>
            <span className="stat-label">Активных</span>
          </div>
          <div className="stat-item">
            <span className="stat-value">{completedQuests.length}</span>
            <span className="stat-label">Завершено</span>
          </div>
          <div className="stat-item">
            <span className="stat-value">{availableQuests.length}</span>
            <span className="stat-label">Доступно</span>
          </div>
        </div>
      </motion.div>

      <div className="quest-tabs">
        <div className="tab-content">
          <div className="quest-section">
            <h3>Активные Квесты</h3>
            <div className="quest-grid">
              {activeQuests.map((quest, index) => (
                <motion.div
                  key={quest.id}
                  initial={{ opacity: 0, y: 20 }}
                  animate={{ opacity: 1, y: 0 }}
                  transition={{ delay: index * 0.1 }}
                >
                  <QuestCard quest={quest} type="active" />
                </motion.div>
              ))}
            </div>
          </div>

          <div className="quest-section">
            <h3>Доступные Квесты</h3>
            <div className="quest-grid">
              {availableQuests.map((quest, index) => (
                <motion.div
                  key={quest.id}
                  initial={{ opacity: 0, y: 20 }}
                  animate={{ opacity: 1, y: 0 }}
                  transition={{ delay: index * 0.1 }}
                >
                  <QuestCard quest={quest} type="available" />
                </motion.div>
              ))}
            </div>
          </div>

          <div className="quest-section">
            <h3>Цепочки Квестов</h3>
            {questChains.map((chain, index) => (
              <motion.div
                key={chain.id}
                initial={{ opacity: 0, x: -50 }}
                animate={{ opacity: 1, x: 0 }}
                transition={{ delay: index * 0.2 }}
              >
                <QuestChain chain={chain} />
              </motion.div>
            ))}
          </div>

          <QuestGenerator />
        </div>
      </div>

      {/* Детали квеста */}
      <AnimatePresence>
        {selectedQuest && (
          <motion.div
            className="quest-detail-overlay"
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            onClick={() => setSelectedQuest(null)}
          >
            <motion.div
              className="quest-detail-modal"
              initial={{ scale: 0.8, y: 50 }}
              animate={{ scale: 1, y: 0 }}
              exit={{ scale: 0.8, y: 50 }}
              onClick={(e) => e.stopPropagation()}
            >
              <div className="modal-header">
                <h3>{selectedQuest.title}</h3>
                <button 
                  className="close-btn"
                  onClick={() => setSelectedQuest(null)}
                >
                  ✕
                </button>
              </div>
              
              <div className="modal-content">
                <div className="quest-full-description">
                  <p>{selectedQuest.description}</p>
                </div>
                
                <div className="quest-detailed-info">
                  <div className="info-section">
                    <h4>Подробности</h4>
                    <ul>
                      <li>Тип: {selectedQuest.type}</li>
                      <li>Категория: {questCategories[selectedQuest.category].name}</li>
                      <li>Сложность: {selectedQuest.difficulty}</li>
                      <li>Прогресс: {selectedQuest.progress}/{selectedQuest.target}</li>
                    </ul>
                  </div>
                  
                  <div className="info-section">
                    <h4>Советы</h4>
                    <ul>
                      <li>Используйте карту для поиска новых локаций</li>
                      <li>Общайтесь с другими путешественниками</li>
                      <li>Делитесь своим опытом в блогах</li>
                    </ul>
                  </div>
                </div>
              </div>
            </motion.div>
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
};

export default QuestSystem;
11. PowerUpCenter.jsx — Центр усилений
import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { HoloCard, HoloButton, HoloProgress } from './HolographicUI';
import './PowerUpCenter.css';

const PowerUpCenter = ({ userLevel, influencePoints, setInfluencePoints }) => {
  const [activePowerUps, setActivePowerUps] = useState([]);
  const [availablePowerUps, setAvailablePowerUps] = useState([]);
  const [inventory, setInventory] = useState([]);
  const [selectedPowerUp, setSelectedPowerUp] = useState(null);
  const [craftingMode, setCraftingMode] = useState(false);

  const powerUpTypes = {
    boost: { name: 'Усиление', color: '#00ff88', icon: '⚡' },
    protection: { name: 'Защита', color: '#4ecdc4', icon: '🛡️' },
    enhancement: { name: 'Улучшение', color: '#ffd93d', icon: '✨' },
    special: { name: 'Особое', color: '#ff6b6b', icon: '🔮' },
    legendary: { name: 'Легендарное', color: '#9933ff', icon: '👑' }
  };

  const powerUpsData = [
    {
      id: 'influence_multiplier',
      name: 'Множитель Влияния',
      description: 'Удваивает получение очков влияния на 30 минут',
      type: 'boost',
      rarity: 'rare',
      duration: 1800, // 30 минут в секундах
      effect: { type: 'multiply_influence', value: 2 },
      cost: 500,
      cooldown: 3600, // 1 час
      requirements: { level: 5 },
      icon: '💎',
      particles: true
    },
    {
      id: 'experience_boost',
      name: 'Ускоритель Опыта',
      description: 'Увеличивает получение опыта на 50% на 1 час',
      type: 'boost',
      rarity: 'common',
      duration: 3600,
      effect: { type: 'multiply_exp', value: 1.5 },
      cost: 300,
      cooldown: 7200,
      requirements: { level: 3 },
      icon: '📈',
      particles: false
    },
    {
      id: 'social_magnetism',
      name: 'Социальный Магнетизм',
      description: 'Привлекает больше друзей и увеличивает популярность постов',
      type: 'enhancement',
      rarity: 'epic',
      duration: 2700, // 45 минут
      effect: { type: 'social_boost', value: 3 },
      cost: 800,
      cooldown: 5400,
      requirements: { level: 10 },
      icon: '🧲',
      particles: true
    },
    {
      id: 'creative_inspiration',
      name: 'Творческое Вдохновение',
      description: 'Улучшает качество создаваемого контента и увеличивает его влияние',
      type: 'enhancement',
      rarity: 'rare',
      duration: 5400, // 1.5 часа
      effect: { type: 'content_quality', value: 2.5 },
      cost: 600,
      cooldown: 10800,
      requirements: { level: 8 },
      icon: '🎨',
      particles: true
    },
    {
      id: 'travel_luck',
      name: 'Удача Путешественника',
      description: 'Увеличивает шанс найти редкие локации и события',
      type: 'special',
      rarity: 'epic',
      duration: 7200, // 2 часа
      effect: { type: 'luck_boost', value: 0.25 },
      cost: 1200,
      cooldown: 14400,
      requirements: { level: 15 },
      icon: '🍀',
      particles: true
    },
    {
      id: 'time_dilation',
      name: 'Замедление Времени',
      description: 'Замедляет истечение времени для всех активных эффектов',
      type: 'legendary',
      rarity: 'legendary',
      duration: 1800,
      effect: { type: 'time_slow', value: 0.5 },
      cost: 2000,
      cooldown: 21600, // 6 часов
      requirements: { level: 20 },
      icon: '⏰',
      particles: true
    }
  ];

  const craftingRecipes = [
    {
      id: 'super_boost',
      name: 'Супер Усиление',
      description: 'Комбинирует эффекты нескольких усилений',
      ingredients: ['influence_multiplier', 'experience_boost'],
      result: {
        name: 'Супер Усиление',
        duration: 2400,
        effect: { type: 'super_boost', value: 3 },
        icon: '🚀'
      },
      cost: 200
    }
  ];

  useEffect(() => {
    setAvailablePowerUps(powerUpsData.filter(p => userLevel >= p.requirements.level));
    
    // Симуляция активных усилений
    const mockActive = [
      {
        ...powerUpsData[0],
        activatedAt: Date.now() - 600000, // 10 минут назад
        remainingTime: 1200 // 20 минут осталось
      }
    ];
    setActivePowerUps(mockActive);

    // Обновление таймеров каждую секунду
    const timer = setInterval(() => {
      setActivePowerUps(prev => prev.map(powerUp => ({
        ...powerUp,
        remainingTime: Math.max(0, powerUp.remainingTime - 1)
      })).filter(powerUp => powerUp.remainingTime > 0));
    }, 1000);

    return () => clearInterval(timer);
  }, [userLevel]);

  const activatePowerUp = (powerUpId) => {
    const powerUp = availablePowerUps.find(p => p.id === powerUpId);
    if (powerUp && influencePoints >= powerUp.cost) {
      setInfluencePoints(prev => prev - powerUp.cost);
      
      const activatedPowerUp = {
        ...powerUp,
        activatedAt: Date.now(),
        remainingTime: powerUp.duration
      };
      
      setActivePowerUps(prev => [...prev, activatedPowerUp]);
    }
  };

  const formatTime = (seconds) => {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = seconds % 60;
    
    if (hours > 0) {
      return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }
    return `${minutes}:${secs.toString().padStart(2, '0')}`;
  };

  const getRarityColor = (rarity) => {
    const colors = {
      common: '#888888',
      rare: '#0099ff',
      epic: '#9933ff',
      legendary: '#ff6600'
    };
    return colors[rarity] || '#888888';
  };

  const PowerUpCard = ({ powerUp, isActive = false, canActivate = true }) => {
    const typeInfo = powerUpTypes[powerUp.type];
    const rarityColor = getRarityColor(powerUp.rarity);
    const canAfford = influencePoints >= powerUp.cost;
    const meetsRequirements = userLevel >= powerUp.requirements.level;

    return (
      <HoloCard
        title={powerUp.name}
        subtitle={typeInfo.name}
        icon={powerUp.icon}
        glowColor={typeInfo.color}
      >
        <div className="powerup-content">
          <p className="powerup-description">{powerUp.description}</p>
          
          <div className="powerup-stats">
            <div className="stat-row">
              <span className="stat-label">Редкость:</span>
              <span 
                className="stat-value rarity"
                style={{ color: rarityColor }}
              >
                {powerUp.rarity.toUpperCase()}
              </span>
            </div>
            
            <div className="stat-row">
              <span className="stat-label">Длительность:</span>
              <span className="stat-value">{formatTime(powerUp.duration)}</span>
            </div>
            
            <div className="stat-row">
              <span className="stat-label">Перезарядка:</span>
              <span className="stat-value">{formatTime(powerUp.cooldown)}</span>
            </div>
            
            <div className="stat-row">
              <span className="stat-label">Стоимость:</span>
              <span className={`stat-value cost ${canAfford ? 'affordable' : 'expensive'}`}>
                {powerUp.cost} IP
              </span>
            </div>
          </div>

          {isActive && (
            <div className="active-timer">
              <HoloProgress
                value={powerUp.remainingTime}
                max={powerUp.duration}
                label="Осталось времени"
                glowColor={typeInfo.color}
              />
              <div className="timer-display">
                {formatTime(powerUp.remainingTime)}
              </div>
            </div>
          )}

          <div className="powerup-requirements">
            <span className="req-label">Требования:</span>
            <span className={`req-level ${meetsRequirements ? 'met' : 'not-met'}`}>
              Уровень {powerUp.requirements.level}
            </span>
          </div>
        </div>

        {!isActive && (
          <div className="powerup-actions">
            <HoloButton
              onClick={() => canActivate && canAfford && meetsRequirements && activatePowerUp(powerUp.id)}
              disabled={!canActivate || !canAfford || !meetsRequirements}
              glowColor={canActivate && canAfford && meetsRequirements ? typeInfo.color : '#666666'}
            >
              {!meetsRequirements ? '🔒 Заблокировано' :
               !canAfford ? '💰 Недостаточно IP' :
               '⚡ Активировать'}
            </HoloButton>
            
            <HoloButton
              onClick={() => setSelectedPowerUp(powerUp)}
              glowColor="#4ecdc4"
            >
              📋 Подробнее
            </HoloButton>
          </div>
        )}

        {powerUp.particles && (
          <div className="powerup-particles">
            {[...Array(8)].map((_, i) => (
              <motion.div
                key={i}
                className="particle"
                animate={{
                  scale: [0, 1, 0],
                  opacity: [0, 1, 0],
                  x: Math.cos(i * 45 * Math.PI / 180) * 20,
                  y: Math.sin(i * 45 * Math.PI / 180) * 20
                }}
                transition={{
                  duration: 2,
                  repeat: Infinity,
                  delay: i * 0.2
                }}
                style={{ backgroundColor: typeInfo.color }}
              />
            ))}
          </div>
        )}
      </HoloCard>
    );
  };

  const CraftingStation = () => (
    <div className="crafting-station">
      <h3>Станция Крафта</h3>
      <p>Комбинируйте усиления для создания более мощных эффектов</p>
      
      {craftingRecipes.map(recipe => (
        <div key={recipe.id} className="crafting-recipe">
          <div className="recipe-header">
            <h4>{recipe.name}</h4>
            <p>{recipe.description}</p>
          </div>
          
          <div className="recipe-ingredients">
            <span>Ингредиенты:</span>
            {recipe.ingredients.map(ingredientId => {
              const ingredient = powerUpsData.find(p => p.id === ingredientId);
              return (
                <div key={ingredientId} className="ingredient">
                  <span className="ingredient-icon">{ingredient?.icon}</span>
                  <span className="ingredient-name">{ingredient?.name}</span>
                </div>
              );
            })}
          </div>
          
          <div className="recipe-result">
            <span>Результат:</span>
            <div className="result-item">
              <span className="result-icon">{recipe.result.icon}</span>
              <span className="result-name">{recipe.result.name}</span>
            </div>
          </div>
          
          <HoloButton
            onClick={() => {/* Логика крафта */}}
            glowColor="#ffd93d"
          >
            🔨 Создать
          </HoloButton>
        </div>
      ))}
    </div>
  );

  const PowerUpEffects = () => (
    <div className="powerup-effects">
      <h3>Активные Эффекты</h3>
      {activePowerUps.length === 0 ? (
        <p className="no-effects">Нет активных усилений</p>
      ) : (
        <div className="effects-list">
          {activePowerUps.map(powerUp => (
            <motion.div
              key={powerUp.id}
              className="effect-item"
              animate={{
                boxShadow: [
                  `0 0 10px ${powerUpTypes[powerUp.type].color}40`,
                  `0 0 20px ${powerUpTypes[powerUp.type].color}60`,
                  `0 0 10px ${powerUpTypes[powerUp.type].color}40`
                ]
              }}
              transition={{ duration: 2, repeat: Infinity }}
            >
              <div className="effect-icon">{powerUp.icon}</div>
              <div className="effect-info">
                <h4>{powerUp.name}</h4>
                <div className="effect-timer">
                  Осталось: {formatTime(powerUp.remainingTime)}
                </div>
              </div>
              <div className="effect-visual">
                <motion.div
                  className="effect-pulse"
                  animate={{
                    scale: [1, 1.2, 1],
                    opacity: [0.5, 1, 0.5]
                  }}
                  transition={{ duration: 1, repeat: Infinity }}
                  style={{ backgroundColor: powerUpTypes[powerUp.type].color }}
                />
              </div>
            </motion.div>
          ))}
        </div>
      )}
    </div>
  );

  return (
    <div className="powerup-center">
      <motion.div 
        className="powerup-header"
        initial={{ opacity: 0, y: -30 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.8 }}
      >
        <h2>Центр Усилений</h2>
        <div className="powerup-stats">
          <div className="stat-item">
            <span className="stat-value">{activePowerUps.length}</span>
            <span className="stat-label">Активных</span>
          </div>
          <div className="stat-item">
            <span className="stat-value">{availablePowerUps.length}</span>
            <span className="stat-label">Доступно</span>
          </div>
          <div className="stat-item">
            <span className="stat-value">{influencePoints}</span>
            <span className="stat-label">IP</span>
          </div>
        </div>
      </motion.div>

      <div className="powerup-controls">
        <HoloButton
          onClick={() => setCraftingMode(!craftingMode)}

          glowColor={craftingMode ? '#ff6b6b' : '#ffd93d'}
        >
          {craftingMode ? '🔙 Назад к усилениям' : '🔨 Станция крафта'}
        </HoloButton>
      </div>

      <AnimatePresence mode="wait">
        {!craftingMode ? (
          <motion.div
            key="powerups"
            initial={{ opacity: 0, x: -50 }}
            animate={{ opacity: 1, x: 0 }}
            exit={{ opacity: 0, x: 50 }}
            className="powerup-main"
          >
            <PowerUpEffects />
            
            <div className="powerup-section">
              <h3>Доступные Усиления</h3>
              <div className="powerup-grid">
                {availablePowerUps.map((powerUp, index) => (
                  <motion.div
                    key={powerUp.id}
                    initial={{ opacity: 0, y: 20 }}
                    animate={{ opacity: 1, y: 0 }}
                    transition={{ delay: index * 0.1 }}
                  >
                    <PowerUpCard powerUp={powerUp} />
                  </motion.div>
                ))}
              </div>
            </div>
          </motion.div>
        ) : (
          <motion.div
            key="crafting"
            initial={{ opacity: 0, x: 50 }}
            animate={{ opacity: 1, x: 0 }}
            exit={{ opacity: 0, x: -50 }}
          >
            <CraftingStation />
          </motion.div>
        )}
      </AnimatePresence>

      {/* Детали усиления */}
      <AnimatePresence>
        {selectedPowerUp && (
          <motion.div
            className="powerup-detail-overlay"
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            onClick={() => setSelectedPowerUp(null)}
          >
            <motion.div
              className="powerup-detail-modal"
              initial={{ scale: 0.8, y: 50 }}
              animate={{ scale: 1, y: 0 }}
              exit={{ scale: 0.8, y: 50 }}
              onClick={(e) => e.stopPropagation()}
            >
              <div className="modal-header">
                <div className="header-icon">{selectedPowerUp.icon}</div>
                <div className="header-info">
                  <h3>{selectedPowerUp.name}</h3>
                  <p className="header-type">{powerUpTypes[selectedPowerUp.type].name}</p>
                </div>
                <button 
                  className="close-btn"
                  onClick={() => setSelectedPowerUp(null)}
                >
                  ✕
                </button>
              </div>
              
              <div className="modal-content">
                <div className="detailed-description">
                  <h4>Описание</h4>
                  <p>{selectedPowerUp.description}</p>
                </div>
                
                <div className="effect-details">
                  <h4>Эффект</h4>
                  <div className="effect-breakdown">
                    <div className="effect-type">
                      Тип: {selectedPowerUp.effect.type}
                    </div>
                    <div className="effect-value">
                      Значение: {selectedPowerUp.effect.value}
                    </div>
                  </div>
                </div>
                
                <div className="usage-tips">
                  <h4>Советы по использованию</h4>
                  <ul>
                    <li>Используйте перед важными активностями</li>
                    <li>Комбинируйте с другими усилениями для максимального эффекта</li>
                    <li>Следите за временем действия</li>
                  </ul>
                </div>
                
                <div className="synergy-info">
                  <h4>Синергия</h4>
                  <p>Хорошо сочетается с усилениями типа "{powerUpTypes[selectedPowerUp.type].name}"</p>
                </div>
              </div>
            </motion.div>
          </motion.div>
        )}
      </AnimatePresence>

      {/* Глобальные эффекты */}
      <div className="global-effects">
        {activePowerUps.map(powerUp => (
          <motion.div
            key={`effect-${powerUp.id}`}
            className="global-effect-particle"
            animate={{
              y: [-20, -100],
              opacity: [0, 1, 0],
              scale: [0.5, 1, 0.5]
            }}
            transition={{
              duration: 2,
              repeat: Infinity,
              delay: Math.random() * 2
            }}
            style={{
              left: `${Math.random() * 100}%`,
              color: powerUpTypes[powerUp.type].color
            }}
          >
            {powerUp.icon}
          </motion.div>
        ))}
      </div>
    </div>
  );
};

export default PowerUpCenter;
12. InsightCrystal.jsx — Кристалл инсайтов
import React, { useState, useEffect, useRef } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import * as THREE from 'three';
import { HoloCard, HoloButton } from './HolographicUI';
import './InsightCrystal.css';

const InsightCrystal = ({ userLevel, influencePoints }) => {
  const mountRef = useRef(null);
  const crystalRef = useRef(null);
  const [selectedFacet, setSelectedFacet] = useState(null);
  const [insights, setInsights] = useState([]);
  const [crystalRotation, setCrystalRotation] = useState({ x: 0, y: 0 });
  const [isAnalyzing, setIsAnalyzing] = useState(false);

  const facetData = [
    {
      id: 'travel_patterns',
      name: 'Паттерны Путешествий',
      color: '#00ff88',
      position: { x: 0, y: 1, z: 0 },
      insights: [
        'Вы предпочитаете горные регионы на 65%',
        'Средняя продолжительность поездки: 8.5 дней',
        'Пик активности: выходные дни',
        'Любимый сезон для путешествий: лето'
      ],
      metrics: {
        countries: 12,
        cities: 47,
        totalDistance: 25847,
        favoriteRegion: 'Европа'
      }
    },
    {
      id: 'social_network',
      name: 'Социальная Сеть',
      color: '#4ecdc4',
      position: { x: 0.866, y: 0.5, z: 0 },
      insights: [
        'Ваша сеть выросла на 340% за год',
        'Самые активные связи: фотографы',
        'Влияние в сообществе: высокое',
        'Средний отклик на посты: 89%'
      ],
      metrics: {
        connections: 234,
        mutualFriends: 67,
        networkReach: 15600,
        engagementRate: 0.89
      }
    },
    {
      id: 'content_analysis',
      name: 'Анализ Контента',
      color: '#ff6b6b',
      position: { x: 0.866, y: -0.5, z: 0 },
      insights: [
        'Самые популярные теги: #природа #приключения',
        'Лучшее время для постов: 19:00-21:00',
        'Средняя длина поста: 280 символов',
        'Рост качества контента: +45%'
      ],
      metrics: {
        totalPosts: 156,
        avgLikes: 47,
        topHashtag: '#природа',
        contentScore: 8.7
      }
    },
    {
      id: 'influence_growth',
      name: 'Рост Влияния',
      color: '#ffd93d',
      position: { x: 0, y: -1, z: 0 },
      insights: [
        'Влияние растет на 12% в месяц',
        'Пиковый рост: после публикации гидов',
        'Основной источник влияния: экспертность',
        'Прогноз на следующий месяц: +15%'
      ],
      metrics: {
        currentInfluence: influencePoints,
        monthlyGrowth: 0.12,
        peakDay: 'Воскресенье',
        projectedGrowth: 0.15
      }
    },
    {
      id: 'learning_path',
      name: 'Путь Обучения',
      color: '#9933ff',
      position: { x: -0.866, y: -0.5, z: 0 },
      insights: [
        'Освоено навыков: 23 из 50',
        'Любимая область: фотография',
        'Скорость обучения: выше среднего',
        'Рекомендуемый навык: видеомонтаж'
      ],
      metrics: {
        skillsLearned: 23,
        totalSkills: 50,
        learningSpeed: 1.3,
        nextSkill: 'Видеомонтаж'
      }
    },
    {
      id: 'future_predictions',
      name: 'Предсказания',
      color: '#ff9500',
      position: { x: -0.866, y: 0.5, z: 0 },
      insights: [
        'Вероятность достижения 20 уровня: 85%',
        'Рекомендуемое направление: наставничество',
        'Потенциальные партнеры: 12 пользователей',
        'Оптимальная стратегия: фокус на качестве'
      ],
      metrics: {
        levelProbability: 0.85,
        recommendedPath: 'Наставничество',
        potentialPartners: 12,
        successRate: 0.78
      }
    }
  ];

  useEffect(() => {
    if (!mountRef.current) return;

    // Инициализация Three.js сцены
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, 400 / 400, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
    
    renderer.setSize(400, 400);
    renderer.setClearColor(0x000000, 0);
    mountRef.current.appendChild(renderer.domElement);

    // Создание кристалла
    const crystalGeometry = new THREE.OctahedronGeometry(2, 2);
    const crystalMaterial = new THREE.MeshPhongMaterial({
      color: 0x00ff88,
      transparent: true,
      opacity: 0.7,
      shininess: 100
    });
    
    const crystal = new THREE.Mesh(crystalGeometry, crystalMaterial);
    scene.add(crystal);
    crystalRef.current = crystal;

    // Создание граней кристалла
    facetData.forEach((facet, index) => {
      const facetGeometry = new THREE.PlaneGeometry(0.5, 0.5);
      const facetMaterial = new THREE.MeshBasicMaterial({
        color: facet.color,
        transparent: true,
        opacity: 0.8
      });
      
      const facetMesh = new THREE.Mesh(facetGeometry, facetMaterial);
      facetMesh.position.set(
        facet.position.x * 2.5,
        facet.position.y * 2.5,
        facet.position.z * 2.5
      );
      facetMesh.lookAt(0, 0, 0);
      facetMesh.userData = { facetId: facet.id };
      
      scene.add(facetMesh);
    });

    // Освещение
    const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
    scene.add(ambientLight);
    
    const pointLight = new THREE.PointLight(0x00ff88, 1, 100);
    pointLight.position.set(10, 10, 10);
    scene.add(pointLight);

    camera.position.z = 8;

    // Обработка кликов
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    const handleClick = (event) => {
      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(scene.children);

      if (intersects.length > 0) {
        const clickedObject = intersects[0].object;
        if (clickedObject.userData.facetId) {
          const facet = facetData.find(f => f.id === clickedObject.userData.facetId);
          setSelectedFacet(facet);
        }
      }
    };

    renderer.domElement.addEventListener('click', handleClick);

    // Анимационный цикл
    const animate = () => {
      requestAnimationFrame(animate);
      
      if (crystalRef.current) {
        crystalRef.current.rotation.x += 0.005;
        crystalRef.current.rotation.y += 0.01;
        
        setCrystalRotation({
          x: crystalRef.current.rotation.x,
          y: crystalRef.current.rotation.y
        });
      }
      
      renderer.render(scene, camera);
    };
    animate();

    return () => {
      if (mountRef.current && renderer.domElement) {
        mountRef.current.removeChild(renderer.domElement);
      }
      renderer.domElement.removeEventListener('click', handleClick);
      renderer.dispose();
    };
  }, []);

  const generateInsights = () => {
    setIsAnalyzing(true);
    
    setTimeout(() => {
      const newInsights = [
        {
          id: Date.now(),
          type: 'trend',
          title: 'Новый тренд обнаружен',
          description: 'Ваш интерес к эко-туризму вырос на 45% за последний месяц',
          confidence: 0.87,
          actionable: true,
          recommendation: 'Рассмотрите создание контента об экологичных путешествиях'
        },
        {
          id: Date.now() + 1,
          type: 'opportunity',
          title: 'Возможность роста',
          description: 'Оптимальное время для запуска блога о горных походах',

          confidence: 0.92,
          actionable: true,
          recommendation: 'Начните серию постов о горных маршрутах в ближайшие 2 недели'
        },
        {
          id: Date.now() + 2,
          type: 'warning',
          title: 'Снижение активности',
          description: 'Активность в чатах снизилась на 23% за неделю',
          confidence: 0.78,
          actionable: true,
          recommendation: 'Увеличьте участие в обсуждениях или создайте новую тему'
        }
      ];
      
      setInsights(newInsights);
      setIsAnalyzing(false);
    }, 3000);
  };

  const DataVisualization = ({ facet }) => {
    const chartData = Object.entries(facet.metrics).map(([key, value]) => ({
      name: key,
      value: typeof value === 'number' ? value : 0
    }));

    return (
      <div className="data-visualization">
        <h4>Метрики</h4>
        <div className="metrics-grid">
          {Object.entries(facet.metrics).map(([key, value]) => (
            <motion.div
              key={key}
              className="metric-item"
              initial={{ opacity: 0, scale: 0.8 }}
              animate={{ opacity: 1, scale: 1 }}
              transition={{ duration: 0.5 }}
            >
              <div className="metric-label">{key}</div>
              <div className="metric-value" style={{ color: facet.color }}>
                {typeof value === 'number' ? value.toLocaleString() : value}
              </div>
            </motion.div>
          ))}
        </div>
        
        <div className="data-patterns">
          <h5>Паттерны данных</h5>
          <div className="pattern-visualization">
            {[...Array(20)].map((_, i) => (
              <motion.div
                key={i}
                className="data-point"
                animate={{
                  scale: [0.5, 1, 0.5],
                  opacity: [0.3, 1, 0.3]
                }}
                transition={{
                  duration: 2,
                  repeat: Infinity,
                  delay: i * 0.1
                }}
                style={{
                  backgroundColor: facet.color,
                  left: `${(i * 5) % 100}%`,
                  top: `${Math.sin(i * 0.5) * 20 + 50}%`
                }}
              />
            ))}
          </div>
        </div>
      </div>
    );
  };

  const InsightCard = ({ insight }) => {
    const typeColors = {
      trend: '#00ff88',
      opportunity: '#ffd93d',
      warning: '#ff6b6b',
      prediction: '#4ecdc4'
    };

    const typeIcons = {
      trend: '📈',
      opportunity: '💡',
      warning: '⚠️',
      prediction: '🔮'
    };

    return (
      <motion.div
        className={`insight-card ${insight.type}`}
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        whileHover={{ scale: 1.02 }}
        style={{ borderColor: typeColors[insight.type] }}
      >
        <div className="insight-header">
          <span className="insight-icon">{typeIcons[insight.type]}</span>
          <h4>{insight.title}</h4>
          <div 
            className="confidence-badge"
            style={{ backgroundColor: typeColors[insight.type] }}
          >
            {Math.round(insight.confidence * 100)}%
          </div>
        </div>
        
        <p className="insight-description">{insight.description}</p>
        
        {insight.actionable && (
          <div className="insight-recommendation">
            <strong>Рекомендация:</strong>
            <p>{insight.recommendation}</p>
          </div>
        )}
        
        <div className="insight-actions">
          <HoloButton
            onClick={() => {/* Применить рекомендацию */}}
            glowColor={typeColors[insight.type]}
          >
            ✅ Применить
          </HoloButton>
          <HoloButton
            onClick={() => {/* Отклонить */}}
            glowColor="#666666"
          >
            ❌ Отклонить
          </HoloButton>
        </div>
      </motion.div>
    );
  };

  const PredictiveAnalytics = () => {
    const predictions = [
      {
        metric: 'Уровень влияния',
        current: influencePoints,
        predicted: influencePoints * 1.15,
        timeframe: '1 месяц',
        confidence: 0.85
      },
      {
        metric: 'Количество подписчиков',
        current: 234,
        predicted: 312,
        timeframe: '2 недели',
        confidence: 0.78
      },
      {
        metric: 'Качество контента',
        current: 8.7,
        predicted: 9.2,
        timeframe: '3 недели',
        confidence: 0.92
      }
    ];

    return (
      <div className="predictive-analytics">
        <h3>Предиктивная Аналитика</h3>
        {predictions.map((prediction, index) => (
          <motion.div
            key={prediction.metric}
            className="prediction-item"
            initial={{ opacity: 0, x: -20 }}
            animate={{ opacity: 1, x: 0 }}
            transition={{ delay: index * 0.2 }}
          >
            <div className="prediction-header">
              <h4>{prediction.metric}</h4>
              <span className="timeframe">{prediction.timeframe}</span>
            </div>
            
            <div className="prediction-values">
              <div className="current-value">
                <span className="label">Текущее:</span>
                <span className="value">{prediction.current.toLocaleString()}</span>
              </div>
              <div className="arrow">→</div>
              <div className="predicted-value">
                <span className="label">Прогноз:</span>
                <span className="value" style={{ color: '#00ff88' }}>
                  {prediction.predicted.toLocaleString()}
                </span>
              </div>
            </div>
            
            <div className="confidence-bar">
              <div className="confidence-label">
                Уверенность: {Math.round(prediction.confidence * 100)}%
              </div>
              <div className="confidence-track">
                <motion.div
                  className="confidence-fill"
                  initial={{ width: 0 }}
                  animate={{ width: `${prediction.confidence * 100}%` }}
                  transition={{ duration: 1, delay: index * 0.3 }}
                  style={{ backgroundColor: '#00ff88' }}
                />
              </div>
            </div>
          </motion.div>
        ))}
      </div>
    );
  };

  return (
    <div className="insight-crystal">
      <motion.div 
        className="crystal-header"
        initial={{ opacity: 0, y: -30 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.8 }}
      >
        <h2>Кристалл Инсайтов</h2>
        <p>Интерактивная аналитика вашей активности</p>
      </motion.div>

      <div className="crystal-container">
        <div className="crystal-viewer">
          <div className="three-canvas" ref={mountRef}></div>
          
          <div className="crystal-controls">
            <HoloButton
              onClick={generateInsights}
              disabled={isAnalyzing}
              glowColor="#00ff88"
            >
              {isAnalyzing ? '🔄 Анализ...' : '🔍 Генерировать инсайты'}
            </HoloButton>
          </div>
          
          <div className="facet-legend">
            <h4>Грани кристалла:</h4>
            {facetData.map(facet => (
              <motion.div
                key={facet.id}
                className={`legend-item ${selectedFacet?.id === facet.id ? 'active' : ''}`}
                onClick={() => setSelectedFacet(facet)}
                whileHover={{ scale: 1.05 }}
                style={{ borderColor: facet.color }}
              >
                <div 
                  className="legend-color"
                  style={{ backgroundColor: facet.color }}
                />
                <span>{facet.name}</span>
              </motion.div>
            ))}
          </div>
        </div>

        <div className="crystal-analysis">
          <AnimatePresence mode="wait">
            {selectedFacet ? (
              <motion.div
                key={selectedFacet.id}
                initial={{ opacity: 0, x: 50 }}
                animate={{ opacity: 1, x: 0 }}
                exit={{ opacity: 0, x: -50 }}
                className="facet-details"
              >
                <div className="facet-header">
                  <h3 style={{ color: selectedFacet.color }}>
                    {selectedFacet.name}
                  </h3>
                  <button 
                    className="close-facet"
                    onClick={() => setSelectedFacet(null)}
                  >
                    ✕
                  </button>
                </div>
                
                <div className="facet-insights">
                  <h4>Ключевые инсайты:</h4>
                  {selectedFacet.insights.map((insight, index) => (
                    <motion.div
                      key={index}
                      className="insight-item"
                      initial={{ opacity: 0, y: 10 }}
                      animate={{ opacity: 1, y: 0 }}
                      transition={{ delay: index * 0.1 }}
                    >
                      <span className="insight-bullet" style={{ color: selectedFacet.color }}>
                        •
                      </span>
                      <span>{insight}</span>
                    </motion.div>
                  ))}
                </div>
                
                <DataVisualization facet={selectedFacet} />
              </motion.div>
            ) : (
              <motion.div
                key="default"
                initial={{ opacity: 0 }}
                animate={{ opacity: 1 }}
                className="crystal-info"
              >
                <h3>Выберите грань кристалла</h3>
                <p>Кликните на цветную область кристалла или выберите из легенды для получения детальной аналитики</p>
                
                <div className="crystal-stats">
                  <div className="stat-item">
                    <span className="stat-value">{facetData.length}</span>
                    <span className="stat-label">Граней анализа</span>
                  </div>
                  <div className="stat-item">
                    <span className="stat-value">{insights.length}</span>
                    <span className="stat-label">Активных инсайтов</span>
                  </div>
                </div>
              </motion.div>
            )}
          </AnimatePresence>
        </div>
      </div>

      {insights.length > 0 && (
        <motion.div
          className="insights-section"
          initial={{ opacity: 0, y: 50 }}
          animate={{ opacity: 1, y: 0 }}
        >
          <h3>Сгенерированные Инсайты</h3>
          <div className="insights-grid">
            {insights.map(insight => (
              <InsightCard key={insight.id} insight={insight} />
            ))}
          </div>
        </motion.div>
      )}

      <PredictiveAnalytics />

      {/* Анимация анализа */}
      <AnimatePresence>
        {isAnalyzing && (
          <motion.div
            className="analyzing-overlay"
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
          >
            <div className="analyzing-content">
              <motion.div
                className="analyzing-crystal"
                animate={{ rotate: 360 }}
                transition={{ duration: 2, repeat: Infinity, ease: "linear" }}
              >
                💎
              </motion.div>
              <h3>Анализ данных...</h3>
              <p>Кристалл обрабатывает ваши паттерны активности</p>
              
              <div className="analyzing-progress">
                {['Сбор данных', 'Анализ паттернов', 'Генерация инсайтов'].map((step, index) => (
                  <motion.div
                    key={step}
                    className="progress-step"
                    animate={{
                      opacity: [0.3, 1, 0.3]
                    }}
                    transition={{
                      duration: 1,
                      repeat: Infinity,
                      delay: index * 0.5
                    }}
                  >
                    {step}
                  </motion.div>
                ))}
              </div>
            </div>
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
};

export default InsightCrystal;
Продолжить работу с остальными компонентами? У нас осталось:

TravelDNA.jsx
Сеть влияния.jsx
Портал наставников.jsx
Доска мечты.jsx
LegacyBuilder.jsx
Сезонные события.jsx
Персональный музей.jsx
А затем CSS-файлы для всех компонентов.


13. TravelDNA.jsx — ДНК путешественника
import React, { useState, useEffect, useRef } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import * as THREE from 'three';
import { HoloCard, HoloButton, HoloProgress } from './HolographicUI';
import './TravelDNA.css';

const TravelDNA = ({ userLevel, influencePoints }) => {
  const mountRef = useRef(null);
  const [dnaData, setDnaData] = useState({});
  const [selectedTrait, setSelectedTrait] = useState(null);
  const [evolutionStage, setEvolutionStage] = useState(1);
  const [compatibilityMode, setCompatibilityMode] = useState(false);
  const [isSequencing, setIsSequencing] = useState(false);

  const traitCategories = {
    explorer: {
      name: 'Исследователь',
      color: '#00ff88',
      icon: '🗺️',
      description: 'Стремление к открытию новых мест'
    },
    social: {
      name: 'Социальный',
      color: '#4ecdc4',
      icon: '👥',
      description: 'Способность к общению и нетворкингу'
    },
    adventurer: {
      name: 'Авантюрист',
      color: '#ff6b6b',
      icon: '⛰️',
      description: 'Тяга к экстремальным приключениям'
    },
    cultural: {
      name: 'Культурный',
      color: '#ffd93d',
      icon: '🎭',
      description: 'Интерес к культуре и традициям'
    },
    photographer: {
      name: 'Фотограф',
      color: '#9933ff',
      icon: '📸',
      description: 'Художественное видение и документирование'
    },
    planner: {
      name: 'Планировщик',
      color: '#ff9500',
      icon: '📋',
      description: 'Организационные способности'
    }
  };

  const dnaSequence = [
    { trait: 'explorer', strength: 85, dominant: true },
    { trait: 'social', strength: 72, dominant: false },
    { trait: 'adventurer', strength: 91, dominant: true },
    { trait: 'cultural', strength: 68, dominant: false },
    { trait: 'photographer', strength: 79, dominant: true },
    { trait: 'planner', strength: 56, dominant: false }
  ];

  const evolutionStages = [
    {
      stage: 1,
      name: 'Новичок',
      description: 'Первые шаги в мире путешествий',
      requirements: { level: 1, trips: 0 },
      unlocked: true
    },
    {
      stage: 2,
      name: 'Путешественник',
      description: 'Опытный исследователь',
      requirements: { level: 5, trips: 10 },
      unlocked: userLevel >= 5
    },
    {
      stage: 3,
      name: 'Авантюрист',
      description: 'Мастер приключений',
      requirements: { level: 10, trips: 25 },
      unlocked: userLevel >= 10
    },
    {
      stage: 4,
      name: 'Эксперт',
      description: 'Признанный специалист',
      requirements: { level: 15, trips: 50 },
      unlocked: userLevel >= 15
    },
    {
      stage: 5,
      name: 'Легенда',
      description: 'Легендарный путешественник',
      requirements: { level: 20, trips: 100 },
      unlocked: userLevel >= 20
    }
  ];

  useEffect(() => {
    setDnaData({
      sequence: dnaSequence,
      dominantTraits: dnaSequence.filter(t => t.dominant),
      uniqueness: 0.847,
      compatibility: 0.73,
      evolution: evolutionStages.find(s => s.unlocked && s.stage <= userLevel) || evolutionStages[0]
    });

    // Определяем текущую стадию эволюции
    const currentStage = evolutionStages.reverse().find(stage => stage.unlocked)?.stage || 1;
    setEvolutionStage(currentStage);
  }, [userLevel]);

  useEffect(() => {
    if (!mountRef.current) return;

    // Создание 3D спирали ДНК
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, 400 / 600, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
    
    renderer.setSize(400, 600);
    renderer.setClearColor(0x000000, 0);
    mountRef.current.appendChild(renderer.domElement);

    // Создание спирали ДНК
    const helixGroup = new THREE.Group();
    
    const helixHeight = 10;
    const helixRadius = 2;
    const segments = 100;
    
    for (let i = 0; i < segments; i++) {
      const y = (i / segments) * helixHeight - helixHeight / 2;
      const angle1 = (i / segments) * Math.PI * 8;
      const angle2 = angle1 + Math.PI;
      
      // Первая нить
      const x1 = Math.cos(angle1) * helixRadius;
      const z1 = Math.sin(angle1) * helixRadius;
      
      // Вторая нить
      const x2 = Math.cos(angle2) * helixRadius;
      const z2 = Math.sin(angle2) * helixRadius;
      
      // Определяем цвет на основе черт характера
      const traitIndex = Math.floor((i / segments) * dnaSequence.length);
      const trait = dnaSequence[traitIndex];
      const traitColor = traitCategories[trait.trait].color;
      
      // Создание сфер для нуклеотидов
      const sphereGeometry = new THREE.SphereGeometry(0.1, 8, 8);
      const sphereMaterial1 = new THREE.MeshPhongMaterial({ 
        color: traitColor,
        transparent: true,
        opacity: 0.8
      });
      const sphereMaterial2 = new THREE.MeshPhongMaterial({ 
        color: traitColor,
        transparent: true,
        opacity: 0.6
      });
      
      const sphere1 = new THREE.Mesh(sphereGeometry, sphereMaterial1);
      const sphere2 = new THREE.Mesh(sphereGeometry, sphereMaterial2);
      
      sphere1.position.set(x1, y, z1);
      sphere2.position.set(x2, y, z2);
      
      helixGroup.add(sphere1, sphere2);
      
      // Соединительные линии каждые 10 сегментов
      if (i % 10 === 0) {
        const lineGeometry = new THREE.BufferGeometry().setFromPoints([
          new THREE.Vector3(x1, y, z1),
          new THREE.Vector3(x2, y, z2)
        ]);
        const lineMaterial = new THREE.LineBasicMaterial({ 
          color: traitColor,
          transparent: true,
          opacity: 0.4
        });
        const line = new THREE.Line(lineGeometry, lineMaterial);
        helixGroup.add(line);
      }
    }
    
    scene.add(helixGroup);

    // Освещение
    const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
    scene.add(ambientLight);
    
    const pointLight = new THREE.PointLight(0x00ff88, 1, 100);
    pointLight.position.set(10, 10, 10);
    scene.add(pointLight);

    camera.position.set(0, 0, 8);

    // Анимация
    const animate = () => {
      requestAnimationFrame(animate);
      
      helixGroup.rotation.y += 0.01;
      
      renderer.render(scene, camera);
    };
    animate();

    return () => {
      if (mountRef.current && renderer.domElement) {
        mountRef.current.removeChild(renderer.domElement);
      }
      renderer.dispose();
    };
  }, [dnaData]);

  const sequenceDNA = () => {
    setIsSequencing(true);
    
    setTimeout(() => {
      // Симуляция нового анализа ДНК
      const newSequence = dnaSequence.map(trait => ({
        ...trait,
        strength: Math.max(20, Math.min(100, trait.strength + (Math.random() - 0.5) * 10))
      }));
      
      setDnaData(prev => ({
        ...prev,
        sequence: newSequence,
        uniqueness: Math.random() * 0.3 + 0.7,
        lastSequenced: new Date()
      }));
      
      setIsSequencing(false);
    }, 3000);
  };

  const TraitCard = ({ trait, strength, dominant }) => {
    const category = traitCategories[trait];
    
    return (
      <motion.div
        className={`trait-card ${dominant ? 'dominant' : 'recessive'}`}
        onClick={() => setSelectedTrait({ trait, strength, dominant, category })}
        whileHover={{ scale: 1.05, boxShadow: `0 10px 30px ${category.color}40` }}
        style={{ borderColor: category.color }}
      >
        <div className="trait-header">
          <span className="trait-icon">{category.icon}</span>
          <h4 style={{ color: category.color }}>{category.name}</h4>
          {dominant && <span className="dominant-badge">Доминантная</span>}
        </div>
        
        <div className="trait-strength">
          <HoloProgress
            value={strength}
            max={100}
            label="Сила черты"
            glowColor={category.color}
          />
          <span className="strength-value">{strength}%</span>
        </div>
        
        <p className="trait-description">{category.description}</p>
        
        <div className="trait-effects">
          <div className="effect-item">
            <span className="effect-label">Влияние на стиль:</span>
            <span className="effect-value">
              {strength > 80 ? 'Очень высокое' : 
               strength > 60 ? 'Высокое' : 
               strength > 40 ? 'Среднее' : 'Низкое'}
            </span>
          </div>
        </div>
      </motion.div>
    );
  };

  const EvolutionTimeline = () => (
    <div className="evolution-timeline">
      <h3>Эволюция Путешественника</h3>
      <div className="timeline-container">
        {evolutionStages.map((stage, index) => (
          <motion.div
            key={stage.stage}
            className={`timeline-stage ${stage.unlocked ? 'unlocked' : 'locked'} ${evolutionStage === stage.stage ? 'current' : ''}`}
            initial={{ opacity: 0, x: -20 }}
            animate={{ opacity: 1, x: 0 }}
            transition={{ delay: index * 0.1 }}
          >
            <div className="stage-connector" />
            <div className="stage-node">
              <span className="stage-number">{stage.stage}</span>
              {evolutionStage === stage.stage && (
                <motion.div
                  className="current-indicator"
                  animate={{
                    scale: [1, 1.2, 1],
                    opacity: [0.5, 1, 0.5]
                  }}
                  transition={{ duration: 2, repeat: Infinity }}
                />
              )}
            </div>
            <div className="stage-info">
              <h4>{stage.name}</h4>
              <p>{stage.description}</p>
              <div className="stage-requirements">
                Требования: Уровень {stage.requirements.level}, {stage.requirements.trips} поездок
              </div>
            </div>
          </motion.div>
        ))}
      </div>
    </div>
  );

  const CompatibilityAnalyzer = () => {
    const [compatibilityResults, setCompatibilityResults] = useState([]);
    
    const analyzeCompatibility = () => {
      const mockResults = [
        {
          user: 'Анна Исследователь',
          avatar: '👩‍🦰',
          compatibility: 0.89,
          sharedTraits: ['explorer', 'photographer'],
          complementaryTraits: ['social', 'planner']
        },
        {
          user: 'Максим Авантюрист',
          avatar: '👨‍🦱',
          compatibility: 0.76,
          sharedTraits: ['adventurer', 'explorer'],
          complementaryTraits: ['cultural']
        },
        {
          user: 'Елена Культуролог',
          avatar: '👩‍🦳',
          compatibility: 0.82,
          sharedTraits: ['cultural', 'social'],
          complementaryTraits: ['adventurer', 'photographer']
        }
      ];
      
      setCompatibilityResults(mockResults);
    };

    return (
      <div className="compatibility-analyzer">
        <div className="analyzer-header">
          <h3>Анализ Совместимости</h3>
          <HoloButton
            onClick={analyzeCompatibility}
            glowColor="#4ecdc4"
          >
            🧬 Найти совместимых путешественников
          </HoloButton>
        </div>
        
        {compatibilityResults.length > 0 && (
          <div className="compatibility-results">
            {compatibilityResults.map((result, index) => (
              <motion.div
                key={result.user}
                className="compatibility-card"
                initial={{ opacity: 0, y: 20 }}
                animate={{ opacity: 1, y: 0 }}
                transition={{ delay: index * 0.2 }}
              >
                <div className="result-header">
                  <span className="user-avatar">{result.avatar}</span>
                  <div className="user-info">
                    <h4>{result.user}</h4>
                    <div className="compatibility-score">
                      Совместимость: {Math.round(result.compatibility * 100)}%
                    </div>
                  </div>
                </div>
                
                <div className="trait-analysis">
                  <div className="shared-traits">
                    <h5>Общие черты:</h5>
                    <div className="trait-list">
                      {result.sharedTraits.map(trait => (
                        <span 
                          key={trait}
                          className="trait-tag shared"
                          style={{ backgroundColor: `${traitCategories[trait].color}40` }}
                        >
                          {traitCategories[trait].icon} {traitCategories[trait].name}
                        </span>
                      ))}
                    </div>
                  </div>
                  
                  <div className="complementary-traits">
                    <h5>Дополняющие черты:</h5>
                    <div className="trait-list">
                      {result.complementaryTraits.map(trait => (
                        <span 
                          key={trait}
                          className="trait-tag complementary"
                          style={{ borderColor: traitCategories[trait].color }}
                        >
                          {traitCategories[trait].icon} {traitCategories[trait].name}
                        </span>
                      ))}
                    </div>
                  </div>
                </div>
                
                <div className="compatibility-actions">
                  <HoloButton
                    onClick={() => {/* Отправить приглашение */}}
                    glowColor="#00ff88"
                  >
                    📨 Пригласить в поездку
                  </HoloButton>
                  <HoloButton
                    onClick={() => {/* Добавить в друзья */}}
                    glowColor="#4ecdc4"
                  >
                    👥 Добавить в друзья
                  </HoloButton>
                </div>
              </motion.div>
            ))}
          </div>
        )}
      </div>
    );
  };

  const DNAStatistics = () => (
    <div className="dna-statistics">
      <h3>Статистика ДНК</h3>
      <div className="stats-grid">
        <div className="stat-card">
          <div className="stat-icon">🧬</div>
          <div className="stat-info">
            <h4>Уникальность</h4>
            <div className="stat-value">{Math.round(dnaData.uniqueness * 100)}%</div>
            <p>Ваш профиль уникален среди путешественников</p>
          </div>
        </div>
        
        <div className="stat-card">
          <div className="stat-icon">🎯</div>
          <div className="stat-info">
            <h4>Доминантные черты</h4>
            <div className="stat-value">{dnaData.dominantTraits?.length || 0}</div>
            <p>Ярко выраженные характеристики</p>
          </div>
        </div>
        
        <div className="stat-card">
          <div className="stat-icon">🔄</div>
          <div className="stat-info">
            <h4>Стадия эволюции</h4>
            <div className="stat-value">{evolutionStage}/5</div>
            <p>Текущий уровень развития</p>
          </div>
        </div>
        
        <div className="stat-card">
          <div className="stat-icon">💫</div>
          <div className="stat-info">
            <h4>Потенциал роста</h4>
            <div className="stat-value">
              {Math.round((5 - evolutionStage) / 5 * 100)}%
            </div>
            <p>Возможности для развития</p>
          </div>
        </div>
      </div>
    </div>
  );

  const TraitEvolution = () => {
    const [selectedEvolution, setSelectedEvolution] = useState(null);
    
    const evolutionPaths = {
      explorer: [
        { stage: 1, name: 'Турист', description: 'Посещение популярных мест' },
        { stage: 2, name: 'Путешественник', description: 'Самостоятельные поездки' },
        { stage: 3, name: 'Исследователь', description: 'Поиск скрытых жемчужин' },
        { stage: 4, name: 'Первопроходец', description: 'Открытие новых маршрутов' },
        { stage: 5, name: 'Легенда', description: 'Вдохновение для других' }
      ],
      social: [
        { stage: 1, name: 'Одиночка', description: 'Путешествия в одиночку' },
        { stage: 2, name: 'Компаньон', description: 'Поездки с друзьями' },
        { stage: 3, name: 'Организатор', description: 'Создание групп' },
        { stage: 4, name: 'Лидер', description: 'Ведение сообществ' },
        { stage: 5, name: 'Амбассадор', description: 'Представитель культуры путешествий' }
      ]
    };

    return (
      <div className="trait-evolution">
        <h3>Эволюция Черт</h3>
        <div className="evolution-selector">
          {Object.keys(evolutionPaths).map(trait => (
            <HoloButton
              key={trait}
              onClick={() => setSelectedEvolution(trait)}
              glowColor={traitCategories[trait].color}
            >
              {traitCategories[trait].icon} {traitCategories[trait].name}
            </HoloButton>
          ))}
        </div>
        
        {selectedEvolution && (
          <motion.div
            className="evolution-path"
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
          >
            <h4>Путь развития: {traitCategories[selectedEvolution].name}</h4>
            <div className="evolution-stages">
              {evolutionPaths[selectedEvolution].map((stage, index) => {
                const currentTraitStrength = dnaData.sequence?.find(s => s.trait === selectedEvolution)?.strength || 0;
                const isUnlocked = currentTraitStrength >= (stage.stage * 20);
                
                return (
                  <motion.div
                    key={stage.stage}
                    className={`evolution-stage ${isUnlocked ? 'unlocked' : 'locked'}`}
                    initial={{ opacity: 0, x: -20 }}
                    animate={{ opacity: 1, x: 0 }}
                    transition={{ delay: index * 0.1 }}
                  >
                    <div className="stage-indicator">
                      <span className="stage-number">{stage.stage}</span>
                      {isUnlocked && <div className="unlock-glow" />}
                    </div>
                    <div className="stage-content">
                      <h5>{stage.name}</h5>
                      <p>{stage.description}</p>
                      <div className="stage-requirement">
                        Требуется: {stage.stage * 20}% силы черты
                      </div>
                    </div>
                  </motion.div>
                );
              })}
            </div>
          </motion.div>
        )}
      </div>
    );
  };

  return (
    <div className="travel-dna">
      <motion.div 
        className="dna-header"
        initial={{ opacity: 0, y: -30 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.8 }}
      >
        <h2>ДНК Путешественника</h2>
        <p>Уникальный профиль ваших путешественнических черт</p>
        
        <div className="dna-controls">
          <HoloButton
            onClick={sequenceDNA}
            disabled={isSequencing}
            glowColor="#00ff88"
          >
            {isSequencing ? '🧬 Секвенирование...' : '🔬 Пересеквенировать ДНК'}
          </HoloButton>
          
          <HoloButton
            onClick={() => setCompatibilityMode(!compatibilityMode)}
            glowColor={compatibilityMode ? '#ff6b6b' : '#4ecdc4'}
          >
            {compatibilityMode ? '🧬 К ДНК' : '💕 Совместимость'}
          </HoloButton>
        </div>
      </motion.div>

      <div className="dna-container">
        <div className="dna-visualization">
          <div className="helix-container" ref={mountRef}></div>
          
          <div className="sequence-info">
            <h3>Последовательность ДНК</h3>
            <div className="sequence-display">
              {dnaData.sequence?.map((trait, index) => (
                <motion.div
                  key={trait.trait}
                  className={`sequence-segment ${trait.dominant ? 'dominant' : 'recessive'}`}
                  style={{ backgroundColor: `${traitCategories[trait.trait].color}40` }}
                  animate={{
                    scale: [1, 1.05, 1],
                    opacity: [0.7, 1, 0.7]
                  }}
                  transition={{
                    duration: 2,
                    repeat: Infinity,
                    delay: index * 0.2
                  }}
                >
                  <span className="segment-icon">{traitCategories[trait.trait].icon}</span>
                  <span className="segment-strength">{trait.strength}%</span>
                </motion.div>
              ))}
            </div>
          </div>
        </div>

        <AnimatePresence mode="wait">
          {!compatibilityMode ? (
            <motion.div
              key="dna-analysis"
              initial={{ opacity: 0, x: 50 }}
              animate={{ opacity: 1, x: 0 }}
              exit={{ opacity: 0, x: -50 }}
              className="dna-analysis"
            >
              <DNAStatistics />
              
              <div className="traits-section">
                <h3>Анализ Черт</h3>
                <div className="traits-grid">
                  {dnaData.sequence?.map((trait, index) => (
                    <motion.div
                      key={trait.trait}
                      initial={{ opacity: 0, y: 20 }}
                      animate={{ opacity: 1, y: 0 }}
                      transition={{ delay: index * 0.1 }}
                    >
                      <TraitCard {...trait} />
                    </motion.div>
                  ))}
                </div>
              </div>
              
              <EvolutionTimeline />
              <TraitEvolution />
            </motion.div>
          ) : (
            <motion.div
              key="compatibility"
              initial={{ opacity: 0, x: -50 }}
              animate={{ opacity: 1, x: 0 }}
              exit={{ opacity: 0, x: 50 }}
            >
              <CompatibilityAnalyzer />
            </motion.div>
          )}
        </AnimatePresence>
      </div>

      {/* Детали выбранной черты */}
      <AnimatePresence>
        {selectedTrait && (
          <motion.div
            className="trait-detail-overlay"
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            onClick={() => setSelectedTrait(null)}
          >
            <motion.div
              className="trait-detail-modal"
              initial={{ scale: 0.8, y: 50 }}
              animate={{ scale: 1, y: 0 }}
              exit={{ scale: 0.8, y: 50 }}
              onClick={(e) => e.stopPropagation()}
            >
              <div className="modal-header">
                <div className="header-icon" style={{ color: selectedTrait.category.color }}>
                  {selectedTrait.category.icon}
                </div>
                <div className="header-info">
                  <h3>{selectedTrait.category.name}</h3>
                  <p>{selectedTrait.category.description}</p>
                </div>
                <button 
                  className="close-btn"
                  onClick={() => setSelectedTrait(null)}
                >
                  ✕
                </button>
              </div>
              
              <div className="modal-content">
                <div className="trait-strength-detail">
                  <h4>Сила черты: {selectedTrait.strength}%</h4>
                  <HoloProgress
                    value={selectedTrait.strength}
                    max={100}
                    glowColor={selectedTrait.category.color}
                  />
                </div>
                
                <div className="trait-impact">
                  <h4>Влияние на путешествия</h4>
                  <ul>
                    <li>Выбор направлений: {selectedTrait.strength > 70 ? 'Сильное' : 'Умеренное'}</li>
                    <li>Стиль путешествий: {selectedTrait.dominant ? 'Определяющий' : 'Дополняющий'}</li>
                    <li>Социальные взаимодействия: {selectedTrait.strength > 60 ? 'Активные' : 'Избирательные'}</li>
                  </ul>
                </div>
                
                <div className="development-tips">
                  <h4>Советы по развитию</h4>
                  <ul>
                    <li>Участвуйте в активностях, связанных с этой чертой</li>
                    <li>Общайтесь с людьми, имеющими схожие интересы</li>
                    <li>Документируйте свой прогресс в блогах</li>
                  </ul>
                </div>
              </div>
            </motion.div>
          </motion.div>
        )}
      </AnimatePresence>

      {/* Анимация секвенирования */}
      <AnimatePresence>
        {isSequencing && (
          <motion.div
            className="sequencing-overlay"
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
          >
            <div className="sequencing-content">
              <motion.div
                className="dna-spinner"
                animate={{ rotate: 360 }}
                transition={{ duration: 2, repeat: Infinity, ease: "linear" }}
              >
                🧬
              </motion.div>
              <h3>Анализ ДНК путешественника...</h3>
              <div className="sequencing-steps">
                {['Сбор данных', 'Анализ паттернов', 'Определение черт', 'Построение профиля'].map((step, index) => (
                  <motion.div
                    key={step}
                    className="sequencing-step"
                    animate={{
                      opacity: [0.3, 1, 0.3]
                    }}
                    transition={{
                      duration: 1,
                      repeat: Infinity,
                      delay: index * 0.3
                    }}
                  >
                    {step}
                  </motion.div>
                ))}
              </div>
            </div>
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
};

export default TravelDNA;
14. InfluenceNetwork.jsx — Сеть влияния
import React, { useState, useEffect, useRef } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import * as d3 from 'd3';
import { HoloCard, HoloButton } from './HolographicUI';

import React, { useState, useEffect, useRef } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import * as d3 from 'd3';
import { HoloCard, HoloButton } from './HolographicUI';
import './InfluenceNetwork.css';

const InfluenceNetwork = ({ userLevel, influencePoints }) => {
  const svgRef = useRef(null);
  const [networkData, setNetworkData] = useState({ nodes: [], links: [] });
  const [selectedNode, setSelectedNode] = useState(null);
  const [networkStats, setNetworkStats] = useState({});
  const [viewMode, setViewMode] = useState('influence'); // influence, connections, activity
  const [isAnalyzing, setIsAnalyzing] = useState(false);

  const influenceCategories = {
    high: { color: '#ff6b6b', size: 20, threshold: 2000 },
    medium: { color: '#ffd93d', size: 15, threshold: 1000 },
    low: { color: '#4ecdc4', size: 10, threshold: 500 },
    minimal: { color: '#888888', size: 8, threshold: 0 }
  };

  const connectionTypes = {
    mentor: { color: '#9933ff', strength: 3, label: 'Наставник' },
    friend: { color: '#00ff88', strength: 2, label: 'Друг' },
    follower: { color: '#4ecdc4', strength: 1, label: 'Подписчик' },
    collaboration: { color: '#ff9500', strength: 4, label: 'Коллаборация' }
  };

  const mockNetworkData = {
    nodes: [
      {
        id: 'user',
        name: 'Вы',
        influence: influencePoints,
        level: userLevel,
        type: 'self',
        avatar: '👤',
        x: 400,
        y: 300,
        fixed: true
      },
      {
        id: 'anna',
        name: 'Анна Путешественница',
        influence: 2500,
        level: 18,
        type: 'influencer',
        avatar: '👩‍🦰',
        specialization: 'Фотография'
      },
      {
        id: 'maxim',
        name: 'Максим Исследователь',
        influence: 1800,
        level: 15,
        type: 'explorer',
        avatar: '👨‍🦱',
        specialization: 'Экстрим'
      },
      {
        id: 'elena',
        name: 'Елена Гид',
        influence: 3200,
        level: 22,
        type: 'mentor',
        avatar: '👩‍🦳',
        specialization: 'Культурный туризм'
      },
      {
        id: 'dmitry',
        name: 'Дмитрий Блогер',
        influence: 1200,
        level: 12,
        type: 'content_creator',
        avatar: '👨‍🦲',
        specialization: 'Видеоблоги'
      },
      {
        id: 'sofia',
        name: 'София Организатор',
        influence: 2100,
        level: 16,
        type: 'organizer',
        avatar: '👩‍🦱',
        specialization: 'Групповые туры'
      }
    ],
    links: [
      { source: 'user', target: 'anna', type: 'friend', strength: 0.8, duration: 6 },
      { source: 'user', target: 'maxim', type: 'collaboration', strength: 0.9, duration: 3 },
      { source: 'user', target: 'elena', type: 'mentor', strength: 0.7, duration: 12 },
      { source: 'user', target: 'dmitry', type: 'follower', strength: 0.6, duration: 2 },
      { source: 'anna', target: 'sofia', type: 'friend', strength: 0.8, duration: 8 },
      { source: 'maxim', target: 'elena', type: 'mentor', strength: 0.7, duration: 15 },
      { source: 'elena', target: 'sofia', type: 'collaboration', strength: 0.9, duration: 4 }
    ]
  };

  useEffect(() => {
    setNetworkData(mockNetworkData);
    
    // Вычисляем статистики сети
    const stats = {
      totalConnections: mockNetworkData.links.filter(l => l.source === 'user' || l.target === 'user').length,
      networkReach: mockNetworkData.nodes.reduce((sum, node) => sum + (node.influence || 0), 0),
      averageInfluence: mockNetworkData.nodes.reduce((sum, node) => sum + (node.influence || 0), 0) / mockNetworkData.nodes.length,
      strongConnections: mockNetworkData.links.filter(l => l.strength > 0.7).length
    };
    
    setNetworkStats(stats);
  }, [influencePoints, userLevel]);

  useEffect(() => {
    if (!svgRef.current || !networkData.nodes.length) return;

    const svg = d3.select(svgRef.current);
    svg.selectAll("*").remove();

    const width = 800;
    const height = 600;

    // Настройка симуляции
    const simulation = d3.forceSimulation(networkData.nodes)
      .force("link", d3.forceLink(networkData.links).id(d => d.id).distance(100))
      .force("charge", d3.forceManyBody().strength(-300))
      .force("center", d3.forceCenter(width / 2, height / 2))
      .force("collision", d3.forceCollide().radius(30));

    // Создание градиентов для связей
    const defs = svg.append("defs");
    Object.entries(connectionTypes).forEach(([type, config]) => {
      const gradient = defs.append("linearGradient")
        .attr("id", `gradient-${type}`)
        .attr("gradientUnits", "userSpaceOnUse");
      
      gradient.append("stop")
        .attr("offset", "0%")
        .attr("stop-color", config.color)
        .attr("stop-opacity", 0.8);
      
      gradient.append("stop")
        .attr("offset", "100%")
        .attr("stop-color", config.color)
        .attr("stop-opacity", 0.3);
    });

    // Создание связей
    const links = svg.selectAll(".link")
      .data(networkData.links)
      .enter().append("line")
      .attr("class", "link")
      .attr("stroke", d => `url(#gradient-${d.type})`)
      .attr("stroke-width", d => connectionTypes[d.type].strength * 2)
      .attr("opacity", d => d.strength);

    // Создание узлов
    const nodes = svg.selectAll(".node")
      .data(networkData.nodes)
      .enter().append("g")
      .attr("class", "node")
      .call(d3.drag()
        .on("start", dragstarted)
        .on("drag", dragged)
        .on("end", dragended));

    // Круги узлов
    nodes.append("circle")
      .attr("r", d => {
        if (d.type === 'self') return 25;
        const category = Object.values(influenceCategories)
          .find(cat => d.influence >= cat.threshold) || influenceCategories.minimal;
        return category.size;
      })
      .attr("fill", d => {
        if (d.type === 'self') return '#00ff88';
        const category = Object.values(influenceCategories)
          .find(cat => d.influence >= cat.threshold) || influenceCategories.minimal;
        return category.color;
      })
      .attr("stroke", "#fff")
      .attr("stroke-width", 2);

    // Аватары
    nodes.append("text")
      .attr("text-anchor", "middle")
      .attr("dy", "0.35em")
      .attr("font-size", d => d.type === 'self' ? "20px" : "16px")
      .text(d => d.avatar);

    // Подписи
    nodes.append("text")
      .attr("text-anchor", "middle")
      .attr("dy", d => d.type === 'self' ? "40px" : "30px")
      .attr("font-size", "12px")
      .attr("fill", "#fff")
      .text(d => d.name);

    // Индикаторы влияния
    nodes.append("text")
      .attr("text-anchor", "middle")
      .attr("dy", d => d.type === 'self' ? "55px" : "45px")
      .attr("font-size", "10px")
      .attr("fill", "#888")
      .text(d => `${d.influence} IP`);

    // Обработка кликов
    nodes.on("click", (event, d) => {
      setSelectedNode(d);
    });

    // Анимация пульса для активных связей
    const pulseAnimation = () => {
      links
        .transition()
        .duration(2000)
        .attr("opacity", d => d.strength * 0.5)
        .transition()
        .duration(2000)
        .attr("opacity", d => d.strength)
        .on("end", pulseAnimation);
    };
    pulseAnimation();

    // Обновление позиций
    simulation.on("tick", () => {
      links
        .attr("x1", d => d.source.x)
        .attr("y1", d => d.source.y)
        .attr("x2", d => d.target.x)
        .attr("y2", d => d.target.y);

      nodes.attr("transform", d => `translate(${d.x},${d.y})`);
    });

    function dragstarted(event, d) {
      if (!event.active) simulation.alphaTarget(0.3).restart();
      d.fx = d.x;
      d.fy = d.y;
    }

    function dragged(event, d) {
      d.fx = event.x;
      d.fy = event.y;
    }

    function dragended(event, d) {
      if (!event.active) simulation.alphaTarget(0);
      if (!d.fixed) {
        d.fx = null;
        d.fy = null;
      }
    }

  }, [networkData, viewMode]);

  const analyzeNetwork = () => {
    setIsAnalyzing(true);
    
    setTimeout(() => {
      // Симуляция анализа сети
      const analysis = {
        centralityScore: 0.78,
        clusteringCoefficient: 0.65,
        networkDensity: 0.42,
        influenceFlow: 'Высокий',
        recommendations: [
          'Укрепите связь с Еленой для повышения экспертности',
          'Расширьте сеть через коллаборации с Максимом',
          'Создайте контент совместно с Анной'
        ]
      };
      
      setNetworkStats(prev => ({ ...prev, ...analysis }));
      setIsAnalyzing(false);
    }, 3000);
  };

  const NetworkStats = () => (
    <div className="network-stats">
      <h3>Статистика Сети</h3>
      <div className="stats-grid">
        <div className="stat-item">
          <div className="stat-icon">🔗</div>
          <div className="stat-value">{networkStats.totalConnections}</div>
          <div className="stat-label">Прямых связей</div>
        </div>
        
        <div className="stat-item">
          <div className="stat-icon">🌐</div>
          <div className="stat-value">{networkStats.networkReach?.toLocaleString()}</div>
          <div className="stat-label">Охват сети</div>
        </div>
        
        <div className="stat-item">
          <div className="stat-icon">📊</div>
          <div className="stat-value">{Math.round(networkStats.averageInfluence)}</div>
          <div className="stat-label">Средн. влияние</div>
        </div>
        
        <div className="stat-item">
          <div className="stat-icon">💪</div>
          <div className="stat-value">{networkStats.strongConnections}</div>
          <div className="stat-label">Сильных связей</div>
        </div>
      </div>
      
      {networkStats.centralityScore && (
        <div className="advanced-stats">
          <div className="advanced-stat">
            <span className="stat-name">Центральность:</span>
            <span className="stat-value">{Math.round(networkStats.centralityScore * 100)}%</span>
          </div>
          <div className="advanced-stat">
            <span className="stat-name">Кластеризация:</span>
            <span className="stat-value">{Math.round(networkStats.clusteringCoefficient * 100)}%</span>
          </div>
          <div className="advanced-stat">
            <span className="stat-name">Плотность сети:</span>
            <span className="stat-value">{Math.round(networkStats.networkDensity * 100)}%</span>
          </div>
        </div>
      )}
    </div>
  );

  const ConnectionLegend = () => (
    <div className="connection-legend">
      <h4>Типы связей</h4>
      {Object.entries(connectionTypes).map(([type, config]) => (
        <div key={type} className="legend-item">
          <div 
            className="legend-line"
            style={{ 
              backgroundColor: config.color,
              height: `${config.strength}px`
            }}
          />
          <span className="legend-label">{config.label}</span>
        </div>
      ))}
    </div>
  );

  const InfluenceLegend = () => (
    <div className="influence-legend">
      <h4>Уровни влияния</h4>
      {Object.entries(influenceCategories).reverse().map(([level, config]) => (
        <div key={level} className="legend-item">
          <div 
            className="legend-circle"
            style={{ 
              backgroundColor: config.color,
              width: `${config.size}px`,
              height: `${config.size}px`
            }}
          />
          <span className="legend-label">
            {level.charAt(0).toUpperCase() + level.slice(1)} ({config.threshold}+ IP)
          </span>
        </div>
      ))}
    </div>
  );

  const NetworkRecommendations = () => (
    <div className="network-recommendations">
      <h3>Рекомендации по развитию сети</h3>
      {networkStats.recommendations?.map((recommendation, index) => (
        <motion.div
          key={index}
          className="recommendation-item"
          initial={{ opacity: 0, x: -20 }}
          animate={{ opacity: 1, x: 0 }}
          transition={{ delay: index * 0.2 }}
        >
          <div className="recommendation-icon">💡</div>
          <div className="recommendation-text">{recommendation}</div>
          <HoloButton
            onClick={() => {/* Применить рекомендацию */}}
            glowColor="#ffd93d"
          >
            Применить
          </HoloButton>
        </motion.div>
      ))}
    </div>
  );

  return (
    <div className="influence-network">
      <motion.div 
        className="network-header"
        initial={{ opacity: 0, y: -30 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.8 }}
      >
        <h2>Сеть Влияния</h2>
        <p>Визуализация ваших связей и влияния в сообществе</p>
        
        <div className="network-controls">
          <div className="view-modes">
            {['influence', 'connections', 'activity'].map(mode => (
              <HoloButton
                key={mode}
                onClick={() => setViewMode(mode)}
                glowColor={viewMode === mode ? '#00ff88' : '#666666'}
              >
                {mode === 'influence' ? '⚡ Влияние' :
                 mode === 'connections' ? '🔗 Связи' : '📊 Активность'}
              </HoloButton>
            ))}
          </div>
          
          <HoloButton
            onClick={analyzeNetwork}
            disabled={isAnalyzing}
            glowColor="#4ecdc4"
          >
            {isAnalyzing ? '🔄 Анализ...' : '🔍 Анализировать сеть'}
          </HoloButton>
        </div>
      </motion.div>

      <div className="network-container">
        <div className="network-visualization">
          <svg
            ref={svgRef}
            width="800"
            height="600"
            className="network-svg"
          />
          
          <div className="network-legends">
            <ConnectionLegend />
            <InfluenceLegend />
          </div>
        </div>

        <div className="network-sidebar">
          <NetworkStats />
          
          {selectedNode && (
            <motion.div
              className="node-details"
              initial={{ opacity: 0, scale: 0.8 }}
              animate={{ opacity: 1, scale: 1 }}
            >
              <div className="node-header">
                <span className="node-avatar">{selectedNode.avatar}</span>
                <div className="node-info">
                  <h4>{selectedNode.name}</h4>
                  {selectedNode.specialization && (
                    <p className="node-specialization">{selectedNode.specialization}</p>
                  )}
                </div>
                <button 
                  className="close-node"
                  onClick={() => setSelectedNode(null)}
                >
                  ✕
                </button>
              </div>
              
              <div className="node-stats">
                <div className="node-stat">
                  <span className="stat-label">Влияние:</span>
                  <span className="stat-value">{selectedNode.influence} IP</span>
                </div>
                <div className="node-stat">
                  <span className="stat-label">Уровень:</span>
                  <span className="stat-value">{selectedNode.level}</span>
                </div>
                <div className="node-stat">
                  <span className="stat-label">Тип:</span>
                  <span className="stat-value">{selectedNode.type}</span>
                </div>
              </div>
              
              {selectedNode.id !== 'user' && (
                <div className="node-actions">
                  <HoloButton
                    onClick={() => {/* Отправить сообщение */}}
                    glowColor="#4ecdc4"
                  >
                    💬 Сообщение
                  </HoloButton>
                  <HoloButton
                    onClick={() => {/* Предложить коллаборацию */}}
                    glowColor="#ffd93d"
                  >
                    🤝 Коллаборация
                  </HoloButton>
                </div>
              )}
            </motion.div>
          )}
          
          {networkStats.recommendations && (
            <NetworkRecommendations />
          )}
        </div>
      </div>

      {/* Анимация анализа */}
      <AnimatePresence>
        {isAnalyzing && (
          <motion.div
            className="analysis-overlay"
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
          >
            <div className="analysis-content">
              <motion.div
                className="analysis-spinner"
                animate={{ rotate: 360 }}
                transition={{ duration: 2, repeat: Infinity, ease: "linear" }}
              >
                🌐
              </motion.div>
              <h3>Анализ сети влияния...</h3>
              <div className="analysis-steps">
                {['Сканирование связей', 'Расчет метрик', 'Поиск паттернов', 'Генерация рекомендаций'].map((step, index) => (
                  <motion.div
                    key={step}
                    className="analysis-step"
                    animate={{
                      opacity: [0.3, 1, 0.3]
                    }}
                    transition={{
                      duration: 1,
                      repeat: Infinity,
                      delay: index * 0.3
                    }}
                  >
                    {step}
                  </motion.div>
                ))}
              </div>
            </div>
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
};

export default InfluenceNetwork;
15. MentorshipPortal.jsx — портал наставничества
import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { HoloCard, HoloButton, HoloProgress } from './HolographicUI';
import './MentorshipPortal.css';

const MentorshipPortal = ({ userLevel, influencePoints }) => {
  const [userRole, setUserRole] = useState('both'); // mentor, mentee, both
  const [mentorships, setMentorships] = useState([]);
  const [availableMentors, setAvailableMentors] = useState([]);
  const [seekingMentees, setSeekingMentees] = useState([]);
  const [selectedMentorship, setSelectedMentorship] = useState(null);
  const [mentorshipRequests, setMentorshipRequests] = useState([]);
  const [knowledgeAreas, setKnowledgeAreas] = useState([]);

  const skillCategories = {
    photography: { name: 'Фотография', icon: '📸', color: '#ff6b6b' },
    planning: { name: 'Планирование', icon: '📋', color: '#4ecdc4' },
    blogging: { name: 'Блогинг', icon: '✍️', color: '#ffd93d' },
    languages: { name: 'Языки', icon: '🗣️', color: '#9933ff' },
    navigation: { name: 'Навигация', icon: '🧭', color: '#00ff88' },
    budgeting: { name: 'Бюджетирование', icon: '💰', color: '#ff9500' },
    safety: { name: 'Безопасность', icon: '🛡️', color: '#888888' },
    networking: { name: 'Нетворкинг', icon: '🤝', color: '#a8e6cf' }
  };

  const mockMentorships = [
    {
      id: 'mentor_1',
      type: 'as_mentor',
      mentee: {
        name: 'Алексей Новичок',
        avatar: '👨‍💼',
        level: 3,
        skills: ['planning', 'budgeting'],
        goal: 'Планирование первого самостоятельного путешествия'
      },
      skill: 'planning',
      startDate: '2024-01-15',
      progress: 65,
      sessions: 8,
      nextSession: '2024-02-20 18:00',
      status: 'active'
    },
    {
      id: 'mentee_1',
      type: 'as_mentee',
      mentor: {
        name: 'Мария Эксперт',
        avatar: '👩‍🏫',
        level: 22,
        rating: 4.9,
        specialization: 'Фотография путешествий'
      },
      skill: 'photography',
      startDate: '2024-01-10',
      progress: 40,
      sessions: 5,
      nextSession: '2024-02-18 20:00',
      status: 'active'
    }
  ];

  const mockAvailableMentors = [
    {
      id: 'mentor_available_1',
      name: 'Елена Профи',
      avatar: '👩‍🎓',
      level: 25,
      rating: 4.8,
      specializations: ['languages', 'networking'],
      experience: '5+ лет',
      mentees: 23,
      price: 0, // бесплатно
      description: 'Помогу освоить языки для путешествий и построить сеть контактов',
      availability: 'Вечера будних дней'
    },
    {
      id: 'mentor_available_2',
      name: 'Дмитрий Гуру',
      avatar: '👨‍🏫',
      level: 28,
      rating: 4.9,
      specializations: ['safety', 'navigation'],
      experience: '8+ лет',
      mentees: 45,
      price: 100, // IP за сессию
      description: 'Эксперт по безопасности в путешествиях и навигации',
      availability: 'Выходные'
    }
  ];

  const mockSeekingMentees = [
    {
      id: 'mentee_seeking_1',
      name: 'Анна Стартер',
      avatar: '👩‍💻',
      level: 2,
      interests: ['photography', 'blogging'],
      goal: 'Создать качественный блог о путешествиях',
      experience: 'Новичок',
      commitment: 'Высокая',
      preferredSchedule: 'Гибкий график'
    },
    {
      id: 'mentee_seeking_2',
      name: 'Игорь Исследователь',
      avatar: '👨‍🔬',
      level: 6,
      interests: ['planning', 'budgeting'],
      goal: 'Оптимизировать расходы на путешествия',
      experience: 'Средний',
      commitment: 'Средняя',
      preferredSchedule: 'Вечера'
    }
  ];

  useEffect(() => {
    setMentorships(mockMentorships);
    setAvailableMentors(mockAvailableMentors);
    setSeekingMentees(mockSeekingMentees);
    
    // Определяем области знаний пользователя
    const userKnowledge = [
      { skill: 'planning', level: 8, canMentor: userLevel >= 10 },
      { skill: 'photography', level: 6, canMentor: userLevel >= 8 },
      { skill: 'blogging', level: 7, canMentor: userLevel >= 9 },
      { skill: 'languages', level: 5, canMentor: userLevel >= 7 },
      { skill: 'navigation', level: 4, canMentor: false },
      { skill: 'budgeting', level: 9, canMentor: userLevel >= 12 }
    ];
    
    setKnowledgeAreas(userKnowledge);
  }, [userLevel]);

  const requestMentorship = (mentorId, skill) => {
    const newRequest = {
      id: Date.now(),
      mentorId,
      skill,
      message: `Хочу изучить ${skillCategories[skill].name}`,
      status: 'pending',
      createdAt: new Date()
    };
    
    setMentorshipRequests(prev => [...prev, newRequest]);
  };

  const acceptMentee = (menteeId, skill) => {
    const newMentorship = {
      id: Date.now(),
      type: 'as_mentor',
      mentee: mockSeekingMentees.find(m => m.id === menteeId),
      skill,
      startDate: new Date().toISOString().split('T')[0],
      progress: 0,
      sessions: 0,
      status: 'active'
    };
    
    setMentorships(prev => [...prev, newMentorship]);
    setSeekingMentees(prev => prev.filter(m => m.id !== menteeId));
  };

  const MentorshipCard = ({ mentorship }) => {
    const skill = skillCategories[mentorship.skill];
    const isMentor = mentorship.type === 'as_mentor';
    const partner = isMentor ? mentorship.mentee : mentorship.mentor;
    
    return (
      <HoloCard
        title={`${skill.name} - ${isMentor ? 'Наставничество' : 'Обучение'}`}
        subtitle={`с ${partner.name}`}
        icon={skill.icon}
        glowColor={skill.color}
      >
        <div className="mentorship-content">
          <div className="partner-info">
            <span className="partner-avatar">{partner.avatar}</span>
            <div className="partner-details">
              <h4>{partner.name}</h4>
              <p>Уровень: {partner.level}</p>
              {partner.rating && <p>Рейтинг: ⭐ {partner.rating}</p>}
              {partner.goal && <p className="goal">Цель: {partner.goal}</p>}
            </div>
          </div>
          
          <div className="mentorship-progress">
            <HoloProgress
              value={mentorship.progress}
              max={100}
              label="Прогресс обучения"
              glowColor={skill.color}
            />
            <div className="progress-details">
              <span>Сессий проведено: {mentorship.sessions}</span>
              <span>Начато: {new Date(mentorship.startDate).toLocaleDateString()}</span>
            </div>
          </div>
          
          {mentorship.nextSession && (
            <div className="next-session">
              <span className="session-icon">📅</span>
              <span>Следующая сессия: {mentorship.nextSession}</span>
            </div>
          )}
          
          <div className="mentorship-actions">
            <HoloButton
              onClick={() => setSelectedMentorship(mentorship)}
              glowColor={skill.color}
            >
              📋 Подробнее
            </HoloButton>
            <HoloButton
              onClick={() => {/* Начать сессию */}}
              glowColor="#00ff88"
            >
              🎥 Начать сессию
            </HoloButton>
          </div>
        </div>
      </HoloCard>
    );
  };

  const MentorCard = ({ mentor }) => (
    <HoloCard
      title={mentor.name}
      subtitle={`${mentor.experience} опыта`}
      icon={mentor.avatar}
      glowColor="#4ecdc4"
    >
      <div className="mentor-content">
        <div className="mentor-stats">
          <div className="stat-item">
            <span className="stat-label">Уровень:</span>
            <span className="stat-value">{mentor.level}</span>
          </div>
          <div className="stat-item">
            <span className="stat-label">Рейтинг:</span>
            <span className="stat-value">⭐ {mentor.rating}</span>
          </div>
          <div className="stat-item">
            <span className="stat-label">Учеников:</span>
            <span className="stat-value">{mentor.mentees}</span>
          </div>
        </div>
        
        <div className="mentor-specializations">
          <h5>Специализации:</h5>
          <div className="specialization-tags">
            {mentor.specializations.map(spec => (
              <span 
                key={spec}
                className="specialization-tag"
                style={{ backgroundColor: `${skillCategories[spec].color}40` }}
              >
                {skillCategories[spec].icon} {skillCategories[spec].name}
              </span>
            ))}
          </div>
        </div>
        
        <p className="mentor-description">{mentor.description}</p>
        
        <div className="mentor-details">
          <div className="detail-item">
            <span className="detail-label">Доступность:</span>
            <span className="detail-value">{mentor.availability}</span>
          </div>
          <div className="detail-item">
            <span className="detail-label">Стоимость:</span>
            <span className="detail-value">
              {mentor.price === 0 ? 'Бесплатно' : `${mentor.price} IP/сессия`}
            </span>
          </div>
        </div>
        
        <div className="mentor-actions">
          {mentor.specializations.map(spec => (
            <HoloButton
              key={spec}
              onClick={() => requestMentorship(mentor.id, spec)}
              glowColor={skillCategories[spec].color}
              disabled={influencePoints < mentor.price}
            >
              Изучать {skillCategories[spec].name}
            </HoloButton>
          ))}
        </div>
      </div>
    </HoloCard>
  );

  const MenteeCard = ({ mentee }) => (
    <HoloCard
      title={mentee.name}
      subtitle={`Уровень ${mentee.level}`}
      icon={mentee.avatar}
      glowColor="#ffd93d"
    >
      <div className="mentee-content">
        <div className="mentee-goal">
          <h5>Цель:</h5>
          <p>{mentee.goal}</p>
        </div>
        
        <div className="mentee-interests">
          <h5>Интересы:</h5>
          <div className="interest-tags">
            {mentee.interests.map(interest => (
              <span 
                key={interest}
                className="interest-tag"
                style={{ backgroundColor: `${skillCategories[interest].color}40` }}
              >
                {skillCategories[interest].icon} {skillCategories[interest].name}
              </span>
            ))}
          </div>
        </div>
        
        <div className="mentee-details">
          <div className="detail-item">
            <span className="detail-label">Опыт:</span>
            <span className="detail-value">{mentee.experience}</span>
          </div>
          <div className="detail-item">
            <span className="detail-label">Готовность:</span>
            <span className="detail-value">{mentee.commitment}</span>
          </div>
          <div className="detail-item">
            <span className="detail-label">График:</span>
            <span className="detail-value">{mentee.preferredSchedule}</span>
          </div>
        </div>
        
        <div className="mentee-actions">
          {mentee.interests.map(interest => {
            const canMentor = knowledgeAreas.find(ka => ka.skill === interest)?.canMentor;
            return (
              <HoloButton
                key={interest}
                onClick={() => canMentor && acceptMentee(mentee.id, interest)}
                glowColor={canMentor ? skillCategories[interest].color : '#666666'}
                disabled={!canMentor}
              >
                {canMentor ? `Обучать ${skillCategories[interest].name}` : 'Недостаточно опыта'}
              </HoloButton>
            );
          })}
        </div>
      </div>
    </HoloCard>
  );

  const KnowledgeMatrix = () => (
    <div className="knowledge-matrix">
      <h3>Матрица Знаний</h3>
      <div className="matrix-grid">
        {knowledgeAreas.map(area => {
          const skill = skillCategories[area.skill];
          return (
            <motion.div
              key={area.skill}
              className={`knowledge-item ${area.canMentor ? 'can-mentor' : 'learning'}`}
              whileHover={{ scale: 1.05 }}
              style={{ borderColor: skill.color }}
            >
              <div className="skill-header">
                <span className="skill-icon">{skill.icon}</span>
                <h4>{skill.name}</h4>
                {area.canMentor && <span className="mentor-badge">Наставник</span>}
              </div>
              
              <div className="skill-level">
                <HoloProgress
                  value={area.level}
                  max={10}
                  label="Уровень навыка"
                  glowColor={skill.color}
                />
                <span className="level-text">{area.level}/10</span>
              </div>
              
              <div className="skill-status">
                {area.canMentor ? (
                  <span className="status-mentor">Можете обучать других</span>
                ) : (

                  <span className="status-learning">Продолжайте изучение</span>
                )}
              </div>
            </motion.div>
          );
        })}
      </div>
    </div>
  );

  const MentorshipStats = () => {
    const mentorCount = mentorships.filter(m => m.type === 'as_mentor').length;
    const menteeCount = mentorships.filter(m => m.type === 'as_mentee').length;
    const totalSessions = mentorships.reduce((sum, m) => sum + m.sessions, 0);
    const avgProgress = mentorships.reduce((sum, m) => sum + m.progress, 0) / mentorships.length || 0;

    return (
      <div className="mentorship-stats">
        <h3>Статистика Наставничества</h3>
        <div className="stats-grid">
          <div className="stat-card">
            <div className="stat-icon">👨‍🏫</div>
            <div className="stat-value">{mentorCount}</div>
            <div className="stat-label">Учеников</div>
          </div>
          
          <div className="stat-card">
            <div className="stat-icon">👨‍🎓</div>
            <div className="stat-value">{menteeCount}</div>
            <div className="stat-label">Наставников</div>
          </div>
          
          <div className="stat-card">
            <div className="stat-icon">📚</div>
            <div className="stat-value">{totalSessions}</div>
            <div className="stat-label">Сессий проведено</div>
          </div>
          
          <div className="stat-card">
            <div className="stat-icon">📈</div>
            <div className="stat-value">{Math.round(avgProgress)}%</div>
            <div className="stat-label">Средний прогресс</div>
          </div>
        </div>
      </div>
    );
  };

  const SessionPlanner = () => {
    const [newSession, setNewSession] = useState({
      mentorshipId: '',
      date: '',
      time: '',
      topic: '',
      duration: 60
    });

    const scheduledSessions = mentorships
      .filter(m => m.nextSession)
      .map(m => ({
        ...m,
        sessionDate: new Date(m.nextSession)
      }))
      .sort((a, b) => a.sessionDate - b.sessionDate);

    return (
      <div className="session-planner">
        <h3>Планировщик Сессий</h3>
        
        <div className="upcoming-sessions">
          <h4>Предстоящие сессии</h4>
          {scheduledSessions.length === 0 ? (
            <p className="no-sessions">Нет запланированных сессий</p>
          ) : (
            <div className="sessions-list">
              {scheduledSessions.map(session => {
                const skill = skillCategories[session.skill];
                const partner = session.type === 'as_mentor' ? session.mentee : session.mentor;
                
                return (
                  <motion.div
                    key={session.id}
                    className="session-item"
                    whileHover={{ scale: 1.02 }}
                    style={{ borderColor: skill.color }}
                  >
                    <div className="session-info">
                      <div className="session-skill">
                        <span className="skill-icon">{skill.icon}</span>
                        <span className="skill-name">{skill.name}</span>
                      </div>
                      <div className="session-partner">
                        <span className="partner-avatar">{partner.avatar}</span>
                        <span className="partner-name">{partner.name}</span>
                      </div>
                      <div className="session-time">
                        {session.nextSession}
                      </div>
                    </div>
                    
                    <div className="session-actions">
                      <HoloButton
                        onClick={() => {/* Присоединиться к сессии */}}
                        glowColor="#00ff88"
                      >
                        🎥 Присоединиться
                      </HoloButton>
                      <HoloButton
                        onClick={() => {/* Перенести сессию */}}
                        glowColor="#ffd93d"
                      >
                        📅 Перенести
                      </HoloButton>
                    </div>
                  </motion.div>
                );
              })}
            </div>
          )}
        </div>
        
        <div className="schedule-new-session">
          <h4>Запланировать новую сессию</h4>
          <div className="session-form">
            <select
              value={newSession.mentorshipId}
              onChange={(e) => setNewSession(prev => ({ ...prev, mentorshipId: e.target.value }))}
              className="form-select"
            >
              <option value="">Выберите наставничество</option>
              {mentorships.map(m => {
                const skill = skillCategories[m.skill];
                const partner = m.type === 'as_mentor' ? m.mentee : m.mentor;
                return (
                  <option key={m.id} value={m.id}>
                    {skill.name} с {partner.name}
                  </option>
                );
              })}
            </select>
            
            <input
              type="date"
              value={newSession.date}
              onChange={(e) => setNewSession(prev => ({ ...prev, date: e.target.value }))}
              className="form-input"
            />
            
            <input
              type="time"
              value={newSession.time}
              onChange={(e) => setNewSession(prev => ({ ...prev, time: e.target.value }))}
              className="form-input"
            />
            
            <input
              type="text"
              placeholder="Тема сессии"
              value={newSession.topic}
              onChange={(e) => setNewSession(prev => ({ ...prev, topic: e.target.value }))}
              className="form-input"
            />
            
            <HoloButton
              onClick={() => {/* Запланировать сессию */}}
              glowColor="#4ecdc4"
              disabled={!newSession.mentorshipId || !newSession.date || !newSession.time}
            >
              📅 Запланировать
            </HoloButton>
          </div>
        </div>
      </div>
    );
  };

  return (
    <div className="mentorship-portal">
      <motion.div 
        className="portal-header"
        initial={{ opacity: 0, y: -30 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.8 }}
      >
        <h2>Портал Наставничества</h2>
        <p>Обучайте и учитесь у лучших путешественников</p>
        
        <div className="role-selector">
          <HoloButton
            onClick={() => setUserRole('mentor')}
            glowColor={userRole === 'mentor' ? '#ff6b6b' : '#666666'}
          >
            👨‍🏫 Наставник
          </HoloButton>
          <HoloButton
            onClick={() => setUserRole('mentee')}
            glowColor={userRole === 'mentee' ? '#4ecdc4' : '#666666'}
          >
            👨‍🎓 Ученик
          </HoloButton>
          <HoloButton
            onClick={() => setUserRole('both')}
            glowColor={userRole === 'both' ? '#ffd93d' : '#666666'}
          >
            🔄 Оба
          </HoloButton>
        </div>
      </motion.div>

      <div className="portal-content">
        <div className="main-section">
          <MentorshipStats />
          <KnowledgeMatrix />
          
          {mentorships.length > 0 && (
            <div className="active-mentorships">
              <h3>Активные Наставничества</h3>
              <div className="mentorships-grid">
                {mentorships.map((mentorship, index) => (
                  <motion.div
                    key={mentorship.id}
                    initial={{ opacity: 0, y: 20 }}
                    animate={{ opacity: 1, y: 0 }}
                    transition={{ delay: index * 0.1 }}
                  >
                    <MentorshipCard mentorship={mentorship} />
                  </motion.div>
                ))}
              </div>
            </div>
          )}
          
          {(userRole === 'mentee' || userRole === 'both') && (
            <div className="available-mentors">
              <h3>Доступные Наставники</h3>
              <div className="mentors-grid">
                {availableMentors.map((mentor, index) => (
                  <motion.div
                    key={mentor.id}
                    initial={{ opacity: 0, y: 20 }}
                    animate={{ opacity: 1, y: 0 }}
                    transition={{ delay: index * 0.1 }}
                  >
                    <MentorCard mentor={mentor} />
                  </motion.div>
                ))}
              </div>
            </div>
          )}
          
          {(userRole === 'mentor' || userRole === 'both') && (
            <div className="seeking-mentees">
              <h3>Ищут Наставника</h3>
              <div className="mentees-grid">
                {seekingMentees.map((mentee, index) => (
                  <motion.div
                    key={mentee.id}
                    initial={{ opacity: 0, y: 20 }}
                    animate={{ opacity: 1, y: 0 }}
                    transition={{ delay: index * 0.1 }}
                  >
                    <MenteeCard mentee={mentee} />
                  </motion.div>
                ))}
              </div>
            </div>
          )}
        </div>

        <div className="sidebar-section">
          <SessionPlanner />
          
          {mentorshipRequests.length > 0 && (
            <div className="mentorship-requests">
              <h3>Запросы на Наставничество</h3>
              {mentorshipRequests.map(request => (
                <motion.div
                  key={request.id}
                  className="request-item"
                  initial={{ opacity: 0, x: 20 }}
                  animate={{ opacity: 1, x: 0 }}
                >
                  <div className="request-info">
                    <span className="request-skill">
                      {skillCategories[request.skill].icon} {skillCategories[request.skill].name}
                    </span>
                    <span className="request-status">{request.status}</span>
                  </div>
                  <p className="request-message">{request.message}</p>
                  <div className="request-actions">
                    <HoloButton
                      onClick={() => {/* Принять запрос */}}
                      glowColor="#00ff88"
                    >
                      ✅ Принять
                    </HoloButton>
                    <HoloButton
                      onClick={() => {/* Отклонить запрос */}}
                      glowColor="#ff6b6b"
                    >
                      ❌ Отклонить
                    </HoloButton>
                  </div>
                </motion.div>
              ))}
            </div>
          )}
        </div>
      </div>

      {/* Детали наставничества */}
      <AnimatePresence>
        {selectedMentorship && (
          <motion.div
            className="mentorship-detail-overlay"
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            onClick={() => setSelectedMentorship(null)}
          >
            <motion.div
              className="mentorship-detail-modal"
              initial={{ scale: 0.8, y: 50 }}
              animate={{ scale: 1, y: 0 }}
              exit={{ scale: 0.8, y: 50 }}
              onClick={(e) => e.stopPropagation()}
            >
              <div className="modal-header">
                <div className="header-info">
                  <h3>Детали Наставничества</h3>
                  <p>{skillCategories[selectedMentorship.skill].name}</p>
                </div>
                <button 
                  className="close-btn"
                  onClick={() => setSelectedMentorship(null)}
                >
                  ✕
                </button>
              </div>
              
              <div className="modal-content">
                <div className="mentorship-timeline">
                  <h4>История Обучения</h4>
                  <div className="timeline-items">
                    {[...Array(selectedMentorship.sessions)].map((_, index) => (
                      <div key={index} className="timeline-item">
                        <div className="timeline-date">
                          Сессия {index + 1}
                        </div>
                        <div className="timeline-content">
                          Тема: Основы {skillCategories[selectedMentorship.skill].name}
                        </div>
                      </div>
                    ))}
                  </div>
                </div>
                
                <div className="progress-analysis">
                  <h4>Анализ Прогресса</h4>
                  <HoloProgress
                    value={selectedMentorship.progress}
                    max={100}
                    label="Общий прогресс"
                    glowColor={skillCategories[selectedMentorship.skill].color}
                  />
                  <div className="progress-insights">
                    <p>Отличный прогресс! Продолжайте в том же духе.</p>
                    <p>Рекомендуется больше практических заданий.</p>
                  </div>
                </div>
                
                <div className="next-steps">
                  <h4>Следующие Шаги</h4>
                  <ul>
                    <li>Практическое задание по пройденной теме</li>
                    <li>Подготовка к следующей сессии</li>
                    <li>Изучение дополнительных материалов</li>
                  </ul>
                </div>
              </div>
            </motion.div>
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
};

export default MentorshipPortal;
Продолжить работу с остальными компонентами? У нас осталось:

Доска мечты.jsx
LegacyBuilder.jsx
Сезонные события.jsx
Персональный музей.jsx
А затем CSS-файлы для стилизации всех компонентов.
17. DreamBoard.jsx — Доска мечты (ПОЛНАЯ ВЕРСИЯ)
import React, { useState, useEffect, useRef } from 'react';
import './DreamBoard.css';

const DreamBoard = ({ userId, dreams, onAddDream, onUpdateDream }) => {
  const [selectedDream, setSelectedDream] = useState(null);
  const [isAddingDream, setIsAddingDream] = useState(false);
  const [newDream, setNewDream] = useState({
    title: '',
    description: '',
    targetDate: '',
    category: 'travel',
    priority: 'medium',
    image: null
  });
  const [dreamProgress, setDreamProgress] = useState({});
  const canvasRef = useRef(null);

  useEffect(() => {
    initializeCanvas();
    animateStars();
  }, []);

  const initializeCanvas = () => {
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    
    for (let i = 0; i < 100; i++) {
      createStar(ctx);
    }
  };

  const createStar = (ctx) => {
    const x = Math.random() * ctx.canvas.width;
    const y = Math.random() * ctx.canvas.height;
    const size = Math.random() * 2;
    const opacity = Math.random();
    
    ctx.beginPath();
    ctx.arc(x, y, size, 0, Math.PI * 2);
    ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
    ctx.fill();
  };

  const animateStars = () => {
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    
    setInterval(() => {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      for (let i = 0; i < 100; i++) {
        createStar(ctx);
      }
    }, 3000);
  };

  const handleAddDream = () => {
    if (newDream.title && newDream.description) {
      const dreamData = {
        ...newDream,
        id: Date.now(),
        createdAt: new Date(),
        progress: 0,
        milestones: [],
        status: 'active'
      };
      
      onAddDream(dreamData);
      setNewDream({
        title: '',
        description: '',
        targetDate: '',
        category: 'travel',
        priority: 'medium',
        image: null
      });
      setIsAddingDream(false);
    }
  };

  const calculateProgress = (dream) => {
    if (!dream.milestones || dream.milestones.length === 0) return 0;
    const completed = dream.milestones.filter(m => m.completed).length;
    return (completed / dream.milestones.length) * 100;
  };

  const getDreamCategoryIcon = (category) => {
    const icons = {
      travel: '✈️',
      adventure: '🏔️',
      culture: '🎭',
      food: '🍜',
      photography: '📸',
      learning: '📚',
      social: '👥'
    };
    return icons[category] || '⭐';
  };

  const getPriorityColor = (priority) => {
    const colors = {
      high: '#ff6b6b',
      medium: '#ffd93d',
      low: '#6bcf7f'
    };
    return colors[priority] || '#6bcf7f';
  };

  return (
    <div className="dream-board">
      <canvas ref={canvasRef} className="dream-canvas" />
      
      <div className="dream-board-header">
        <h2 className="dream-title">
          <span className="dream-icon">🌟</span>
          Доска Мечты
        </h2>
        <button 
          className="add-dream-btn"
          onClick={() => setIsAddingDream(true)}
        >
          <span>+</span> Добавить мечту
        </button>
      </div>

      <div className="dreams-constellation">
        {dreams.map((dream, index) => (
          <div 
            key={dream.id}
            className={`dream-star ${selectedDream?.id === dream.id ? 'selected' : ''}`}
            style={{
              '--delay': `${index * 0.2}s`,
              '--priority-color': getPriorityColor(dream.priority)
            }}
            onClick={() => setSelectedDream(dream)}
          >
            <div className="dream-glow"></div>
            <div className="dream-content">
              <div className="dream-category-icon">
                {getDreamCategoryIcon(dream.category)}
              </div>
              <h3>{dream.title}</h3>
              <div className="dream-progress-ring">
                <svg className="progress-ring" width="60" height="60">
                  <circle
                    className="progress-ring-circle"
                    stroke="currentColor"
                    strokeWidth="3"
                    fill="transparent"
                    r="26"
                    cx="30"
                    cy="30"
                    style={{
                      strokeDasharray: `${calculateProgress(dream) * 1.63} 163`,
                      strokeDashoffset: 0
                    }}
                  />
                </svg>
                <span className="progress-text">
                  {Math.round(calculateProgress(dream))}%
                </span>
              </div>
            </div>
            <div className="dream-particles"></div>
          </div>
        ))}
      </div>

      {selectedDream && (
        <div className="dream-detail-modal">
          <div className="dream-detail-content">
            <button 
              className="close-modal"
              onClick={() => setSelectedDream(null)}
            >
              ×
            </button>
            
            <div className="dream-detail-header">
              <h2>{selectedDream.title}</h2>
              <span className="dream-category">
                {getDreamCategoryIcon(selectedDream.category)} {selectedDream.category}
              </span>
            </div>
            
            <div className="dream-description">
              <p>{selectedDream.description}</p>
            </div>
            
            <div className="dream-timeline">
              <h3>Этапы достижения</h3>
              <div className="milestones">
                {selectedDream.milestones?.map((milestone, index) => (
                  <div 
                    key={index}
                    className={`milestone ${milestone.completed ? 'completed' : ''}`}
                  >
                    <div className="milestone-marker"></div>
                    <div className="milestone-content">
                      <h4>{milestone.title}</h4>
                      <p>{milestone.description}</p>
                      {milestone.completed && (
                        <span className="completion-date">
                          Выполнено: {new Date(milestone.completedAt).toLocaleDateString()}
                        </span>
                      )}
                    </div>
                  </div>
                ))}
              </div>
            </div>
            
            <div className="dream-actions">
              <button className="update-progress-btn">
                Обновить прогресс
              </button>
              <button className="share-dream-btn">
                Поделиться мечтой
              </button>
            </div>
          </div>
        </div>
      )}

      {isAddingDream && (
        <div className="add-dream-modal">
          <div className="add-dream-content">
            <h2>Новая мечта</h2>
            
            <div className="dream-form">
              <input
                type="text"
                placeholder="Название мечты"
                value={newDream.title}
                onChange={(e) => setNewDream({...newDream, title: e.target.value})}
                className="dream-input"
              />
              
              <textarea
                placeholder="Описание мечты"
                value={newDream.description}
                onChange={(e) => setNewDream({...newDream, description: e.target.value})}
                className="dream-textarea"
              />
              
              <div className="dream-form-row">
                <select
                  value={newDream.category}
                  onChange={(e) => setNewDream({...newDream, category: e.target.value})}
                  className="dream-select"
                >
                  <option value="travel">Путешествия</option>
                  <option value="adventure">Приключения</option>
                  <option value="culture">Культура</option>
                  <option value="food">Еда</option>
                  <option value="photography">Фотография</option>
                  <option value="learning">Обучение</option>
                  <option value="social">Социальное</option>
                </select>
                
                <select
                  value={newDream.priority}
                  onChange={(e) => setNewDream({...newDream, priority: e.target.value})}
                  className="dream-select"
                >
                  <option value="low">Низкий приоритет</option>
                  <option value="medium">Средний приоритет</option>
                  <option value="high">Высокий приоритет</option>
                </select>
              </div>
              
              <input
                type="date"
                value={newDream.targetDate}
                onChange={(e) => setNewDream({...newDream, targetDate: e.target.value})}
                className="dream-input"
              />
              
              <div className="dream-form-actions">
                <button onClick={handleAddDream} className="save-dream-btn">
                  Сохранить мечту
                </button>
                <button 
                  onClick={() => setIsAddingDream(false)}
                  className="cancel-btn"
                >
                  Отмена
                </button>
              </div>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default DreamBoard;
18. LegacyBuilder.jsx — Строитель наследия (ПОЛНАЯ ВЕРСИЯ)
import React, { useState, useEffect, useRef } from 'react';
import './LegacyBuilder.css';

const LegacyBuilder = ({ userId, legacyData, contributions, onUpdateLegacy }) => {
  const [activeTab, setActiveTab] = useState('timeline');
  const [legacyMetrics, setLegacyMetrics] = useState({});
  const [impactVisualization, setImpactVisualization] = useState([]);
  const [selectedContribution, setSelectedContribution] = useState(null);
  const timelineRef = useRef(null);
  const canvasRef = useRef(null);

  useEffect(() => {
    calculateLegacyMetrics();
    generateImpactVisualization();
    initializeVisualization();
  }, [contributions]);

  const calculateLegacyMetrics = () => {
    const metrics = {
      totalContributions: contributions.length,
      peopleImpacted: contributions.reduce((sum, c) => sum + (c.impactCount || 0), 0),
      knowledgeShared: contributions.filter(c => c.type === 'knowledge').length,
      placesDocumented: contributions.filter(c => c.type === 'place').length,
      storiesPreserved: contributions.filter(c => c.type === 'story').length,
      connectionsCreated: contributions.filter(c => c.type === 'connection').length,
      legacyScore: calculateLegacyScore(contributions)
    };
    
    setLegacyMetrics(metrics);
  };

  const calculateLegacyScore = (contributions) => {
    return contributions.reduce((score, contribution) => {
      const baseScore = contribution.impactCount || 0;
      const timeMultiplier = Math.max(1, (Date.now() - new Date(contribution.createdAt)) / (1000 * 60 * 60 * 24 * 30));
      const typeMultiplier = {
        knowledge: 2,
        story: 1.5,
        place: 1.2,
        connection: 1.8
      }[contribution.type] || 1;
      
      return score + (baseScore * timeMultiplier * typeMultiplier);
    }, 0);
  };

  const generateImpactVisualization = () => {
    const visualization = contributions.map((contribution, index) => ({
      ...contribution,
      x: Math.random() * 800,
      y: Math.random() * 600,
      size: Math.min(50, Math.max(10, (contribution.impactCount || 1) * 2)),
      connections: contributions.filter(c => 
        c.relatedTo?.includes(contribution.id) || 
        contribution.relatedTo?.includes(c.id)
      )
    }));
    
    setImpactVisualization(visualization);
  };

  const initializeVisualization = () => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    canvas.width = 800;
    canvas.height = 600;
    
    drawImpactNetwork(ctx);
  };

  const drawImpactNetwork = (ctx) => {
    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    
    // Рисуем связи
    impactVisualization.forEach(node => {
      node.connections.forEach(connection => {
        const connectedNode = impactVisualization.find(n => n.id === connection.id);
        if (connectedNode) {
          ctx.beginPath();
          ctx.moveTo(node.x, node.y);
          ctx.lineTo(connectedNode.x, connectedNode.y);
          ctx.strokeStyle = 'rgba(100, 200, 255, 0.3)';
          ctx.lineWidth = 2;
          ctx.stroke();
        }
      });
    });
    
    // Рисуем узлы
    impactVisualization.forEach(node => {
      const gradient = ctx.createRadialGradient(node.x, node.y, 0, node.x, node.y, node.size);
      gradient.addColorStop(0, getContributionColor(node.type));
      gradient.addColorStop(1, 'rgba(0, 0, 0, 0.1)');
      
      ctx.beginPath();
      ctx.arc(node.x, node.y, node.size, 0, Math.PI * 2);
      ctx.fillStyle = gradient;
      ctx.fill();
      
      // Добавляем иконку
      ctx.font = `${node.size / 2}px Arial`;
      ctx.textAlign = 'center';
      ctx.fillStyle = '#fff';
      ctx.fillText(getContributionIcon(node.type), node.x, node.y + node.size / 6);
    });
  };

  const getContributionIcon = (type) => {
    const icons = {
      knowledge: '🧠',
      story: '📖',
      place: '📍',
      connection: '🤝',
      experience: '⭐',
      guide: '🗺️'
    };
    return icons[type] || '💫';
  };

  const getContributionColor = (type) => {
    const colors = {
      knowledge: '#4CAF50',
      story: '#FF9800',
      place: '#2196F3',
      connection: '#9C27B0',
      experience: '#F44336',
      guide: '#00BCD4'
    };
    return colors[type] || '#607D8B';
  };

  const getImpactLevel = (score) => {
    if (score < 100) return { level: 'Начинающий', color: '#4CAF50' };
    if (score < 500) return { level: 'Опытный', color: '#FF9800' };
    if (score < 1000) return { level: 'Эксперт', color: '#2196F3' };
    if (score < 2000) return { level: 'Мастер', color: '#9C27B0' };
    return { level: 'Легенда', color: '#F44336' };
  };

  const renderTimeline = () => (
    <div className="legacy-timeline" ref={timelineRef}>
      <div className="timeline-header">
        <h3>Временная линия наследия</h3>
        <div className="timeline-stats">
          <span>Всего вкладов: {legacyMetrics.totalContributions}</span>
          <span>Людей затронуто: {legacyMetrics.peopleImpacted}</span>
        </div>
      </div>
      
      <div className="timeline-container">
        {contributions
          .sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt))
          .map((contribution, index) => (
            <div key={contribution.id} className="timeline-item">
              <div className="timeline-marker">
                <span className="contribution-icon">
                  {getContributionIcon(contribution.type)}
                </span>
              </div>
              
              <div className="timeline-content">
                <div className="contribution-header">
                  <h4>{contribution.title}</h4>
                  <span className="contribution-date">
                    {new Date(contribution.createdAt).toLocaleDateString()}
                  </span>
                </div>
                
                <p className="contribution-description">
                  {contribution.description}
                </p>
                
                <div className="contribution-impact">
                  <div className="impact-metrics">
                    <span className="impact-count">
                      👥 {contribution.impactCount || 0} человек
                    </span>
                    <span className="impact-type">
                      {contribution.type}
                    </span>
                  </div>
                  
                  <div className="contribution-tags">
                    {contribution.tags?.map(tag => (
                      <span key={tag} className="tag">#{tag}</span>
                    ))}
                  </div>
                </div>
              </div>
            </div>
          ))}
      </div>
    </div>
  );

  const renderImpactNetwork = () => (
    <div className="impact-network">
      <div className="network-header">
        <h3>Сеть влияния</h3>
        <div className="network-legend">
          <div className="legend-item">
            <span className="legend-color knowledge"></span>
            <span>Знания</span>
          </div>
          <div className="legend-item">
            <span className="legend-color story"></span>
            <span>Истории</span>
          </div>
          <div className="legend-item">
            <span className="legend-color place"></span>
            <span>Места</span>
          </div>
          <div className="legend-item">
            <span className="legend-color connection"></span>
            <span>Связи</span>
          </div>
        </div>
      </div>
      
      <canvas 
        ref={canvasRef}
        className="impact-canvas"
        onClick={(e) => handleCanvasClick(e)}
      />
      
      <div className="network-stats">
        <div className="stat-item">
          <span className="stat-value">{legacyMetrics.knowledgeShared}</span>
          <span className="stat-label">Знаний поделено</span>
        </div>
        <div className="stat-item">
          <span className="stat-value">{legacyMetrics.storiesPreserved}</span>
          <span className="stat-label">Историй сохранено</span>
        </div>
        <div className="stat-item">
          <span className="stat-value">{legacyMetrics.placesDocumented}</span>
          <span className="stat-label">Мест задокументировано</span>
        </div>
        <div className="stat-item">
          <span className="stat-value">{legacyMetrics.connectionsCreated}</span>
          <span className="stat-label">Связей создано</span>
        </div>
      </div>
    </div>
  );

  const renderLegacyScore = () => {
    const impactLevel = getImpactLevel(legacyMetrics.legacyScore);
    
    return (
      <div className="legacy-score">
        <div className="score-header">
          <h3>Оценка наследия</h3>
          <div className="score-value" style={{ color: impactLevel.color }}>
            {Math.round(legacyMetrics.legacyScore)}
          </div>
        </div>
        
        <div className="score-level">
          <span className="level-badge" style={{ backgroundColor: impactLevel.color }}>
            {impactLevel.level}
          </span>
        </div>
        
        <div className="score-breakdown">
          <div className="breakdown-item">
            <span className="breakdown-label">Базовое влияние:</span>
            <span className="breakdown-value">{legacyMetrics.peopleImpacted}</span>
          </div>
          <div className="breakdown-item">
            <span className="breakdown-label">Временной множитель:</span>
            <span className="breakdown-value">×1.5</span>
          </div>
          <div className="breakdown-item">
            <span className="breakdown-label">Качественный бонус:</span>
            <span className="breakdown-value">+25%</span>
          </div>
        </div>
        
        <div className="score-progress">
          <div className="progress-bar">
            <div 
              className="progress-fill"
              style={{ 
                width: `${Math.min(100, (legacyMetrics.legacyScore / 2000) * 100)}%`,
                backgroundColor: impactLevel.color
              }}
            />
          </div>
          <span className="progress-text">
            До следующего уровня: {Math.max(0, getNextLevelThreshold(legacyMetrics.legacyScore) - legacyMetrics.legacyScore)}
          </span>
        </div>
      </div>
    );
  };

  const getNextLevelThreshold = (currentScore) => {
    if (currentScore < 100) return 100;
    if (currentScore < 500) return 500;
    if (currentScore < 1000) return 1000;
    if (currentScore < 2000) return 2000;
    return 5000;
  };

  const handleCanvasClick = (e) => {
    const canvas = canvasRef.current;
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    const clickedNode = impactVisualization.find(node => {
      const distance = Math.sqrt((x - node.x) ** 2 + (y - node.y) ** 2);
      return distance <= node.size;
    });
    
    if (clickedNode) {
      setSelectedContribution(clickedNode);
    }
  };

  return (
    <div className="legacy-builder">
      <div className="legacy-header">
        <h2 className="legacy-title">
          <span className="legacy-icon">🏛️</span>
          Строитель Наследия
        </h2>
        
        <div className="legacy-tabs">
          <button 
            className={`tab ${activeTab === 'timeline' ? 'active' : ''}`}
            onClick={() => setActiveTab('timeline')}
          >
            Временная линия
          </button>
          <button 
            className={`tab ${activeTab === 'network' ? 'active' : ''}`}
            onClick={() => setActiveTab('network')}
          >
            Сеть влияния
          </button>
          <button 
            className={`tab ${activeTab === 'score' ? 'active' : ''}`}
            onClick={() => setActiveTab('score')}
          >
            Оценка наследия
          </button>
        </div>
      </div>

      <div className="legacy-content">
        {activeTab === 'timeline' && renderTimeline()}
        {activeTab === 'network' && renderImpactNetwork()}
        {activeTab === 'score' && renderLegacyScore()}
      </div>

      {selectedContribution && (
        <div className="contribution-modal">
          <div className="contribution-modal-content">
            <button 
              className="close-modal"
              onClick={() => setSelectedContribution(null)}
            >
              ×
            </button>
            
            <div className="contribution-detail">
              <div className="contribution-icon-large">
                {getContributionIcon(selectedContribution.type)}
              </div>
              
              <h3>{selectedContribution.title}</h3>
              <p>{selectedContribution.description}</p>
              
              <div className="contribution-stats">
                <div className="stat">
                  <span className="stat-label">Влияние:</span>
                  <span className="stat-value">{selectedContribution.impactCount} человек</span>
                </div>
                <div className="stat">
                  <span className="stat-label">Дата создания:</span>
                  <span className="stat-value">
                    {new Date(selectedContribution.createdAt).toLocaleDateString()}
                  </span>
                </div>
                <div className="stat">
                  <span className="stat-label">Тип:</span>
                  <span className="stat-value">{selectedContribution.type}</span>
                </div>
              </div>
              
              {selectedContribution.connections.length > 0 && (
                <div className="related-contributions">
                  <h4>Связанные вклады:</h4>
                  <div className="related-list">
                    {selectedContribution.connections.map(conn => (
                      <div key={conn.id} className="related-item">
                        <span className="related-icon">
                          {getContributionIcon(conn.type)}
                        </span>
                        <span className="related-title">{conn.title}</span>
                      </div>
                    ))}
                  </div>
                </div>
              )}
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default LegacyBuilder;
19. SeasonalEvents.jsx — сезонные события
import React, { useState, useEffect, useRef } from 'react';
import './SeasonalEvents.css';

const SeasonalEvents = ({ userId, events, onJoinEvent, onCreateEvent }) => {
  const [currentSeason, setCurrentSeason] = useState('');
  const [activeEvents, setActiveEvents] = useState([]);
  const [upcomingEvents, setUpcomingEvents] = useState([]);
  const [selectedEvent, setSelectedEvent] = useState(null);
  const [isCreatingEvent, setIsCreatingEvent] = useState(false);
  const [newEvent, setNewEvent] = useState({
    title: '',
    description: '',
    startDate: '',
    endDate: '',
    type: 'seasonal',
    maxParticipants: 50,
    location: '',
    requirements: []
  });
  const [seasonalTheme, setSeasonalTheme] = useState({});
  const particlesRef = useRef(null);

  useEffect(() => {
    determineCurrentSeason();
    filterEventsBySeason();
    initializeSeasonalEffects();
  }, [events]);

  const determineCurrentSeason = () => {
    const month = new Date().getMonth();
    const seasons = {
      winter: [11, 0, 1], // декабрь, январь, февраль
      spring: [2, 3, 4],  // март, апрель, май
      summer: [5, 6, 7],  // июнь, июль, август
      autumn: [8, 9, 10]  // сентябрь, октябрь, ноябрь
    };
    
    const season = Object.keys(seasons).find(s => seasons[s].includes(month));
    setCurrentSeason(season);
    
    const themes = {
      winter: {
        name: 'Зимние приключения',
        icon: '❄️',
        colors: ['#E3F2FD', '#BBDEFB', '#90CAF9'],
        particles: 'snow',
        events: ['Лыжные туры', 'Новогодние путешествия', 'Зимние фестивали']
      },
      spring: {
        name: 'Весеннее пробуждение',
        icon: '🌸',
        colors: ['#F3E5F5', '#E1BEE7', '#CE93D8'],
        particles: 'petals',
        events: ['Цветение сакуры', 'Весенние походы', 'Фестивали цветов']
      },
      summer: {
        name: 'Летние приключения',
        icon: '☀️',
        colors: ['#FFF3E0', '#FFE0B2', '#FFCC02'],
        particles: 'sun',
        events: ['Пляжный отдых', 'Летние фестивали', 'Походы в горы']
      },
      autumn: {
        name: 'Осенние краски',
        icon: '🍂',
        colors: ['#FFF8E1', '#FFECB3', '#FFD54F'],
        particles: 'leaves',
        events: ['Сбор урожая', 'Осенние фотосессии', 'Винные туры']
      }
    };
    
    setSeasonalTheme(themes[season] || themes.spring);
  };

  const filterEventsBySeason = () => {
    const now = new Date();
    const active = events.filter(event => 
      new Date(event.startDate) <= now && new Date(event.endDate) >= now
    );
    const upcoming = events.filter(event => 
      new Date(event.startDate) > now
    ).sort((a, b) => new Date(a.startDate) - new Date(b.startDate));
    
    setActiveEvents(active);
    setUpcomingEvents(upcoming);
  };

  const initializeSeasonalEffects = () => {
    const canvas = particlesRef.current;
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    
    createSeasonalParticles(ctx);
  };

  const createSeasonalParticles = (ctx) => {
    const particleCount = 50;
    const particles = [];
    
    for (let i = 0; i < particleCount; i++) {
      particles.push({
        x: Math.random() * ctx.canvas.width,
        y: Math.random() * ctx.canvas.height,
        size: Math.random() * 5 + 2,
        speedX: (Math.random() - 0.5) * 2,
        speedY: Math.random() * 2 + 1,
        opacity: Math.random() * 0.5 + 0.3,
        rotation: Math.random() * 360
      });
    }
    
    const animateParticles = () => {
      ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
      
      particles.forEach(particle => {
        particle.x += particle.speedX;
        particle.y += particle.speedY;
        particle.rotation += 2;
        
        if (particle.y > ctx.canvas.height) {
          particle.y = -10;
          particle.x = Math.random() * ctx.canvas.width;
        }
        
        ctx.save();
        ctx.translate(particle.x, particle.y);
        ctx.rotate(particle.rotation * Math.PI / 180);
        ctx.globalAlpha = particle.opacity;
        
        drawSeasonalParticle(ctx, particle);
        
        ctx.restore();
      });
      
      requestAnimationFrame(animateParticles);
    };
    
    animateParticles();
  };

  const drawSeasonalParticle = (ctx, particle) => {
    switch (seasonalTheme.particles) {
      case 'snow':
        ctx.beginPath();
        ctx.arc(0, 0, particle.size, 0, Math.PI * 2);
        ctx.fillStyle = '#ffffff';
        ctx.fill();
        break;
        
      case 'petals':
        ctx.beginPath();
        ctx.ellipse(0, 0, particle.size, particle.size * 1.5, 0, 0, Math.PI * 2);
        ctx.fillStyle = '#ffb3d9';
        ctx.fill();
        break;
        
      case 'sun':
        ctx.beginPath();
        for (let i = 0; i < 8; i++) {
          const angle = (i * Math.PI * 2) / 8;
          const x = Math.cos(angle) * particle.size;
          const y = Math.sin(angle) * particle.size;
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.fillStyle = '#ffd700';
        ctx.fill();
        break;
        
      case 'leaves':
        ctx.beginPath();
        ctx.ellipse(0, 0, particle.size, particle.size * 2, Math.PI / 4, 0, Math.PI * 2);
        ctx.fillStyle = '#ff8c00';
        ctx.fill();
        break;
        
      default:
        ctx.beginPath();
        ctx.arc(0, 0, particle.size, 0, Math.PI * 2);
        ctx.fillStyle = '#ffffff';
        ctx.fill();
    }
  };

  const getEventTypeIcon = (type) => {
    const icons = {
      seasonal: seasonalTheme.icon,
      festival: '🎪',
      adventure: '🏔️',
      cultural: '🎭',
      food: '🍽️',
      photography: '📸',
      social: '👥'
    };
    return icons[type] || '🎉';
  };

  const handleCreateEvent = () => {
    if (newEvent.title && newEvent.description && newEvent.startDate) {
      const eventData = {
        ...newEvent,
        id: Date.now(),
        createdBy: userId,
        participants: [userId],
        createdAt: new Date(),
        season: currentSeason,
        status: 'upcoming'
      };
      
      onCreateEvent(eventData);
      setNewEvent({
        title: '',
        description: '',
        startDate: '',
        endDate: '',
        type: 'seasonal',
        maxParticipants: 50,
        location: '',
        requirements: []
      });
      setIsCreatingEvent(false);
    }
  };

  const handleJoinEvent = (eventId) => {
    onJoinEvent(eventId, userId);
  };

  const formatDate = (dateString) => {
    return new Date(dateString).toLocaleDateString('ru-RU', {
      day: 'numeric',
      month: 'long',
      year: 'numeric'
    });
  };

  const getTimeUntilEvent = (startDate) => {
    const now = new Date();
    const eventDate = new Date(startDate);
    const diffTime = eventDate - now;
    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
    
    if (diffDays < 0) return 'Идет сейчас';
    if (diffDays === 0) return 'Сегодня';
    if (diffDays === 1) return 'Завтра';
    return `Через ${diffDays} дней`;
  };

  return (
    <div className="seasonal-events" style={{ '--theme-color': seasonalTheme.colors?.[0] }}>
      <canvas ref={particlesRef} className="seasonal-particles" />
      
      <div className="seasonal-header">
        <div className="season-info">
          <h2 className="season-title">
            <span className="season-icon">{seasonalTheme.icon}</span>
            {seasonalTheme.name}
          </h2>
          <p className="season-description">
            Откройте для себя уникальные события этого сезона
          </p>
        </div>
        
        <button 
          className="create-event-btn"
          onClick={() => setIsCreatingEvent(true)}
        >
          <span>+</span> Создать событие
        </button>
      </div>

      <div className="events-sections">
        {/* Активные события */}
        <div className="events-section">
          <h3 className="section-title">
            <span className="section-icon">🔥</span>
            Активные события
          </h3>
          
          <div className="events-grid">
            {activeEvents.map(event => (
              <div key={event.id} className="event-card active">
                <div className="event-header">
                  <span className="event-type-icon">
                    {getEventTypeIcon(event.type)}
                  </span>
                  <div className="event-status">Идет сейчас</div>
                </div>
                
                <div className="event-content">
                  <h4 className="event-title">{event.title}</h4>
                  <p className="event-description">{event.description}</p>
                  
                  <div className="event-details">
                    <div className="event-detail">
                      <span className="detail-icon">📍</span>
                      <span>{event.location}</span>
                    </div>
                    <div className="event-detail">
                      <span className="detail-icon">👥</span>
                      <span>{event.participants?.length || 0}/{event.maxParticipants}</span>
                    </div>
                    <div className="event-detail">
                      <span className="detail-icon">📅</span>
                      <span>До {formatDate(event.endDate)}</span>
                    </div>
                  </div>
                </div>
                
                <div className="event-actions">
                  <button 
                    className="join-btn"
                    onClick={() => handleJoinEvent(event.id)}
                    disabled={event.participants?.includes(userId)}
                  >
                    {event.participants?.includes(userId) ? 'Участвуете' : 'Присоединиться'}
                  </button>
                  <button 
                    className="details-btn"
                    onClick={() => setSelectedEvent(event)}
                  >
                    Подробнее
                  </button>
                </div>
              </div>
            ))}
          </div>
        </div>

        {/* Предстоящие события */}
        <div className="events-section">
          <h3 className="section-title">
            <span className="section-icon">⏰</span>
            Предстоящие события
          </h3>
          
          <div className="events-grid">
            {upcomingEvents.map(event => (
              <div key={event.id} className="event-card upcoming">
                <div className="event-header">
                  <span className="event-type-icon">
                    {getEventTypeIcon(event.type)}
                  </span>
                  <div className="event-countdown">
                    {getTimeUntilEvent(event.startDate)}
                  </div>
                </div>
                
                <div className="event-content">
                  <h4 className="event-title">{event.title}</h4>
                  <p className="event-description">{event.description}</p>
                  
                  <div className="event-details">
                    <div className="event-detail">
                      <span className="detail-icon">📍</span>
                      <span>{event.location}</span>
                    </div>
                    <div className="event-detail">
                      <span className="detail-icon">👥</span>
                      <span>{event.participants?.length || 0}/{event.maxParticipants}</span>
                    </div>
                    <div className="event-detail">
                      <span className="detail-icon">📅</span>
                      <span>{formatDate(event.startDate)}</span>
                    </div>
                  </div>
                </div>
                
                <div className="event-actions">
                  <button 
                    className="join-btn"
                    onClick={() => handleJoinEvent(event.id)}
                    disabled={event.participants?.includes(userId)}
                  >
                    {event.participants?.includes(userId) ? 'Записаны' : 'Записаться'}
                  </button>
                  <button 
                    className="details-btn"
                    onClick={() => setSelectedEvent(event)}
                  >
                    Подробнее
                  </button>
                </div>
              </div>
            ))}
          </div>
        </div>
      </div>

      {/* Модальное окно создания события */}
      {isCreatingEvent && (
        <div className="create-event-modal">
          <div className="create-event-content">
            <h2>Создать новое событие</h2>
            
            <div className="event-form">
              <input
                type="text"
                placeholder="Название события"
                value={newEvent.title}
                onChange={(e) => setNewEvent({...newEvent, title: e.target.value})}
                className="event-input"
              />
              
              <textarea
                placeholder="Описание события"
                value={newEvent.description}
                onChange={(e) => setNewEvent({...newEvent, description: e.target.value})}
                className="event-textarea"
              />
              
              <div className="form-row">
                <input
                  type="datetime-local"
                  value={newEvent.startDate}
                  onChange={(e) => setNewEvent({...newEvent, startDate: e.target.value})}
                  className="event-input"
                />
                
                <input
                  type="datetime-local"
                  value={newEvent.endDate}
                  onChange={(e) => setNewEvent({...newEvent, endDate: e.target.value})}
                  className="event-input"
                />
              </div>
              
              <div className="form-row">
                <select
                  value={newEvent.type}
                  onChange={(e) => setNewEvent({...newEvent, type: e.target.value})}
                  className="event-select"
                >
                  <option value="seasonal">Сезонное</option>
                  <option value="festival">Фестиваль</option>
                  <option value="adventure">Приключение</option>
                  <option value="cultural">Культурное</option>
                  <option value="food">Гастрономическое</option>
                  <option value="photography">Фотография</option>
                  <option value="social">Социальное</option>
                </select>
                
                <input
                  type="number"
                  placeholder="Макс. участников"
                  value={newEvent.maxParticipants}
                  onChange={(e) => setNewEvent({...newEvent, maxParticipants: parseInt(e.target.value)})}
                  className="event-input"
                />
              </div>
              
              <input
                type="text"
                placeholder="Место проведения"
                value={newEvent.location}
                onChange={(e) => setNewEvent({...newEvent, location: e.target.value})}
                className="event-input"
              />
              
              <div className="form-actions">
                <button onClick={handleCreateEvent} className="save-event-btn">
                  Создать событие
                </button>
                <button 
                  onClick={() => setIsCreatingEvent(false)}
                  className="cancel-btn"
                >
                  Отмена
                </button>
              </div>
            </div>
          </div>
        </div>
      )}

      {/* Модальное окно деталей события */}
      {selectedEvent && (
        <div className="event-detail-modal">
          <div className="event-detail-content">
            <button 
              className="close-modal"
              onClick={() => setSelectedEvent(null)}
            >
              ×
            </button>
            
            <div className="event-detail-header">
              <span className="event-type-icon-large">
                {getEventTypeIcon(selectedEvent.type)}
              </span>
              <div>
                <h2>{selectedEvent.title}</h2>
                <p className="event-type">{selectedEvent.type}</p>
              </div>
            </div>
            
            <div className="event-detail-body">
              <p className="event-full-description">
                {selectedEvent.description}
              </p>
              
              <div className="event-info-grid">
                <div className="info-item">
                  <span className="info-label">📅 Начало:</span>
                  <span className="info-value">{formatDate(selectedEvent.startDate)}</span>
                </div>
                <div className="info-item">
                  <span className="info-label">📅 Окончание:</span>
                  <span className="info-value">{formatDate(selectedEvent.endDate)}</span>
                </div>
                <div className="info-item">
                  <span className="info-label">📍 Место:</span>
                  <span className="info-value">{selectedEvent.location}</span>
                </div>
                <div className="info-item">
                  <span className="info-label">👥 Участники:</span>
                  <span className="info-value">
                    {selectedEvent.participants?.length || 0}/{selectedEvent.maxParticipants}
                  </span>
                </div>
              </div>
              
              {selectedEvent.requirements && selectedEvent.requirements.length > 0 && (
                <div className="event-requirements">
                  <h4>Требования:</h4>
                  <ul>
                    {selectedEvent.requirements.map((req, index) => (
                      <li key={index}>{req}</li>
                    ))}
                  </ul>
                </div>
              )}
              
              <div className="event-participants">
                <h4>Участники:</h4>
                <div className="participants-list">
                  {selectedEvent.participants?.map(participantId => (
                    <div key={participantId} className="participant-avatar">
                      <span>{participantId.charAt(0).toUpperCase()}</span>
                    </div>
                  ))}
                </div>
              </div>
            </div>
            
            <div className="event-detail-actions">
              <button 
                className="join-event-btn"
                onClick={() => handleJoinEvent(selectedEvent.id)}
                disabled={selectedEvent.participants?.includes(userId)}
              >
                {selectedEvent.participants?.includes(userId) ? 'Вы участвуете' : 'Присоединиться'}
              </button>
              <button className="share-event-btn">
                Поделиться
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default SeasonalEvents;
20. PersonalMuseum.jsx — Личный музей
import React, { useState, useEffect, useRef } from 'react';
import './PersonalMuseum.css';

const PersonalMuseum = ({ userId, memories, artifacts, onAddMemory, onUpdateMemory }) => {
  const [currentExhibition, setCurrentExhibition] = useState('timeline');
  const [selectedMemory, setSelectedMemory] = useState(null);
  const [isAddingMemory, setIsAddingMemory] = useState(false);
  const [newMemory, setNewMemory] = useState({
    title: '',
    description: '',
    date: '',
    location: '',
    category: 'travel',
    media: [],
    tags: [],
    mood: 'happy'
  });
  const [museumLayout, setMuseumLayout] = useState('gallery');
  const [searchQuery, setSearchQuery] = useState('');
  const [filteredMemories, setFilteredMemories] = useState([]);
  const canvasRef = useRef(null);
  const audioRef = useRef(null);

  useEffect(() => {
    filterMemories();
    initializeMuseumAmbience();
    create3DGallery();
  }, [memories, searchQuery]);

  const filterMemories = () => {
    let filtered = memories;
    
    if (searchQuery) {
      filtered = memories.filter(memory => 
        memory.title.toLowerCase().includes(searchQuery.toLowerCase()) ||
        memory.description.toLowerCase().includes(searchQuery.toLowerCase()) ||
        memory.tags.some(tag => tag.toLowerCase().includes(searchQuery.toLowerCase()))
      );
    }
    
    setFilteredMemories(filtered.sort((a, b) => new Date(b.date) - new Date(a.date)));
  };

  const initializeMuseumAmbience = () => {
    // Инициализация фонового звука музея
    if (audioRef.current) {
      audioRef.current.volume = 0.1;
      audioRef.current.loop = true;
    }
  };

  const create3DGallery = () => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    canvas.width = 800;
    canvas.height = 600;
    
    draw3DGallery(ctx);
  };

  const draw3DGallery = (ctx) => {
    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    
    // Рисуем пол музея
    const gradient = ctx.createLinearGradient(0, 400, 0, 600);
    gradient.addColorStop(0, '#f0f0f0');
    gradient.addColorStop(1, '#d0d0d0');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 400, 800, 200);
    
    // Рисуем стены
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, 800, 400);
    
    // Рисуем рамки для воспоминаний
    filteredMemories.slice(0, 6).forEach((memory, index) => {
      const x = 50 + (index % 3) * 250;
      const y = 50 + Math.floor(index / 3) * 200;
      
      // Тень рамки
      ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
      ctx.fillRect(x + 5, y + 5, 200, 150);
      
      // Рамка
      ctx.fillStyle = '#8B4513';
      ctx.fillRect(x, y, 200, 150);
      
      // Внутренняя область
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(x + 10, y + 10, 180, 130);
      
      // Превью воспоминания
      if (memory.media && memory.media[0]) {
        // Здесь бы отображалось изображение
        ctx.fillStyle = getCategoryColor(memory.category);
        ctx.fillRect(x + 15, y + 15, 170, 100);
      }
      
      // Название воспоминания
      ctx.fillStyle = '#333';
      ctx.font = '12px Arial';
      ctx.textAlign = 'center';
      ctx.fillText(
        memory.title.length > 20 ? memory.title.substring(0, 20) + '...' : memory.title,
        x + 100,
        y + 135
      );
    });
    
    // Добавляем освещение
    const lightGradient = ctx.createRadialGradient(400, 200, 0, 400, 200, 400);
    lightGradient.addColorStop(0, 'rgba(255, 255, 255, 0.1)');
    lightGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
    ctx.fillStyle = lightGradient;
    ctx.fillRect(0, 0, 800, 600);
  };

  const getCategoryColor = (category) => {
    const colors = {
      travel: '#4CAF50',
      food: '#FF9800',
      culture: '#9C27B0',
      nature: '#2196F3',
      people: '#F44336',
      adventure: '#FF5722',
      learning: '#607D8B'
    };
    return colors[category] || '#757575';
  };

  const getCategoryIcon = (category) => {
    const icons = {
      travel: '✈️',
      food: '🍽️',
      culture: '🎭',
      nature: '🌿',
      people: '👥',
      adventure: '🏔️',
      learning: '📚'
    };
    return icons[category] || '📝';
  };

  const getMoodIcon = (mood) => {
    const moods = {
      happy: '😊',
      excited: '🤩',
      peaceful: '😌',
      nostalgic: '🥺',
      adventurous: '😎',
      grateful: '🙏',
      amazed: '😍'
    };
    return moods[mood] || '😊';
  };

  const handleAddMemory = () => {
    if (newMemory.title && newMemory.description && newMemory.date) {
      const memoryData = {
        ...newMemory,
        id: Date.now(),
        createdAt: new Date(),
        views: 0,
        likes: 0
      };
      
      onAddMemory(memoryData);
      setNewMemory({
        title: '',
        description: '',
        date: '',
        location: '',
        category: 'travel',
        media: [],
        tags: [],
        mood: 'happy'
      });
      setIsAddingMemory(false);
    }
  };

  const formatDate = (dateString) => {
    return new Date(dateString).toLocaleDateString('ru-RU', {
      day: 'numeric',
      month: 'long',
      year: 'numeric'
    });
  };

  const renderTimelineView = () => (
    <div className="timeline-view">
      <div className="timeline-line"></div>
      {filteredMemories.map((memory, index) => (
        <div 
          key={memory.id} 
          className={`timeline-item ${index % 2 === 0 ? 'left' : 'right'}`}
          onClick={() => setSelectedMemory(memory)}
        >
          <div className="timeline-marker">
            <span className="timeline-date">{new Date(memory.date).getFullYear()}</span>
          </div>
          
          <div className="timeline-content">
            <div className="memory-preview">
              <div className="memory-header">
                <span className="memory-category-icon">
                  {getCategoryIcon(memory.category)}
                </span>
                <span className="memory-mood">
                  {getMoodIcon(memory.mood)}
                </span>
              </div>
              
              <h4 className="memory-title">{memory.title}</h4>
              <p className="memory-location">📍 {memory.location}</p>
              <p className="memory-date">{formatDate(memory.date)}</p>
              
              <div className="memory-tags">
                {memory.tags.slice(0, 3).map(tag => (
                  <span key={tag} className="memory-tag">#{tag}</span>
                ))}
              </div>
            </div>
          </div>
        </div>
      ))}
    </div>
  );

  const renderGalleryView = () => (
    <div className="gallery-view">
      <canvas ref={canvasRef} className="gallery-canvas" />
      
      <div className="gallery-grid">
        {filteredMemories.map(memory => (
          <div 
            key={memory.id}
            className="gallery-item"
            onClick={() => setSelectedMemory(memory)}
          >
            <div className="gallery-frame">
              <div className="memory-preview-image">
                {memory.media && memory.media[0] ? (
                  <img src={memory.media[0]} alt={memory.title} />
                ) : (
                  <div 
                    className="memory-placeholder"
                    style={{ backgroundColor: getCategoryColor(memory.category) }}
                  >
                    <span className="placeholder-icon">
                      {getCategoryIcon(memory.category)}
                    </span>
                  </div>
                )}
              </div>
              
              <div className="gallery-info">
                <h4>{memory.title}</h4>
                <span className="gallery-date">{formatDate(memory.date)}</span>
              </div>
            </div>
          </div>
        ))}
      </div>
    </div>
  );

  const renderCategoryView = () => {
    const categories = [...new Set(filteredMemories.map(m => m.category))];
    
    return (
      <div className="category-view">
        {categories.map(category => (
          <div key={category} className="category-section">
            <h3 className="category-title">
              <span className="category-icon">{getCategoryIcon(category)}</span>
              {category.charAt(0).toUpperCase() + category.slice(1)}
              <span className="category-count">
                ({filteredMemories.filter(m => m.category === category).length})
              </span>
            </h3>
            
            <div className="category-memories">
              {filteredMemories
                .filter(memory => memory.category === category)
                .map(memory => (
                  <div 
                    key={memory.id}
                    className="category-memory-card"
                    onClick={() => setSelectedMemory(memory)}
                  >
                    <div className="memory-card-header">
                      <h4>{memory.title}</h4>
                      <span className="memory-mood">{getMoodIcon(memory.mood)}</span>
                    </div>
                    
                    <p className="memory-card-description">
                      {memory.description.length > 100 
                        ? memory.description.substring(0, 100) + '...'
                        : memory.description
                      }
                    </p>
                    
                    <div className="memory-card-footer">
                      <span className="memory-location">📍 {memory.location}</span>
                      <span className="memory-date">{formatDate(memory.date)}</span>
                    </div>
                  </div>
                ))}
            </div>
          </div>
        ))}
      </div>
    );
  };

  return (
    <div className="personal-museum">
      <audio ref={audioRef} preload="auto">
        <source src="/sounds/museum-ambience.mp3" type="audio/mpeg" />
      </audio>
      
      <div className="museum-header">
        <div className="museum-title">
          <h2>
            <span className="museum-icon">🏛️</span>
            Личный Музей Воспоминаний
          </h2>
          <p className="museum-subtitle">
            Коллекция ваших самых ценных моментов
          </p>
        </div>
        
        <div className="museum-controls">
          <div className="search-bar">
            <input
              type="text"
              placeholder="Поиск воспоминаний..."
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
              className="search-input"
            />
            <span className="search-icon">🔍</span>
          </div>
          
          <button 
            className="add-memory-btn"
            onClick={() => setIsAddingMemory(true)}
          >
            <span>+</span> Добавить воспоминание
          </button>
        </div>
      </div>

      <div className="museum-navigation">
        <button 
          className={`nav-btn ${currentExhibition === 'timeline' ? 'active' : ''}`}
          onClick={() => setCurrentExhibition('timeline')}
        >
          <span className="nav-icon">📅</span>
          Временная линия
        </button>
        
        <button 
          className={`nav-btn ${currentExhibition === 'gallery' ? 'active' : ''}`}
          onClick={() => setCurrentExhibition('gallery')}
        >
          <span className="nav-icon">🖼️</span>
          Галерея
        </button>
        
        <button 
          className={`nav-btn ${currentExhibition === 'categories' ? 'active' : ''}`}
          onClick={() => setCurrentExhibition('categories')}
        >
          <span className="nav-icon">📂</span>
          По категориям
        </button>
      </div>

      <div className="museum-content">
        {currentExhibition === 'timeline' && renderTimelineView()}
        {currentExhibition === 'gallery' && renderGalleryView()}
        {currentExhibition === 'categories' && renderCategoryView()}
      </div>

      {/* Модальное окно добавления воспоминания */}
      {isAddingMemory && (
        <div className="add-memory-modal">
          <div className="add-memory-content">

            <h2>Новое воспоминание</h2>
            
            <div className="memory-form">
              <input
                type="text"
                placeholder="Название воспоминания"
                value={newMemory.title}
                onChange={(e) => setNewMemory({...newMemory, title: e.target.value})}
                className="memory-input"
              />
              
              <textarea
                placeholder="Описание воспоминания"
                value={newMemory.description}
                onChange={(e) => setNewMemory({...newMemory, description: e.target.value})}
                className="memory-textarea"
                rows="4"
              />
              
              <div className="form-row">
                <input
                  type="date"
                  value={newMemory.date}
                  onChange={(e) => setNewMemory({...newMemory, date: e.target.value})}
                  className="memory-input"
                />
                
                <input
                  type="text"
                  placeholder="Место"
                  value={newMemory.location}
                  onChange={(e) => setNewMemory({...newMemory, location: e.target.value})}
                  className="memory-input"
                />
              </div>
              
              <div className="form-row">
                <select
                  value={newMemory.category}
                  onChange={(e) => setNewMemory({...newMemory, category: e.target.value})}
                  className="memory-select"
                >
                  <option value="travel">Путешествия</option>
                  <option value="food">Еда</option>
                  <option value="culture">Культура</option>
                  <option value="nature">Природа</option>
                  <option value="people">Люди</option>
                  <option value="adventure">Приключения</option>
                  <option value="learning">Обучение</option>
                </select>
                
                <select
                  value={newMemory.mood}
                  onChange={(e) => setNewMemory({...newMemory, mood: e.target.value})}
                  className="memory-select"
                >
                  <option value="happy">Счастливое</option>
                  <option value="excited">Восторженное</option>
                  <option value="peaceful">Спокойное</option>
                  <option value="nostalgic">Ностальгическое</option>
                  <option value="adventurous">Авантюрное</option>
                  <option value="grateful">Благодарное</option>
                  <option value="amazed">Удивительное</option>
                </select>
              </div>
              
              <div className="tags-input">
                <input
                  type="text"
                  placeholder="Теги (через запятую)"
                  onChange={(e) => {
                    const tags = e.target.value.split(',').map(tag => tag.trim()).filter(tag => tag);
                    setNewMemory({...newMemory, tags});
                  }}
                  className="memory-input"
                />
              </div>
              
              <div className="media-upload">
                <label className="upload-label">
                  <span className="upload-icon">📎</span>
                  Добавить фото/видео
                  <input
                    type="file"
                    multiple
                    accept="image/*,video/*"
                    onChange={(e) => {
                      const files = Array.from(e.target.files);
                      // Здесь бы была логика загрузки файлов
                      setNewMemory({...newMemory, media: files.map(f => f.name)});
                    }}
                    className="file-input"
                  />
                </label>
              </div>
              
              <div className="form-actions">
                <button onClick={handleAddMemory} className="save-memory-btn">
                  Сохранить воспоминание
                </button>
                <button 
                  onClick={() => setIsAddingMemory(false)}
                  className="cancel-btn"
                >
                  Отмена
                </button>
              </div>
            </div>
          </div>
        </div>
      )}

      {/* Модальное окно детального просмотра воспоминания */}
      {selectedMemory && (
        <div className="memory-detail-modal">
          <div className="memory-detail-content">
            <button 
              className="close-modal"
              onClick={() => setSelectedMemory(null)}
            >
              ×
            </button>
            
            <div className="memory-detail-header">
              <div className="memory-title-section">
                <h2>{selectedMemory.title}</h2>
                <div className="memory-meta">
                  <span className="memory-category">
                    {getCategoryIcon(selectedMemory.category)} {selectedMemory.category}
                  </span>
                  <span className="memory-mood">
                    {getMoodIcon(selectedMemory.mood)}
                  </span>
                </div>
              </div>
              
              <div className="memory-stats">
                <span className="stat">👁️ {selectedMemory.views || 0}</span>
                <span className="stat">❤️ {selectedMemory.likes || 0}</span>
              </div>
            </div>
            
            <div className="memory-detail-body">
              <div className="memory-info">
                <div className="info-item">
                  <span className="info-label">📅 Дата:</span>
                  <span className="info-value">{formatDate(selectedMemory.date)}</span>
                </div>
                <div className="info-item">
                  <span className="info-label">📍 Место:</span>
                  <span className="info-value">{selectedMemory.location}</span>
                </div>
              </div>
              
              <div className="memory-description">
                <p>{selectedMemory.description}</p>
              </div>
              
              {selectedMemory.media && selectedMemory.media.length > 0 && (
                <div className="memory-media">
                  <h4>Медиа:</h4>
                  <div className="media-gallery">
                    {selectedMemory.media.map((media, index) => (
                      <div key={index} className="media-item">
                        {media.endsWith('.mp4') || media.endsWith('.mov') ? (
                          <video controls className="media-video">
                            <source src={media} type="video/mp4" />
                          </video>
                        ) : (
                          <img src={media} alt={`Memory ${index + 1}`} className="media-image" />
                        )}
                      </div>
                    ))}
                  </div>
                </div>
              )}
              
              {selectedMemory.tags && selectedMemory.tags.length > 0 && (
                <div className="memory-tags-section">
                  <h4>Теги:</h4>
                  <div className="tags-list">
                    {selectedMemory.tags.map(tag => (
                      <span key={tag} className="memory-tag">#{tag}</span>
                    ))}
                  </div>
                </div>
              )}
            </div>
            
            <div className="memory-detail-actions">
              <button className="edit-memory-btn">
                ✏️ Редактировать
              </button>
              <button className="share-memory-btn">
                📤 Поделиться
              </button>
              <button className="like-memory-btn">
                ❤️ Нравится
              </button>
            </div>
          </div>
        </div>
      )}

      <div className="museum-footer">
        <div className="museum-stats">
          <div className="stat-item">
            <span className="stat-number">{memories.length}</span>
            <span className="stat-label">Воспоминаний</span>
          </div>
          <div className="stat-item">
            <span className="stat-number">
              {[...new Set(memories.map(m => m.location))].length}
            </span>
            <span className="stat-label">Мест</span>
          </div>
          <div className="stat-item">
            <span className="stat-number">
              {memories.reduce((sum, m) => sum + (m.media?.length || 0), 0)}
            </span>
            <span className="stat-label">Медиафайлов</span>
          </div>
          <div className="stat-item">
            <span className="stat-number">
              {Math.round((Date.now() - new Date(Math.min(...memories.map(m => new Date(m.date))))) / (1000 * 60 * 60 * 24))}
            </span>
            <span className="stat-label">Дней истории</span>
          </div>
        </div>
      </div>
    </div>
  );
};

export default PersonalMuseum;
Готово! 🎉
Все компоненты для «Центра влияния» готовы:

✅ DreamBoard.jsx — Доска мечты с созвездиями целей
✅ LegacyBuilder.jsx — Строитель наследия с сетью влияния
✅ SeasonalEvents.jsx — Сезонные события с анимированными эффектами
✅ PersonalMuseum.jsx — Личный музей воспоминаний с 3D-галереей

Что дальше? Теперь нужно создать CSS-файлы для стилизации всех этих компонентов. Хотите, чтобы я написал стили для каждого компонента? Это будет включать в себя:

DreamBoard.css
LegacyBuilder.css
SeasonalEvents.css
PersonalMuseum.css
Или есть какие-то конкретные компоненты, которые нужно доработать?

Я так понимаю, что стили для всего этого были твоим предложением, и я так понял, что ты стили не добавлял. Посмотри сам, пожалуйста: Архитектура компонентов 1. InfluenceHub.jsx — главный контейнер // Основной компонент с анимированным фоном и орбитальной навигацией - Фон с системой частиц - Плавающие навигационные сферы - Динамическое переключение тем - Плавные переходы между разделами 2. PersonalGalaxy.jsx — личная вселенная пользователя // 3D-визуализация достижений в виде созвездий - Карта созвездий с достижениями - Анимированное формирование звёзд при получении новых достижений - Интерактивная планета для каждой категории активности - Эффекты масштабирования при наведении 3. InfluenceMetrics.jsx — метрики влияния // Живые графики и статистика - Анимированные круговые индикаторы выполнения - Волновая форма активности - Пульсирующие индикаторы для трендов - Морфинг-графики при изменении периода 4. AchievementOrbit.jsx — Орбита достижений // Вращающиеся достижения вокруг аватара - Система орбитальной анимации - Светящиеся значки с эффектами частиц - Анимация разблокировки - Визуализация цепочек достижений 5. CommunityPulse.jsx — пульс сообщества // Живая визуализация активности сообщества - Анимация активности в виде сердцебиения - Поток сообщений между пользователями - Потоки активности в реальном времени - Совместное празднование достижений 6. TrendNebula.jsx — Туманность трендов // Облако трендовых направлений - Визуализация трансформирующегося облака - Изменение цвета в зависимости от популярности - Интерактивное изучение трендов - Прогностические индикаторы трендов 7. MotivationEngine.jsx — двигатель мотивации // Персонализированные вызовы и цели - Динамическая генерация вызовов - Анимация ракеты прогресса - Индикатор топлива для мотивации - Эффекты усиления при достижениях 8. InfluenceLeaderboard.jsx — Доска лидеров // Подиум с голографическими эффектами — 3D-подиум с эффектами частиц — Голограммы аватаров — Плавные переходы между рангами — Эффекты короны и ауры для лидеров 🎨 ВИЗУАЛЬНЫЕ ЭФФЕКТЫ И АНИМАЦИЯ 9. ParticleSystem.jsx — система частиц // Фоновые эффекты и реакции на действия — Плавающие частицы — Реакции на взаимодействие — Взрывы достижений — Фоновая анимация 10. HolographicUI.jsx — голографический интерфейс // Футуристические элементы пользовательского интерфейса — светящиеся границы — голографические кнопки — неоновые текстовые эффекты — прозрачные панели с размытием 🎮 Геймификация 11. QuestSystem.jsx — система квестов // Динамические задания и челленджи — алгоритм генерации квестов - Отслеживание прогресса - Анимация получения наград - Визуализация цепочки заданий 12. PowerUpCenter.jsx — Центр усилений // Временные усиления и способности - Инвентарь усилений - Эффекты активации - Таймеры восстановления - Система комбинаций 📊 АНАЛИТИКА И СТАТИСТИКА 13. InsightCrystal.jsx — Кристалл инсайтов // Интерактивная аналитика - Визуализация данных в виде кристалла - Отображение фасетной информации - Взаимодействие с ротацией - Эффекты углубления данных 14. TravelDNA.jsx — ДНК путешественника // Уникальный профиль активности — Визуализация спирали — Отображение личностных качеств — Временная шкала эволюции — Подбор совместимости 🌟 СОЦИАЛЬНОЕ ВЗАИМОДЕЙСТВИЕ 15. InfluenceNetwork.jsx — Сеть влияния // Визуализация связей и влияния — Сетевой граф с анимацией — Визуализация потока влияния — Индикаторы силы связи — Основные моменты совместного проекта 16. MentorshipPortal.jsx — портал наставничества // Система наставничества и обучения — связи между наставником и учеником — визуализация передачи знаний — развитие навыков — вознаграждение за обмен знаниями 🎯 Мотивационные механизмы 17. DreamBoard.jsx — Доска мечты // Визуализация целей и мечтаний — Доска визуализации с интерактивными элементами — Отслеживание реализации целей — Празднование достижения мечты — Галерея вдохновения 18. LegacyBuilder.jsx — Строитель наследия // Долгосрочное влияние и вклад — График наследия — Измерение влияния — Визуализация вклада — Прогноз на будущее 🔮 ДОПОЛНИТЕЛЬНЫЕ ФУНКЦИИ 19. SeasonalEvents.jsx — Сезонные события // Временные события и празднования — Интеграция с календарем событий — Сезонные темы — Ограниченные по времени испытания — Праздники сообщества 20. PersonalMuseum.jsx — Личный музей // Коллекция воспоминаний и достижений — Пространство 3D-галереи — Артефакты памяти — Сохранение истории — Интерактивные выставки
Стоп, давай поступим так: ты мне написал все коды основных файлов, но, думаю, стили ты решил сделать в конце, поэтому нужны только стили, но, похоже, для всех файлов
Точно! Вы правы — я написал все JSX-компоненты, но забыл про стили. Давайте создадим CSS-файлы для всех 20 компонентов «Центра влияния». Начинаю:

1. Файл InfluenceHub.css
.influence-hub {
  min-height: 100vh;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  position: relative;
  overflow: hidden;
}

.particle-background {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 1;
}

.hub-container {
  position: relative;
  z-index: 2;
  padding: 2rem;
  max-width: 1400px;
  margin: 0 auto;
}

.hub-header {
  text-align: center;
  margin-bottom: 3rem;
}

.hub-title {
  font-size: 3rem;
  color: #ffffff;
  text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
  margin-bottom: 1rem;
  animation: titleGlow 2s ease-in-out infinite alternate;
}

@keyframes titleGlow {
  from { text-shadow: 0 0 20px rgba(255, 255, 255, 0.5); }
  to { text-shadow: 0 0 30px rgba(255, 255, 255, 0.8); }
}

.hub-subtitle {
  font-size: 1.2rem;
  color: rgba(255, 255, 255, 0.8);
  margin-bottom: 2rem;
}

.orbital-navigation {
  position: relative;
  width: 600px;
  height: 600px;
  margin: 0 auto;
}

.nav-sphere {
  position: absolute;
  width: 80px;
  height: 80px;
  border-radius: 50%;
  background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: all 0.3s ease;
  animation: orbit 20s linear infinite;
  box-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
}

.nav-sphere:hover {
  transform: scale(1.2);
  box-shadow: 0 0 30px rgba(255, 255, 255, 0.6);
}

.nav-sphere.active {
  background: linear-gradient(45deg, #ffd93d, #ff6b6b);
  transform: scale(1.3);
}

@keyframes orbit {
  from { transform: rotate(0deg) translateX(250px) rotate(0deg); }
  to { transform: rotate(360deg) translateX(250px) rotate(-360deg); }
}

.nav-icon {
  font-size: 1.5rem;
  color: white;
}

.nav-label {
  position: absolute;
  bottom: -30px;
  left: 50%;
  transform: translateX(-50%);
  color: white;
  font-size: 0.9rem;
  white-space: nowrap;
}

.content-area {
  margin-top: 4rem;
  background: rgba(255, 255, 255, 0.1);
  backdrop-filter: blur(10px);
  border-radius: 20px;
  padding: 2rem;
  border: 1px solid rgba(255, 255, 255, 0.2);
}

.theme-switcher {
  position: fixed;
  top: 2rem;
  right: 2rem;
  z-index: 1000;
}

.theme-btn {
  background: rgba(255, 255, 255, 0.2);
  border: none;
  border-radius: 50%;
  width: 50px;
  height: 50px;
  color: white;
  cursor: pointer;
  backdrop-filter: blur(10px);
  transition: all 0.3s ease;
}

.theme-btn:hover {
  background: rgba(255, 255, 255, 0.3);
  transform: scale(1.1);
}
2. PersonalGalaxy.css
.personal-galaxy {
  position: relative;
  width: 100%;
  height: 100vh;
  background: radial-gradient(ellipse at center, #1a1a2e 0%, #16213e 50%, #0f0f23 100%);
  overflow: hidden;
}

.galaxy-canvas {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}

.constellation-map {
  position: relative;
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
}

.achievement-star {
  position: absolute;
  width: 40px;
  height: 40px;
  cursor: pointer;
  transition: all 0.3s ease;
  animation: starTwinkle 3s ease-in-out infinite;
}

.achievement-star:hover {
  transform: scale(1.5);
  filter: brightness(1.5);
}

@keyframes starTwinkle {
  0%, 100% { opacity: 0.7; transform: scale(1); }
  50% { opacity: 1; transform: scale(1.1); }
}

.star-core {
  width: 100%;
  height: 100%;
  border-radius: 50%;
  background: radial-gradient(circle, #ffd700 0%, #ff8c00 100%);
  box-shadow: 0 0 20px #ffd700;
  position: relative;
}

.star-rays {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 60px;
  height: 60px;
}

.star-ray {
  position: absolute;
  width: 2px;
  height: 15px;
  background: linear-gradient(to top, transparent, #ffd700);
  top: 50%;
  left: 50%;
  transform-origin: bottom center;
}

.star-ray:nth-child(1) { transform: translate(-50%, -100%) rotate(0deg); }
.star-ray:nth-child(2) { transform: translate(-50%, -100%) rotate(45deg); }
.star-ray:nth-child(3) { transform: translate(-50%, -100%) rotate(90deg); }
.star-ray:nth-child(4) { transform: translate(-50%, -100%) rotate(135deg); }
.star-ray:nth-child(5) { transform: translate(-50%, -100%) rotate(180deg); }
.star-ray:nth-child(6) { transform: translate(-50%, -100%) rotate(225deg); }
.star-ray:nth-child(7) { transform: translate(-50%, -100%) rotate(270deg); }
.star-ray:nth-child(8) { transform: translate(-50%, -100%) rotate(315deg); }

.constellation-line {
  position: absolute;
  height: 2px;
  background: linear-gradient(90deg, transparent, #4ecdc4, transparent);
  transform-origin: left center;
  animation: lineGlow 2s ease-in-out infinite alternate;
}

@keyframes lineGlow {
  from { box-shadow: 0 0 5px #4ecdc4; }
  to { box-shadow: 0 0 15px #4ecdc4; }
}

.activity-planet {
  position: absolute;
  border-radius: 50%;
  cursor: pointer;
  transition: all 0.5s ease;
  animation: planetRotate 30s linear infinite;
}

.activity-planet:hover {
  transform: scale(1.2);
  filter: brightness(1.3);
}

@keyframes planetRotate {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}

.planet-travel {
  width: 80px;
  height: 80px;
  background: radial-gradient(circle at 30% 30%, #4ecdc4, #2c5aa0);
  box-shadow: 0 0 30px #4ecdc4;
}

.planet-social {
  width: 60px;
  height: 60px;
  background: radial-gradient(circle at 30% 30%, #ff6b6b, #c44569);
  box-shadow: 0 0 25px #ff6b6b;
}

.planet-learning {
  width: 70px;
  height: 70px;
  background: radial-gradient(circle at 30% 30%, #ffd93d, #f39c12);
  box-shadow: 0 0 28px #ffd93d;
}

.galaxy-info-panel {
  position: absolute;
  top: 2rem;
  left: 2rem;
  background: rgba(0, 0, 0, 0.7);
  backdrop-filter: blur(10px);
  border-radius: 15px;
  padding: 1.5rem;
  color: white;
  border: 1px solid rgba(255, 255, 255, 0.1);
}

.galaxy-stats {
  display: flex;
  flex-direction: column;
  gap: 1rem;
}

.stat-item {
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.stat-icon {
  font-size: 1.2rem;
}

.stat-value {
  font-weight: bold;
  color: #ffd700;
}

.achievement-detail-modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.8);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
}

.achievement-detail-content {
  background: linear-gradient(135deg, #1a1a2e, #16213e);
  border-radius: 20px;
  padding: 2rem;
  max-width: 500px;
  width: 90%;
  color: white;
  border: 1px solid rgba(255, 255, 255, 0.2);
}

.achievement-header {
  text-align: center;
  margin-bottom: 1.5rem;
}

.achievement-icon-large {
  font-size: 3rem;
  margin-bottom: 1rem;
}

.achievement-title {
  font-size: 1.5rem;
  margin-bottom: 0.5rem;
  color: #ffd700;
}

.achievement-description {
  color: rgba(255, 255, 255, 0.8);
  line-height: 1.6;
  margin-bottom: 1.5rem;
}

.achievement-progress {
  background: rgba(255, 255, 255, 0.1);
  border-radius: 10px;
  height: 20px;
  overflow: hidden;
  margin-bottom: 1rem;
}

.progress-fill {
  height: 100%;
  background: linear-gradient(90deg, #4ecdc4, #ffd700);
  transition: width 0.5s ease;
}

.close-modal {
  position: absolute;
  top: 1rem;
  right: 1rem;
  background: none;
  border: none;
  color: white;
  font-size: 1.5rem;
  cursor: pointer;
  opacity: 0.7;
  transition: opacity 0.3s ease;
}

.close-modal:hover {
  opacity: 1;
}
3. Влияние Metrics.css
.influence-metrics {
  padding: 2rem;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  border-radius: 20px;
  color: white;
  position: relative;
  overflow: hidden;
}

.metrics-header {
  text-align: center;
  margin-bottom: 2rem;
}

.metrics-title {
  font-size: 2rem;
  margin-bottom: 0.5rem;
  text-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
}

.metrics-subtitle {
  opacity: 0.8;
  font-size: 1rem;
}

.metrics-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: 2rem;
  margin-bottom: 3rem;
}

.metric-card {
  background: rgba(255, 255, 255, 0.1);
  backdrop-filter: blur(10px);
  border-radius: 15px;
  padding: 1.5rem;
  border: 1px solid rgba(255, 255, 255, 0.2);
  transition: all 0.3s ease;
}

.metric-card:hover {
  transform: translateY(-5px);
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
}

.metric-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 1rem;
}

.metric-icon {
  font-size: 1.5rem;
}

.metric-trend {
  font-size: 0.9rem;
  padding: 0.2rem 0.5rem;
  border-radius: 10px;
  background: rgba(76, 175, 80, 0.2);
  color: #4CAF50;
}

.metric-trend.down {
  background: rgba(244, 67, 54, 0.2);
  color: #F44336;
}

.metric-value {
  font-size: 2.5rem;
  font-weight: bold;
  margin-bottom: 0.5rem;
  animation: countUp 1s ease-out;
}

@keyframes countUp {
  from { opacity: 0; transform: translateY(20px); }
  to { opacity: 1; transform: translateY(0); }
}

.metric-label {
  opacity: 0.8;
  font-size: 0.9rem;
}

.circular-progress {
  position: relative;
  width: 120px;
  height: 120px;
  margin: 0 auto 1rem;
}

.progress-ring {
  transform: rotate(-90deg);
}

.progress-ring-circle {
  transition: stroke-dasharray 0.5s ease;
  stroke: #4ecdc4;
  stroke-linecap: round;
}

.progress-ring-bg {
  stroke: rgba(255, 255, 255, 0.1);
}

.progress-text {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 1.2rem;
  font-weight: bold;
}

.wave-chart {
  height: 100px;
  margin: 1rem 0;
  position: relative;
  overflow: hidden;
  border-radius: 10px;
  background: rgba(255, 255, 255, 0.05);
}

.wave-path {
  position: absolute;
  bottom: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: linear-gradient(180deg, rgba(78, 205, 196, 0.3) 0%, rgba(78, 205, 196, 0.1) 100%);
  animation: waveFlow 3s ease-in-out infinite;
}

@keyframes waveFlow {
  0%, 100% { transform: translateX(0); }
  50% { transform: translateX(-10px); }
}

.pulse-indicator {
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background: #4ecdc4;
  animation: pulse 2s ease-in-out infinite;
  margin: 0 auto;
}

@keyframes pulse {
  0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(78, 205, 196, 0.7); }
  70% { transform: scale(1.1); box-shadow: 0 0 0 10px rgba(78, 205, 196, 0); }
  100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(78, 205, 196, 0); }
}

.morphing-chart {
  height: 200px;
  position: relative;
  margin: 1rem 0;
}

.chart-bar {
  position: absolute;
  bottom: 0;
  background: linear-gradient(180deg, #ffd93d, #ff6b6b);
  border-radius: 5px 5px 0 0;
  transition: all 0.5s ease;
  animation: barGrow 1s ease-out;
}

@keyframes barGrow {
  from { height: 0; }
  to { height: var(--bar-height); }
}

.chart-controls {
  display: flex;
  justify-content: center;
  gap: 1rem;
  margin-top: 2rem;
}

.period-btn {
  background: rgba(255, 255, 255, 0.1);
  border: 1px solid rgba(255, 255, 255, 0.2);
  color: white;
  padding: 0.5rem 1rem;
  border-radius: 20px;
  cursor: pointer;
  transition: all 0.3s ease;
}

.period-btn:hover,
.period-btn.active {
  background: rgba(255, 255, 255, 0.2);
  transform: translateY(-2px);
}

.metrics-summary {
  background: rgba(0, 0, 0, 0.2);
  border-radius: 15px;
  padding: 1.5rem;
  margin-top: 2rem;
}

.summary-title {
  font-size: 1.2rem;
  margin-bottom: 1rem;
  text-align: center;
}

.summary-stats {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
  gap: 1rem;
}

.summary-stat {
  text-align: center;
}

.summary-value {
  font-size: 1.5rem;
  font-weight: bold;
  color: #ffd93d;
}

.summary-label {
  font-size: 0.9rem;
  opacity: 0.8;
}
4. Файл AchievementOrbit.css
.achievement-orbit {
  position: relative;
  width: 400px;
  height: 400px;
  margin: 2rem auto;
}

.orbit-center {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 100px;
  height: 100px;
  border-radius: 50%;
  background: linear-gradient(45deg, #667eea, #764ba2);
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 0 30px rgba(102, 126, 234, 0.5);
  z-index: 10;
}

.user-avatar {
  width: 80px;
  height: 80px;
  border-radius: 50%;
  background: linear-gradient(45deg, #ffd93d, #ff6b6b);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 2rem;
  color: white;
  font-weight: bold;
}

.orbit-ring {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  border: 2px solid rgba(255, 255, 255, 0.1);
  border-radius: 50%;
  animation: ringRotate 20s linear infinite;
}

.orbit-ring.ring-1 {
  width: 200px;
  height: 200px;
  animation-duration: 15s;
}

.orbit-ring.ring-2 {
  width: 280px;
  height: 280px;
  animation-duration: 25s;
  animation-direction: reverse;
}

.orbit-ring.ring-3 {
  width: 360px;
  height: 360px;
  animation-duration: 35s;
}

@keyframes ringRotate {
  from { transform: translate(-50%, -50%) rotate(0deg); }
  to { transform: translate(-50%, -50%) rotate(360deg); }
}

.achievement-badge {
  position: absolute;
  width: 60px;
  height: 60px;
  border-radius: 50%;
  cursor: pointer;
  transition: all 0.3s ease;
  animation: badgeOrbit 20s linear infinite;
  z-index: 5;
}

.achievement-badge:hover {
  transform: scale(1.3);
  z-index: 15;
}

.achievement-badge.ring-1 {
  animation-duration: 15s;
}

.achievement-badge.ring-2 {
  animation-duration: 25s;
  animation-direction: reverse;
}

.achievement-badge.ring-3 {
  animation-duration: 35s;
}

@keyframes badgeOrbit {
  from { transform: rotate(0deg) translateX(var(--orbit-radius)) rotate(0deg); }
  to { transform: rotate(360deg) translateX(var(--orbit-radius)) rotate(-360deg); }
}

.badge-glow {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  border-radius: 50%;
  background: radial-gradient(circle, rgba(255, 215, 0, 0.3), transparent);
  animation: glowPulse 2s ease-in-out infinite alternate;
}

@keyframes glowPulse {
  from { transform: scale(1); opacity: 0.5; }
  to { transform: scale(1.2); opacity: 0.8; }
}

.badge-content {
  position: relative;
  width: 100%;
  height: 100%;
  border-radius: 50%;
  background: linear-gradient(45deg, #4ecdc4, #44a08d);
  display: flex;
  align-items: center;
  justify-content: center;
  border: 3px solid #ffd700;
  box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
}

.badge-icon {
  font-size: 1.5rem;
  color: white;
}

.badge-particles {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 80px;
  height: 80px;
  pointer-events: none;
}

.particle {
  position: absolute;
  width: 4px;
  height: 4px;
  background: #ffd700;
  border-radius: 50%;
  animation: particleFloat 3s ease-in-out infinite;
}

@keyframes particleFloat {
  0% { transform: translate(0, 0) scale(0); opacity: 0; }
  50% { opacity: 1; }
  100% { transform: translate(var(--particle-x), var(--particle-y)) scale(1); opacity: 0; }
}

.unlock-animation {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 100px;
  height: 100px;
  border-radius: 50%;
  background: radial-gradient(circle, rgba(255, 215, 0, 0.8), transparent);
  animation: unlockBurst 1s ease-out;
  pointer-events: none;
}

@keyframes unlockBurst {
  0% { transform: translate(-50%, -50%) scale(0); opacity: 1; }
  100% { transform: translate(-50%, -50%) scale(3); opacity: 0; }
}

.achievement-chain {
  position: absolute;
  height: 2px;
  background: linear-gradient(90deg, transparent, #ffd700, transparent);
  transform-origin: left center;
  animation: chainGlow 2s ease-in-out infinite alternate;
}

@keyframes chainGlow {
  from { box-shadow: 0 0 5px #ffd700; }
  to { box-shadow: 0 0 15px #ffd700; }
}

.orbit-controls {
  position: absolute;
  bottom: -60px;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  gap: 1rem;
}

.orbit-btn {
  background: rgba(255, 255, 255, 0.1);
  border: 1px solid rgba(255, 255, 255, 0.2);
  color: white;
  padding: 0.5rem 1rem;
  border-radius: 20px;
  cursor: pointer;
  transition: all 0.3s ease;
  backdrop-filter: blur(10px);
}

.orbit-btn:hover {
  background: rgba(255, 255, 255, 0.2);
  transform: translateY(-2px);
}

.achievement-tooltip {
  position: absolute;
  bottom: 120%;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(0, 0, 0, 0.9);
  color: white;
  padding: 0.5rem 1rem;
  border-radius: 10px;
  font-size: 0.9rem;
  white-space: nowrap;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.3s ease;
  z-index: 20;
}

.achievement-badge:hover .achievement-tooltip {
  opacity: 1;
}

.tooltip-arrow {
  position: absolute;
  top: 100%;
  left: 50%;
  transform: translateX(-50%);
  width: 0;
  height: 0;
  border-left: 5px solid transparent;
  border-right: 5px solid transparent;
  border-top: 5px solid rgba(0, 0, 0, 0.9);
}
5. CommunityPulse.css
.community-pulse {
  padding: 2rem;
  background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
  border-radius: 20px;
  color: white;
  position: relative;
  overflow: hidden;
}

.pulse-header {
  text-align: center;
  margin-bottom: 2rem;
}

.pulse-title {
  font-size: 2rem;
  margin-bottom: 0.5rem;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 0.5rem;
}

.heartbeat-icon {
  animation: heartbeat 1.5s ease-in-out infinite;
  color: #e74c3c;
}

@keyframes heartbeat {
  0% { transform: scale(1); }
  14% { transform: scale(1.3); }
  28% { transform: scale(1); }
  42% { transform: scale(1.3); }
  70% { transform: scale(1); }
}

.pulse-subtitle {
  opacity: 0.8;
  font-size: 1rem;
}

.activity-stream {
  height: 300px;
  overflow-y: auto;
  margin-bottom: 2rem;
  background: rgba(0, 0, 0, 0.2);
  border-radius: 15px;
  padding: 1rem;
}

.activity-item {
  display: flex;
  align-items: center;
  gap: 1rem;
  padding: 0.75rem;
  margin-bottom: 0.5rem;
  background: rgba(255, 255, 255, 0.05);
  border-radius: 10px;
  transition: all 0.3s ease;
  animation: slideIn 0.5s ease-out;
}

.activity-item:hover {
  background: rgba(255, 255, 255, 0.1);
  transform: translateX(5px);
}

@keyframes slideIn {
  from { opacity: 0; transform: translateX(-20px); }
  to { opacity: 1; transform: translateX(0); }
}

.activity-avatar {
  width: 40px;
  height: 40px;
  border-radius: 50%;
  background: linear-gradient(45deg, #3498db, #2980b9);
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: bold;
  flex-shrink: 0;
}

.activity-content {
  flex: 1;
}

.activity-text {
  margin-bottom: 0.25rem;
  line-height: 1.4;
}

.activity-time {
  font-size: 0.8rem;
  opacity: 0.6;
}

.activity-type-icon {
  font-size: 1.2rem;
  margin-right: 0.5rem;
}

.connection-network {
  position: relative;
  height: 200px;
  background: rgba(0, 0, 0, 0.2);
  border-radius: 15px;
  margin-bottom: 2rem;
  overflow: hidden;
}

.network-canvas {
  width: 100%;
  height: 100%;
}

.connection-node {
  position: absolute;
  width: 30px;
  height: 30px;
  border-radius: 50%;
  background: linear-gradient(45deg, #4ecdc4, #44a08d);
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: all 0.3s ease;
  animation: nodeFloat 4s ease-in-out infinite;
}

.connection-node:hover {
  transform: scale(1.3);
  box-shadow: 0 0 20px rgba(78, 205, 196, 0.6);
}

@keyframes nodeFloat {
  0%, 100% { transform: translateY(0px); }
  50% { transform: translateY(-10px); }
}

.connection-line {
  position: absolute;
  height: 2px;
  background: linear-gradient(90deg, transparent, rgba(78, 205, 196, 0.6), transparent);
  transform-origin: left center;
  animation: connectionFlow 3s ease-in-out infinite;
}

@keyframes connectionFlow {
  0% { opacity: 0.3; }
  50% { opacity: 1; }
  100% { opacity: 0.3; }
}

.pulse-metrics {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 1.5rem;
  margin-bottom: 2rem;
}

.pulse-metric {
  background: rgba(255, 255, 255, 0.05);
  border-radius: 15px;
  padding: 1.5rem;
  text-align: center;
  border: 1px solid rgba(255, 255, 255, 0.1);
}

.metric-icon {
  font-size: 2rem;
  margin-bottom: 0.5rem;
  display: block;
}

.metric-value {
  font-size: 2rem;
  font-weight: bold;
  color: #4ecdc4;
  margin-bottom: 0.25rem;
}

.metric-label {
  opacity: 0.8;
  font-size: 0.9rem;
}

.collaborative-achievements {
  background: rgba(0, 0, 0, 0.2);
  border-radius: 15px;
  padding: 1.5rem;
}

.achievements-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 1rem;
}

.achievements-title {
  font-size: 1.2rem;
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.view-all-btn {
  background: rgba(78, 205, 196, 0.2);
  border: 1px solid #4ecdc4;
  color: #4ecdc4;
  padding: 0.5rem 1rem;
  border-radius: 20px;
  cursor: pointer;
  transition: all 0.3s ease;
  font-size: 0.9rem;
}

.view-all-btn:hover {
  background: rgba(78, 205, 196, 0.3);
  transform: translateY(-2px);
}

.achievement-list {
  display: flex;
  flex-direction: column;
  gap: 1rem;
}

.achievement-item {
  display: flex;
  align-items: center;
  gap: 1rem;
  padding: 1rem;
  background: rgba(255, 255, 255, 0.05);
  border-radius: 10px;
  transition: all 0.3s ease;
}

.achievement-item:hover {
  background: rgba(255, 255, 255, 0.1);
  transform: translateY(-2px);
}

.achievement-icon {
  font-size: 1.5rem;
  width: 40px;
  height: 40px;
  border-radius: 50%;
  background: linear-gradient(45deg, #ffd93d, #ff6b6b);
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
}

.achievement-info {
  flex: 1;
}

.achievement-name {
  font-weight: bold;
  margin-bottom: 0.25rem;
}

.achievement-description {
  font-size: 0.9rem;
  opacity: 0.8;
  line-height: 1.4;
}

.achievement-participants {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  margin-top: 0.5rem;
}

.participant-avatar {
  width: 24px;
  height: 24px;
  border-radius: 50%;
  background: linear-gradient(45deg, #3498db, #2980b9);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 0.7rem;
  font-weight: bold;
  border: 2px solid rgba(255, 255, 255, 0.2);
}

.participants-count {
  font-size: 0.8rem;
  opacity: 0.7;
  margin-left: 0.5rem;
}

.celebration-animation {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 10;
}

.celebration-particle {
  position: absolute;
  width: 8px;
  height: 8px;
  background: #ffd700;
  border-radius: 50%;
  animation: celebrate 2s ease-out forwards;
}

@keyframes celebrate {
  0% {
    transform: translate(0, 0) scale(0);
    opacity: 1;
  }
  100% {
    transform: translate(var(--particle-x), var(--particle-y)) scale(1);
    opacity: 0;
  }
}

.pulse-controls {
  display: flex;
  justify-content: center;
  gap: 1rem;
  margin-top: 2rem;
}

.pulse-control-btn {
  background: rgba(255, 255, 255, 0.1);
  border: 1px solid rgba(255, 255, 255, 0.2);
  color: white;
  padding: 0.75rem 1.5rem;
  border-radius: 25px;
  cursor: pointer;
  transition: all 0.3s ease;
  backdrop-filter: blur(10px);
}

.pulse-control-btn:hover,
.pulse-control-btn.active {
  background: rgba(78, 205, 196, 0.2);
  border-color: #4ecdc4;
  transform: translateY(-2px);
}

.real-time-indicator {
  position: absolute;
  top: 1rem;
  right: 1rem;
  display: flex;
  align-items: center;
  gap: 0.5rem;
  background: rgba(0, 0, 0, 0.3);
  padding: 0.5rem 1rem;
  border-radius: 20px;
  font-size: 0.9rem;
}

.live-dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: #e74c3c;
  animation: livePulse 1s ease-in-out infinite;
}

@keyframes livePulse {
  0%, 100% { opacity: 1; transform: scale(1); }
  50% { opacity: 0.5; transform: scale(0.8); }
}
6. TrendNebula.css
.trend-nebula {
  position: relative;
  padding: 2rem;
  background: radial-gradient(ellipse at center, #1a1a2e 0%, #16213e 50%, #0f0f23 100%);
  border-radius: 20px;
  color: white;
  overflow: hidden;
  min-height: 600px;
}

.nebula-background {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  opacity: 0.3;
  z-index: 1;
}

.nebula-content {
  position: relative;
  z-index: 2;
}

.nebula-header {
  text-align: center;
  margin-bottom: 2rem;
}

.nebula-title {
  font-size: 2.5rem;
  margin-bottom: 0.5rem;
  background: linear-gradient(45deg, #4ecdc4, #ffd93d);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  animation: titleShimmer 3s ease-in-out infinite;
}

@keyframes titleShimmer {
  0%, 100% { filter: brightness(1); }
  50% { filter: brightness(1.3); }
}

.nebula-subtitle {
  opacity: 0.8;
  font-size: 1.1rem;
}

.trend-cloud {
  position: relative;
  width: 100%;
  height: 400px;
  margin: 2rem 0;
}

.trend-particle {
  position: absolute;
  border-radius: 50%;
  cursor: pointer;
  transition: all 0.3s ease;
  animation: float 6s ease-in-out infinite;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: bold;
  text-align: center;
  line-height: 1.2;
}

.trend-particle:hover {
  transform: scale(1.2);
  z-index: 10;
  box-shadow: 0 0 30px currentColor;
}

@keyframes float {
  0%, 100% { transform: translateY(0px) rotate(0deg); }
  33% { transform: translateY(-10px) rotate(120deg); }
  66% { transform: translateY(5px) rotate(240deg); }
}

.trend-particle.size-small {
  width: 60px;
  height: 60px;
  font-size: 0.8rem;
  animation-duration: 8s;
}

.trend-particle.size-medium {
  width: 80px;
  height: 80px;
  font-size: 1rem;
  animation-duration: 6s;
}

.trend-particle.size-large {
  width: 100px;
  height: 100px;
  font-size: 1.2rem;
  animation-duration: 4s;
}

.trend-particle.popularity-low {
  background: linear-gradient(45deg, #3498db, #2980b9);
  color: white;
}

.trend-particle.popularity-medium {
  background: linear-gradient(45deg, #f39c12, #e67e22);
  color: white;
}

.trend-particle.popularity-high {
  background: linear-gradient(45deg, #e74c3c, #c0392b);
  color: white;
}

.trend-particle.popularity-viral {
  background: linear-gradient(45deg, #9b59b6, #8e44ad);
  color: white;
  animation: viralPulse 1s ease-in-out infinite alternate;
}

@keyframes viralPulse {
  from { box-shadow: 0 0 20px rgba(155, 89, 182, 0.6); }
  to { box-shadow: 0 0 40px rgba(155, 89, 182, 1); }
}

.trend-connections {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
}

.trend-connection-line {
  position: absolute;
  height: 2px;
  background: linear-gradient(90deg, transparent, rgba(78, 205, 196, 0.4), transparent);
  transform-origin: left center;
  animation: connectionPulse 4s ease-in-out infinite;
}

@keyframes connectionPulse {
  0%, 100% { opacity: 0.2; }
  50% { opacity: 0.8; }
}

.trend-controls {
  display: flex;
  justify-content: center;
  gap: 1rem;
  margin: 2rem 0;
}

.trend-filter-btn {
  background: rgba(255, 255, 255, 0.1);
  border: 1px solid rgba(255, 255, 255, 0.2);
  color: white;
  padding: 0.75rem 1.5rem;
  border-radius: 25px;
  cursor: pointer;
  transition: all 0.3s ease;
  backdrop-filter: blur(10px);
}

.trend-filter-btn:hover,
.trend-filter-btn.active {
  background: rgba(78, 205, 196, 0.2);
  border-color: #4ecdc4;
  transform: translateY(-2px);
}

.trend-exploration-panel {
  background: rgba(0, 0, 0, 0.3);
  border-radius: 15px;
  padding: 1.5rem;
  margin-top: 2rem;
  backdrop-filter: blur(10px);
  border: 1px solid rgba(255, 255, 255, 0.1);
}

.exploration-header {
  display: flex;
  align-items: center;
  justify-content: between;
  margin-bottom: 1rem;
}

.exploration-title {
  font-size: 1.3rem;
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.trend-search {
  background: rgba(255, 255, 255, 0.1);
  border: 1px solid rgba(255, 255, 255, 0.2);
  border-radius: 20px;
  padding: 0.5rem 1rem;
  color: white;
  width: 200px;
}

.trend-search::placeholder {
  color: rgba(255, 255, 255, 0.5);
}

.trend-categories {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: 1rem;
  margin-top: 1rem;
}

.trend-category {
  background: rgba(255, 255, 255, 0.05);
  border-radius: 10px;
  padding: 1rem;
  border: 1px solid rgba(255, 255, 255, 0.1);
}

.category-header {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  margin-bottom: 0.75rem;
}

.category-icon {
  font-size: 1.2rem;
}

.category-name {
  font-weight: bold;
}

.category-trends {
  display: flex;
  flex-wrap: wrap;
  gap: 0.5rem;
}

.mini-trend {
  background: rgba(78, 205, 196, 0.2);
  color: #4ecdc4;
  padding: 0.25rem 0.75rem;
  border-radius: 15px;
  font-size: 0.8rem;
  border: 1px solid rgba(78, 205, 196, 0.3);
  cursor: pointer;
  transition: all 0.3s ease;
}

.mini-trend:hover {
  background: rgba(78, 205, 196, 0.3);
  transform: translateY(-1px);
}

.predictive-indicators {
  margin-top: 2rem;
  background: rgba(0, 0, 0, 0.2);
  border-radius: 15px;
  padding: 1.5rem;
}

.predictive-title {
  font-size: 1.2rem;
  margin-bottom: 1rem;
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.prediction-list {
  display: flex;
  flex-direction: column;
  gap: 1rem;
}

.prediction-item {
  display: flex;
  align-items: center;
  gap: 1rem;
  padding: 1rem;
  background: rgba(255, 255, 255, 0.05);
  border-radius: 10px;
  border-left: 4px solid;
  transition: all 0.3s ease;
}

.prediction-item:hover {
  background: rgba(255, 255, 255, 0.1);
  transform: translateX(5px);
}

.prediction-item.rising {
  border-left-color: #2ecc71;
}

.prediction-item.declining {
  border-left-color: #e74c3c;
}

.prediction-item.stable {
  border-left-color: #f39c12;
}

.prediction-icon {
  font-size: 1.5rem;
  width: 40px;
  text-align: center;
}

.prediction-content {
  flex: 1;
}

.prediction-trend {
  font-weight: bold;
  margin-bottom: 0.25rem;
}

.prediction-description {
  font-size: 0.9rem;
  opacity: 0.8;
  line-height: 1.4;
}

.prediction-confidence {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  margin-top: 0.5rem;
}

.confidence-bar {
  flex: 1;
  height: 4px;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 2px;
  overflow: hidden;
}

.confidence-fill {
  height: 100%;
  background: linear-gradient(90deg, #4ecdc4, #ffd93d);
  transition: width 0.5s ease;
}

.confidence-text {
  font-size: 0.8rem;
  opacity: 0.7;
}

.trend-detail-modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.8);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
}

.trend-detail-content {
  background: linear-gradient(135deg, #1a1a2e, #16213e);
  border-radius: 20px;
  padding: 2rem;
  max-width: 600px;
  width: 90%;
  color: white;
  border: 1px solid rgba(255, 255, 255, 0.2);
  max-height: 80vh;
  overflow-y: auto;
}

.trend-detail-header {
  text-align: center;
  margin-bottom: 2rem;
}

.trend-detail-title {
  font-size: 2rem;
  margin-bottom: 0.5rem;
  background: linear-gradient(45deg, #4ecdc4, #ffd93d);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

.trend-stats {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
  gap: 1rem;
  margin: 1.5rem 0;
}

.trend-stat {
  text-align: center;
  background: rgba(255, 255, 255, 0.05);
  padding: 1rem;
  border-radius: 10px;
}

.stat-value {
  font-size: 1.5rem;
  font-weight: bold;
  color: #4ecdc4;
}

.stat-label {
  font-size: 0.9rem;
  opacity: 0.8;
  margin-top: 0.25rem;
}

.trend-timeline {
  margin: 2rem 0;
}

.timeline-title {
  font-size: 1.2rem;
  margin-bottom: 1rem;
}

.timeline-chart {
  height: 150px;
  background: rgba(255, 255, 255, 0.05);
  border-radius: 10px;
  position: relative;
  overflow: hidden;
}

.timeline-line {
  position: absolute;
  bottom: 20px;
  left: 10px;
  right: 10px;
  height: 2px;
  background: linear-gradient(90deg, #4ecdc4, #ffd93d);
}

.timeline-point {
  position: absolute;
  width: 8px;
  height: 8px;
  background: #ffd93d;
  border-radius: 50%;
  bottom: 16px;
  cursor: pointer;
  transition: all 0.3s ease;
}

.timeline-point:hover {
  transform: scale(1.5);
  box-shadow: 0 0 10px #ffd93d;
}

.related-trends {
  margin-top: 2rem;
}

.related-title {
  font-size: 1.2rem;
  margin-bottom: 1rem;
}

.related-list {
  display: flex;
  flex-wrap: wrap;
  gap: 0.5rem;
}

.related-trend {
  background: rgba(78, 205, 196, 0.2);
  color: #4ecdc4;
  padding: 0.5rem 1rem;
  border-radius: 20px;
  font-size: 0.9rem;
  border: 1px solid rgba(78, 205, 196, 0.3);
  cursor: pointer;
  transition: all 0.3s ease;
}

.related-trend:hover {
  background: rgba(78, 205, 196, 0.3);
  transform: translateY(-2px);
}

.close-modal {
  position: absolute;
  top: 1rem;
  right: 1rem;
  background: none;
  border: none;
  color: white;
  font-size: 1.5rem;
  cursor: pointer;
  opacity: 0.7;
  transition: opacity 0.3s ease;
}

.close-modal:hover {
  opacity: 1;
}
7. Файл MotivationEngine.css
.motivation-engine {
  padding: 2rem;
  background: linear-gradient(135deg, #ff6b6b 0%, #ffd93d 100%);
  border-radius: 20px;
  color: white;
  position: relative;
  overflow: hidden;
}

.engine-background {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  opacity: 0.1;
  background-image: radial-gradient(circle, white 2px, transparent 2px);
  background-size: 30px 30px;
  animation: backgroundMove 20s linear infinite;
}

@keyframes backgroundMove {
  from { transform: translate(0, 0); }
  to { transform: translate(30px, 30px); }
}

.engine-header {
  text-align: center;
  margin-bottom: 2rem;
  position: relative;
  z-index: 2;
}

.engine-title {
  font-size: 2.5rem;
  margin-bottom: 0.5rem;
  text-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 0.5rem;
}

.rocket-icon {
  animation: rocketBoost 2s ease-in-out infinite;
}

@keyframes rocketBoost {
  0%, 100% { transform: translateY(0) rotate(0deg); }
  50% { transform: translateY(-10px) rotate(5deg); }
}

.engine-subtitle {
  opacity: 0.9;
  font-size: 1.1rem;
}

.motivation-dashboard {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 2rem;
  margin-bottom: 2rem;
}

.fuel-gauge {
  background: rgba(255, 255, 255, 0.1);
  border-radius: 15px;
  padding: 1.5rem;
  backdrop-filter: blur(10px);
  border: 1px solid rgba(255, 255, 255, 0.2);
}

.gauge-header {
  text-align: center;
  margin-bottom: 1rem;
}

.gauge-title {
  font-size: 1.2rem;
  margin-bottom: 0.5rem;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 0.5rem;
}

.fuel-level {
  position: relative;
  width: 120px;
  height: 120px;
  margin: 0 auto;
}

.fuel-circle {
  width: 100%;
  height: 100%;
  border-radius: 50%;
  background: conic-gradient(
    from 0deg,
    #ff6b6b 0deg,
    #ffd93d var(--fuel-angle),
    rgba(255, 255, 255, 0.2) var(--fuel-angle)
  );
  display: flex;
  align-items: center;
  justify-content: center;
  position: relative;
}

.fuel-inner {
  width: 80px;
  height: 80px;
  border-radius: 50%;
  background: rgba(255, 255, 255, 0.1);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 1.5rem;
  font-weight: bold;
}

.fuel-actions {
  display: flex;
  justify-content: center;
  gap: 0.5rem;
  margin-top: 1rem;
}

.fuel-btn {
  background: rgba(255, 255, 255, 0.2);
  border: none;
  color: white;
  padding: 0.5rem 1rem;
  border-radius: 20px;
  cursor: pointer;
  transition: all 0.3s ease;
  font-size: 0.9rem;
}

.fuel-btn:hover {
  background: rgba(255, 255, 255, 0.3);
  transform: translateY(-2px);
}

.challenge-generator {
  background: rgba(255, 255, 255, 0.1);
  border-radius: 15px;
  padding: 1.5rem;
  backdrop-filter: blur(10px);
  border: 1px solid rgba(255, 255, 255, 0.2);
}

.generator-header {
  text-align: center;
  margin-bottom: 1rem;
}

.generator-title {
  font-size: 1.2rem;
  margin-bottom: 0.5rem;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 0.5rem;
}

.current-challenge {
  background: rgba(0, 0, 0, 0.2);
  border-radius: 10px;
  padding: 1rem;
  margin-bottom: 1rem;
  text-align: center;
}

.challenge-text {
  font-size: 1rem;
  line-height: 1.4;
  margin-bottom: 0.5rem;
}

.challenge-difficulty {
  display: inline-block;
  padding: 0.25rem 0.75rem;
  border-radius: 15px;
  font-size: 0.8rem;
  font-weight: bold;
}

.challenge-difficulty.easy {
  background: rgba(46, 204, 113, 0.3);
  color: #2ecc71;
}

.challenge-difficulty.medium {
  background: rgba(243, 156, 18, 0.3);
  color: #f39c12;
}

.challenge-difficulty.hard {
  background: rgba(231, 76, 60, 0.3);
  color: #e74c3c;
}

.challenge-actions {
  display: flex;
  justify-content: center;
  gap: 0.5rem;
}

.challenge-btn {
  background: rgba(255, 255, 255, 0.2);
  border: none;
  color: white;
  padding: 0.5rem 1rem;
  border-radius: 20px;
  cursor: pointer;
  transition: all 0.3s ease;
  font-size: 0.9rem;
}

.challenge-btn:hover {
  background: rgba(255, 255, 255, 0.3);
  transform: translateY(-2px);
}

.challenge-btn.primary {
  background: rgba(255, 255, 255, 0.3);
}

.progress-rocket {
  text-align: center;
  margin: 2rem 0;
}

.rocket-container {
  position: relative;
  width: 200px;
  height: 300px;
  margin: 0 auto;
}

.rocket-body {
  position: absolute;
  bottom: 0;
  left: 50%;
  transform: translateX(-50%);
  width: 60px;
  height: 120px;
  background: linear-gradient(180deg, #3498db, #2980b9);
  border-radius: 30px 30px 10px 10px;
  animation: rocketFly 3s ease-in-out infinite;
}

@keyframes rocketFly {
  0%, 100% { transform: translateX(-50%) translateY(0); }
  50% { transform: translateX(-50%) translateY(-20px); }
}

.rocket-flame {
  position: absolute;
  bottom: -20px;
  left: 50%;
  transform: translateX(-50%);
  width: 20px;
  height: 30px;
  background: linear-gradient(180deg, #ff6b6b, #ffd93d);
  border-radius: 0 0 50% 50%;
  animation: flameFlicker 0.5s ease-in-out infinite alternate;
}

@keyframes flameFlicker {
  from { height: 30px; opacity: 1; }
  to { height: 40px; opacity: 0.8; }
}

.rocket-trail {
  position: absolute;
  bottom: -50px;
  left: 50%;
  transform: translateX(-50%);
  width: 4px;
  height: 100px;
  background: linear-gradient(180deg, rgba(255, 215, 0, 0.6), transparent);
  border-radius: 2px;
  animation: trailGlow 2s ease-in-out infinite;
}

@keyframes trailGlow {
  0%, 100% { opacity: 0.6; }
  50% { opacity: 1; }
}


.progress-track {
  position: absolute;
  left: 20px;
  top: 0;
  width: 4px;
  height: 100%;
  background: rgba(255, 255, 255, 0.2);
  border-radius: 2px;
}

.progress-fill {
  width: 100%;
  background: linear-gradient(180deg, #4ecdc4, #ffd93d);
  border-radius: 2px;
  transition: height 0.5s ease;
}

.progress-milestones {
  position: absolute;
  left: 10px;
  top: 0;
  width: 24px;
  height: 100%;
}

.milestone {
  position: absolute;
  width: 24px;
  height: 24px;
  border-radius: 50%;
  background: rgba(255, 255, 255, 0.3);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 0.8rem;
  transition: all 0.3s ease;
}

.milestone.completed {
  background: linear-gradient(45deg, #4ecdc4, #44a08d);
  transform: scale(1.2);
  box-shadow: 0 0 15px rgba(78, 205, 196, 0.6);
}

.boost-effects {
  display: flex;
  justify-content: center;
  gap: 1rem;
  margin: 2rem 0;
}

.boost-item {
  background: rgba(255, 255, 255, 0.1);
  border-radius: 15px;
  padding: 1rem;
  text-align: center;
  cursor: pointer;
  transition: all 0.3s ease;
  backdrop-filter: blur(10px);
  border: 1px solid rgba(255, 255, 255, 0.2);
  min-width: 120px;
}

.boost-item:hover {
  background: rgba(255, 255, 255, 0.2);
  transform: translateY(-5px);
}

.boost-item.active {
  background: rgba(255, 215, 0, 0.3);
  border-color: #ffd700;
  animation: boostGlow 1s ease-in-out infinite alternate;
}

@keyframes boostGlow {
  from { box-shadow: 0 0 10px rgba(255, 215, 0, 0.5); }
  to { box-shadow: 0 0 20px rgba(255, 215, 0, 0.8); }
}

.boost-icon {
  font-size: 2rem;
  margin-bottom: 0.5rem;
  display: block;
}

.boost-name {
  font-size: 0.9rem;
  font-weight: bold;
  margin-bottom: 0.25rem;
}

.boost-duration {
  font-size: 0.8rem;
  opacity: 0.8;
}

.achievement-celebration {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 1000;
}

.celebration-burst {
  position: absolute;
  width: 100px;
  height: 100px;
  border-radius: 50%;
  background: radial-gradient(circle, rgba(255, 215, 0, 0.8), transparent);
  animation: celebrationBurst 1s ease-out forwards;
}

@keyframes celebrationBurst {
  0% { transform: scale(0); opacity: 1; }
  100% { transform: scale(5); opacity: 0; }
}

.celebration-confetti {
  position: absolute;
  width: 8px;
  height: 8px;
  background: #ffd700;
  animation: confettiFall 3s ease-out forwards;
}

@keyframes confettiFall {
  0% {
    transform: translateY(-100vh) rotate(0deg);
    opacity: 1;
  }
  100% {
    transform: translateY(100vh) rotate(720deg);
    opacity: 0;
  }
}

.motivation-stats {
  background: rgba(0, 0, 0, 0.2);
  border-radius: 15px;
  padding: 1.5rem;
  margin-top: 2rem;
}

.stats-header {
  text-align: center;
  margin-bottom: 1rem;
}

.stats-title {
  font-size: 1.3rem;
  margin-bottom: 0.5rem;
}

.stats-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
  gap: 1rem;
}

.stat-item {
  text-align: center;
  background: rgba(255, 255, 255, 0.05);
  padding: 1rem;
  border-radius: 10px;
}

.stat-value {
  font-size: 1.8rem;
  font-weight: bold;
  color: #ffd93d;
  margin-bottom: 0.25rem;
}

.stat-label {
  font-size: 0.9rem;
  opacity: 0.8;
}

.motivation-controls {
  display: flex;
  justify-content: center;
  gap: 1rem;
  margin-top: 2rem;
}

.control-btn {
  background: rgba(255, 255, 255, 0.2);
  border: none;
  color: white;
  padding: 0.75rem 1.5rem;
  border-radius: 25px;
  cursor: pointer;
  transition: all 0.3s ease;
  backdrop-filter: blur(10px);
  font-size: 1rem;
}

.control-btn:hover {
  background: rgba(255, 255, 255, 0.3);
  transform: translateY(-2px);
}

.control-btn.primary {
  background: rgba(255, 215, 0, 0.3);
  border: 1px solid #ffd700;
}

.control-btn.primary:hover {
  background: rgba(255, 215, 0, 0.4);
}
8. Файл InfluenceLeaderboard.css
.influence-leaderboard {
  padding: 2rem;
  background: linear-gradient(135deg, #2c3e50 0%, #3498db 100%);
  border-radius: 20px;
  color: white;
  position: relative;
  overflow: hidden;
}

.leaderboard-background {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  opacity: 0.1;
  background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><polygon points="50,10 61,35 90,35 69,57 79,91 50,70 21,91 31,57 10,35 39,35" fill="white"/></svg>');
  background-size: 50px 50px;
  animation: starsMove 30s linear infinite;
}

@keyframes starsMove {
  from { transform: translateY(0); }
  to { transform: translateY(-50px); }
}

.leaderboard-header {
  text-align: center;
  margin-bottom: 3rem;
  position: relative;
  z-index: 2;
}

.leaderboard-title {
  font-size: 2.5rem;
  margin-bottom: 0.5rem;
  text-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 0.5rem;
}

.crown-icon {
  animation: crownFloat 3s ease-in-out infinite;
  color: #ffd700;
}

@keyframes crownFloat {
  0%, 100% { transform: translateY(0) rotate(0deg); }
  50% { transform: translateY(-10px) rotate(5deg); }
}

.leaderboard-subtitle {
  opacity: 0.9;
  font-size: 1.1rem;
}

.podium-container {
  display: flex;
  justify-content: center;
  align-items: end;
  gap: 2rem;
  margin-bottom: 3rem;
  height: 300px;
}

.podium-place {
  display: flex;
  flex-direction: column;
  align-items: center;
  cursor: pointer;
  transition: all 0.3s ease;
}

.podium-place:hover {
  transform: translateY(-10px);
}

.podium-avatar {
  width: 80px;
  height: 80px;
  border-radius: 50%;
  margin-bottom: 1rem;
  position: relative;
  background: linear-gradient(45deg, #3498db, #2980b9);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 2rem;
  font-weight: bold;
  border: 4px solid;
  animation: avatarGlow 2s ease-in-out infinite alternate;
}

.podium-place.first .podium-avatar {
  border-color: #ffd700;
  width: 100px;
  height: 100px;
  font-size: 2.5rem;
}

.podium-place.second .podium-avatar {
  border-color: #c0c0c0;
  width: 90px;
  height: 90px;
  font-size: 2.2rem;
}

.podium-place.third .podium-avatar {
  border-color: #cd7f32;
}

@keyframes avatarGlow {
  from { box-shadow: 0 0 20px rgba(255, 215, 0, 0.5); }
  to { box-shadow: 0 0 30px rgba(255, 215, 0, 0.8); }
}

.avatar-hologram {
  position: absolute;
  top: -10px;
  left: -10px;
  right: -10px;
  bottom: -10px;
  border-radius: 50%;
  background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.1), transparent);
  animation: hologramSpin 4s linear infinite;
}

@keyframes hologramSpin {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}

.podium-crown {
  position: absolute;
  top: -20px;
  left: 50%;
  transform: translateX(-50%);
  font-size: 1.5rem;
  color: #ffd700;
  animation: crownBounce 2s ease-in-out infinite;
}

@keyframes crownBounce {
  0%, 100% { transform: translateX(-50%) translateY(0); }
  50% { transform: translateX(-50%) translateY(-5px); }
}

.podium-info {
  text-align: center;
  margin-bottom: 1rem;
}

.podium-name {
  font-size: 1.1rem;
  font-weight: bold;
  margin-bottom: 0.25rem;
}

.podium-score {
  font-size: 1.5rem;
  font-weight: bold;
  color: #ffd700;
  margin-bottom: 0.25rem;
}

.podium-rank {
  font-size: 0.9rem;
  opacity: 0.8;
}

.podium-base {
  width: 120px;
  background: linear-gradient(180deg, rgba(255, 255, 255, 0.2), rgba(255, 255, 255, 0.1));
  border-radius: 10px 10px 0 0;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 3rem;
  font-weight: bold;
  color: rgba(255, 255, 255, 0.8);
  border: 2px solid rgba(255, 255, 255, 0.3);
  position: relative;
  overflow: hidden;
}

.podium-base.first {
  height: 120px;
  background: linear-gradient(180deg, rgba(255, 215, 0, 0.3), rgba(255, 215, 0, 0.1));
  border-color: #ffd700;
}

.podium-base.second {
  height: 100px;
  background: linear-gradient(180deg, rgba(192, 192, 192, 0.3), rgba(192, 192, 192, 0.1));
  border-color: #c0c0c0;
}

.podium-base.third {
  height: 80px;
  background: linear-gradient(180deg, rgba(205, 127, 50, 0.3), rgba(205, 127, 50, 0.1));
  border-color: #cd7f32;
}

.podium-particles {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
}

.podium-particle {
  position: absolute;
  width: 4px;
  height: 4px;
  background: #ffd700;
  border-radius: 50%;
  animation: podiumParticle 3s ease-in-out infinite;
}

@keyframes podiumParticle {
  0% { transform: translateY(0) scale(0); opacity: 0; }
  50% { opacity: 1; }
  100% { transform: translateY(-50px) scale(1); opacity: 0; }
}

.leaderboard-list {
  background: rgba(0, 0, 0, 0.2);
  border-radius: 15px;
  padding: 1.5rem;
  backdrop-filter: blur(10px);
  border: 1px solid rgba(255, 255, 255, 0.1);
}

.list-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 1rem;
  padding-bottom: 0.5rem;
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.list-title {
  font-size: 1.3rem;
  font-weight: bold;
}

.list-filters {
  display: flex;
  gap: 0.5rem;
}

.filter-btn {
  background: rgba(255, 255, 255, 0.1);
  border: 1px solid rgba(255, 255, 255, 0.2);
  color: white;
  padding: 0.5rem 1rem;
  border-radius: 20px;
  cursor: pointer;
  transition: all 0.3s ease;
  font-size: 0.9rem;
}

.filter-btn:hover,
.filter-btn.active {
  background: rgba(52, 152, 219, 0.3);
  border-color: #3498db;
}

.leaderboard-entries {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}

.leaderboard-entry {
  display: flex;
  align-items: center;
  gap: 1rem;
  padding: 1rem;
  background: rgba(255, 255, 255, 0.05);
  border-radius: 10px;
  transition: all 0.3s ease;
  cursor: pointer;
  border-left: 4px solid transparent;
}

.leaderboard-entry:hover {
  background: rgba(255, 255, 255, 0.1);
  transform: translateX(5px);
  border-left-color: #3498db;
}

.entry-rank {
  font-size: 1.2rem;
  font-weight: bold;
  width: 40px;
  text-align: center;
  color: #ffd700;
}

.entry-avatar {
  width: 50px;
  height: 50px;
  border-radius: 50%;
  background: linear-gradient(45deg, #3498db, #2980b9);
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: bold;
  border: 2px solid rgba(255, 255, 255, 0.2);
  flex-shrink: 0;
}

.entry-info {
  flex: 1;
}

.entry-name {
  font-size: 1.1rem;
  font-weight: bold;
  margin-bottom: 0.25rem;
}

.entry-details {
  font-size: 0.9rem;
  opacity: 0.8;
  display: flex;
  gap: 1rem;
}

.entry-score {
  font-size: 1.3rem;
  font-weight: bold;
  color: #ffd700;
  min-width: 80px;
  text-align: right;
}

.entry-trend {
  display: flex;
  align-items: center;
  gap: 0.25rem;
  font-size: 0.9rem;
  min-width: 60px;
}

.trend-up {
  color: #2ecc71;
}

.trend-down {
  color: #e74c3c;
}

.trend-stable {
  color: #f39c12;
}

.ranking-transitions {
  position: relative;
  overflow: hidden;
}

.entry-transition {
  animation: rankingSlide 0.5s ease-out;
}

@keyframes rankingSlide {
  from { transform: translateY(-20px); opacity: 0; }
  to { transform: translateY(0); opacity: 1; }
}

.aura-effects {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  border-radius: 10px;
  overflow: hidden;
}

.aura-effect.gold {
  background: radial-gradient(circle, rgba(255, 215, 0, 0.1), transparent);
  animation: goldAura 3s ease-in-out infinite;
}

.aura-effect.silver {
  background: radial-gradient(circle, rgba(192, 192, 192, 0.1), transparent);
  animation: silverAura 3s ease-in-out infinite;
}

.aura-effect.bronze {
  background: radial-gradient(circle, rgba(205, 127, 50, 0.1), transparent);
  animation: bronzeAura 3s ease-in-out infinite;
}

@keyframes goldAura {
  0%, 100% { opacity: 0.3; transform: scale(1); }
  50% { opacity: 0.6; transform: scale(1.05); }
}

@keyframes silverAura {
  0%, 100% { opacity: 0.2; transform: scale(1); }
  50% { opacity: 0.4; transform: scale(1.03); }
}

@keyframes bronzeAura {
  0%, 100% { opacity: 0.2; transform: scale(1); }
  50% { opacity: 0.4; transform: scale(1.03); }
}

.leaderboard-stats {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 1rem;
  margin-top: 2rem;
}

.stat-card {
  background: rgba(255, 255, 255, 0.05);
  border-radius: 10px;
  padding: 1rem;
  text-align: center;
  border: 1px solid rgba(255, 255, 255, 0.1);
}

.stat-icon {
  font-size: 2rem;
  margin-bottom: 0.5rem;
  display: block;
}

.stat-value {
  font-size: 1.5rem;
  font-weight: bold;
  color: #3498db;
  margin-bottom: 0.25rem;
}

.stat-label {
  font-size: 0.9rem;
  opacity: 0.8;
}

.leaderboard-controls {
  display: flex;
  justify-content: center;
  gap: 1rem;
  margin-top: 2rem;
}

.control-button {
  background: rgba(255, 255, 255, 0.1);
  border: 1px solid rgba(255, 255, 255, 0.2);
  color: white;
  padding: 0.75rem 1.5rem;
  border-radius: 25px;
  cursor: pointer;
  transition: all 0.3s ease;
  backdrop-filter: blur(10px);
}

.control-button:hover {
  background: rgba(52, 152, 219, 0.2);
  border-color: #3498db;
  transform: translateY(-2px);
}

.user-highlight {
  border-left-color: #ffd700 !important;
  background: rgba(255, 215, 0, 0.1) !important;
}

.user-highlight .entry-name {
  color: #ffd700;
}

.achievement-badges {
  display: flex;
  gap: 0.25rem;
  margin-top: 0.25rem;
}

.achievement-badge {
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background: linear-gradient(45deg, #4ecdc4, #44a08d);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 0.7rem;
  border: 1px solid rgba(255, 255, 255, 0.2);
}

.loading-skeleton {
  background: linear-gradient(90deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.2), rgba(255, 255, 255, 0.1));
  background-size: 200% 100%;
  animation: skeletonLoading 1.5s ease-in-out infinite;
  border-radius: 10px;
  height: 70px;
  margin-bottom: 0.5rem;
}

@keyframes skeletonLoading {
  0% { background-position: -200% 0; }
  100% { background-position: 200% 0; }
}
Продолжить работу с остальными CSS-файлами? У нас ещё остались:

ParticleSystem.css
Голографический интерфейс.css
QuestSystem.css
PowerUpCenter.css
InsightCrystal.css
TravelDNA.css
InfluenceNetwork.css
Портал наставников.css
DreamBoard.css
LegacyBuilder.css
SeasonalEvents.css
Персональный музей.css
9. ParticleSystem.css
.particle-system {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  overflow: hidden;
  z-index: 1;
}

.particle-canvas {
  width: 100%;
  height: 100%;
}

.particle {
  position: absolute;
  border-radius: 50%;
  pointer-events: none;
}

.particle.floating {
  animation: particleFloat 8s ease-in-out infinite;
}

@keyframes particleFloat {
  0%, 100% { 
    transform: translateY(0px) translateX(0px) rotate(0deg);
    opacity: 0.3;
  }
  25% { 
    transform: translateY(-20px) translateX(10px) rotate(90deg);
    opacity: 0.7;
  }
  50% { 
    transform: translateY(-10px) translateX(-15px) rotate(180deg);
    opacity: 1;
  }
  75% { 
    transform: translateY(-30px) translateX(5px) rotate(270deg);
    opacity: 0.5;
  }
}

.particle.sparkle {
  background: radial-gradient(circle, #ffd700, transparent);
  animation: sparkleEffect 2s ease-in-out infinite;
}

@keyframes sparkleEffect {
  0%, 100% { 
    transform: scale(0) rotate(0deg);
    opacity: 0;
  }
  50% { 
    transform: scale(1) rotate(180deg);
    opacity: 1;
  }
}

.particle.bubble {
  background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.8), rgba(78, 205, 196, 0.3));
  border: 1px solid rgba(255, 255, 255, 0.2);
  animation: bubbleRise 6s linear infinite;
}

@keyframes bubbleRise {
  0% {
    transform: translateY(100vh) scale(0);
    opacity: 0;
  }
  10% {
    opacity: 1;
  }
  90% {
    opacity: 1;
  }
  100% {
    transform: translateY(-100px) scale(1);
    opacity: 0;
  }
}

.particle.energy {
  background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
  animation: energyPulse 3s ease-in-out infinite;
}

@keyframes energyPulse {
  0%, 100% {
    transform: scale(1);
    box-shadow: 0 0 10px currentColor;
  }
  50% {
    transform: scale(1.5);
    box-shadow: 0 0 30px currentColor;
  }
}

.particle.trail {
  background: linear-gradient(90deg, transparent, #ffd93d, transparent);
  border-radius: 2px;
  animation: trailMove 4s linear infinite;
}

@keyframes trailMove {
  0% {
    transform: translateX(-100px) scaleX(0);
    opacity: 0;
  }
  20% {
    opacity: 1;
    transform: scaleX(1);
  }
  80% {
    opacity: 1;
  }
  100% {
    transform: translateX(100vw) scaleX(0);
    opacity: 0;
  }
}

.particle.explosion {
  animation: explosionParticle 1s ease-out forwards;
}

@keyframes explosionParticle {
  0% {
    transform: scale(0) rotate(0deg);
    opacity: 1;
  }
  100% {
    transform: scale(2) rotate(360deg) translate(var(--explosion-x), var(--explosion-y));
    opacity: 0;
  }
}

.particle.achievement {
  background: radial-gradient(circle, #ffd700, #ff6b6b);
  animation: achievementBurst 2s ease-out forwards;
}

@keyframes achievementBurst {
  0% {
    transform: scale(0);
    opacity: 1;
  }
  50% {
    transform: scale(1.5);
    opacity: 0.8;
  }
  100% {
    transform: scale(3) translate(var(--burst-x), var(--burst-y));
    opacity: 0;
  }
}

.particle.ambient {
  background: rgba(255, 255, 255, 0.1);
  animation: ambientDrift 12s linear infinite;
}

@keyframes ambientDrift {
  0% {
    transform: translateX(-50px) translateY(100vh);
    opacity: 0;
  }
  10%, 90% {
    opacity: 0.3;
  }
  100% {
    transform: translateX(50px) translateY(-100px);
    opacity: 0;
  }
}

.particle.interaction {
  background: radial-gradient(circle, rgba(78, 205, 196, 0.8), transparent);
  animation: interactionRipple 1s ease-out forwards;
}

@keyframes interactionRipple {
  0% {
    transform: scale(0);
    opacity: 0.8;
  }
  100% {
    transform: scale(10);
    opacity: 0;
  }
}

.particle.magic {
  background: conic-gradient(from 0deg, #ff6b6b, #ffd93d, #4ecdc4, #ff6b6b);
  animation: magicSparkle 3s ease-in-out infinite;
}

@keyframes magicSparkle {
  0%, 100% {
    transform: rotate(0deg) scale(1);
    opacity: 0.6;
  }
  50% {
    transform: rotate(180deg) scale(1.3);
    opacity: 1;
  }
}

.particle.constellation {
  background: #ffffff;
  box-shadow: 0 0 10px #ffffff;
  animation: constellationTwinkle 4s ease-in-out infinite;
}

@keyframes constellationTwinkle {
  0%, 100% {
    opacity: 0.3;
    transform: scale(1);
  }
  50% {
    opacity: 1;
    transform: scale(1.2);
  }
}

.particle-emitter {
  position: absolute;
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background: radial-gradient(circle, rgba(255, 215, 0, 0.8), transparent);
}

.emitter.active {
  animation: emitterPulse 1s ease-in-out infinite;
}

@keyframes emitterPulse {
  0%, 100% {
    transform: scale(1);
    opacity: 0.5;
  }
  50% {
    transform: scale(1.5);
    opacity: 1;
  }
}

.particle-field {
  position: relative;
  width: 100%;
  height: 100%;
}

.field-line {
  position: absolute;
  height: 1px;
  background: linear-gradient(90deg, transparent, rgba(78, 205, 196, 0.3), transparent);
  animation: fieldFlow 6s linear infinite;
}

@keyframes fieldFlow {
  0% {
    transform: translateX(-100%);
    opacity: 0;
  }
  50% {
    opacity: 1;
  }
  100% {
    transform: translateX(100%);
    opacity: 0;
  }
}

.particle-cluster {
  position: absolute;
  animation: clusterRotate 20s linear infinite;
}

@keyframes clusterRotate {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}

.cluster-particle {
  position: absolute;
  width: 4px;
  height: 4px;
  background: #4ecdc4;
  border-radius: 50%;
  animation: clusterOrbit 8s linear infinite;
}

@keyframes clusterOrbit {
  from { 
    transform: rotate(0deg) translateX(var(--orbit-radius)) rotate(0deg);
  }
  to { 
    transform: rotate(360deg) translateX(var(--orbit-radius)) rotate(-360deg);
  }
}

.particle-wave {
  position: absolute;
  width: 100%;
  height: 2px;
  background: linear-gradient(90deg, transparent, #ffd93d, transparent);
  animation: waveMotion 4s ease-in-out infinite;
}

@keyframes waveMotion {
  0%, 100% {
    transform: translateY(0) scaleY(1);
    opacity: 0.3;
  }
  50% {
    transform: translateY(-20px) scaleY(2);
    opacity: 1;
  }
}

.particle-vortex {
  position: absolute;
  width: 200px;
  height: 200px;
  border-radius: 50%;
  border: 2px solid rgba(78, 205, 196, 0.3);
  animation: vortexSpin 10s linear infinite;
}

@keyframes vortexSpin {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}

.vortex-particle {
  position: absolute;
  width: 6px;
  height: 6px;
  background: #4ecdc4;
  border-radius: 50%;
  animation: vortexParticle 5s linear infinite;
}

@keyframes vortexParticle {
  0% {
    transform: rotate(0deg) translateX(100px) scale(1);
    opacity: 1;
  }
  100% {
    transform: rotate(720deg) translateX(0px) scale(0);
    opacity: 0;
  }
}

.particle-storm {
  position: absolute;
  width: 100%;
  height: 100%;
}

.storm-particle {
  position: absolute;
  width: 3px;
  height: 3px;
  background: #ffffff;
  border-radius: 50%;
  animation: stormChaos 6s ease-in-out infinite;
}

@keyframes stormChaos {
  0%, 100% {
    transform: translate(0, 0) scale(1);
    opacity: 0.3;
  }
  25% {
    transform: translate(50px, -30px) scale(1.5);
    opacity: 0.8;
  }
  50% {
    transform: translate(-30px, 40px) scale(0.8);
    opacity: 1;
  }
  75% {
    transform: translate(20px, -50px) scale(1.2);
    opacity: 0.6;
  }
}

.particle-controls {
  position: absolute;
  top: 1rem;
  right: 1rem;
  display: flex;
  gap: 0.5rem;
  z-index: 10;
}

.particle-control-btn {
  background: rgba(0, 0, 0, 0.5);
  border: 1px solid rgba(255, 255, 255, 0.2);
  color: white;
  padding: 0.5rem;
  border-radius: 50%;
  cursor: pointer;
  transition: all 0.3s ease;
  backdrop-filter: blur(10px);
}

.particle-control-btn:hover {
  background: rgba(78, 205, 196, 0.3);
  border-color: #4ecdc4;
}

.particle-control-btn.active {
  background: rgba(78, 205, 196, 0.5);
  border-color: #4ecdc4;
}
10. HolographicUI.css
.holographic-ui {
  position: relative;
  background: rgba(0, 0, 0, 0.1);
  backdrop-filter: blur(10px);
  border: 1px solid rgba(78, 205, 196, 0.3);
  border-radius: 15px;
  overflow: hidden;
}

.holographic-ui::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(78, 205, 196, 0.1), transparent);
  animation: hologramScan 3s linear infinite;
}

@keyframes hologramScan {
  0% { left: -100%; }
  100% { left: 100%; }
}

.holo-button {
  background: rgba(78, 205, 196, 0.1);
  border: 2px solid #4ecdc4;
  color: #4ecdc4;
  padding: 0.75rem 1.5rem;
  border-radius: 25px;
  cursor: pointer;
  transition: all 0.3s ease;
  position: relative;
  overflow: hidden;
  backdrop-filter: blur(5px);
  text-transform: uppercase;
  font-weight: bold;
  letter-spacing: 1px;
}

.holo-button::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(78, 205, 196, 0.3), transparent);
  transition: left 0.5s ease;
}

.holo-button:hover {
  background: rgba(78, 205, 196, 0.2);
  box-shadow: 0 0 20px rgba(78, 205, 196, 0.5);
  transform: translateY(-2px);
}

.holo-button:hover::before {
  left: 100%;
}

.holo-button.active {
  background: rgba(78, 205, 196, 0.3);
  box-shadow: 0 0 30px rgba(78, 205, 196, 0.7);
  animation: holoButtonPulse 2s ease-in-out infinite;
}

@keyframes holoButtonPulse {
  0%, 100% { box-shadow: 0 0 30px rgba(78, 205, 196, 0.7); }
  50% { box-shadow: 0 0 40px rgba(78, 205, 196, 1); }
}

.holo-panel {
  background: rgba(0, 0, 0, 0.3);
  border: 1px solid rgba(78, 205, 196, 0.5);
  border-radius: 10px;
  padding: 1.5rem;
  position: relative;
  backdrop-filter: blur(15px);
}

.holo-panel::after {
  content: '';
  position: absolute;
  top: -1px;
  left: -1px;
  right: -1px;
  bottom: -1px;
  background: linear-gradient(45deg, #4ecdc4, transparent, #4ecdc4);
  border-radius: 10px;
  z-index: -1;
  animation: holoBorderGlow 4s linear infinite;
}

@keyframes holoBorderGlow {
  0%, 100% { opacity: 0.5; }
  50% { opacity: 1; }
}


.holo-text {
  color: #4ecdc4;
  text-shadow: 0 0 10px rgba(78, 205, 196, 0.5);
  font-family: 'Courier New', monospace;
  animation: textFlicker 0.1s linear infinite;
}

@keyframes textFlicker {
  0%, 98% { opacity: 1; }
  99% { opacity: 0.8; }
  100% { opacity: 1; }
}

.holo-text.neon {
  color: #ffd93d;
  text-shadow: 
    0 0 5px #ffd93d,
    0 0 10px #ffd93d,
    0 0 15px #ffd93d,
    0 0 20px #ff6b6b;
  animation: neonGlow 2s ease-in-out infinite alternate;
}

@keyframes neonGlow {
  from { 
    text-shadow: 
      0 0 5px #ffd93d,
      0 0 10px #ffd93d,
      0 0 15px #ffd93d,
      0 0 20px #ff6b6b;
  }
  to { 
    text-shadow: 
      0 0 10px #ffd93d,
      0 0 20px #ffd93d,
      0 0 30px #ffd93d,
      0 0 40px #ff6b6b;
  }
}

.holo-input {
  background: rgba(0, 0, 0, 0.5);
  border: 2px solid rgba(78, 205, 196, 0.5);
  border-radius: 5px;
  padding: 0.75rem;
  color: #4ecdc4;
  font-family: 'Courier New', monospace;
  backdrop-filter: blur(5px);
  transition: all 0.3s ease;
}

.holo-input:focus {
  outline: none;
  border-color: #4ecdc4;
  box-shadow: 0 0 15px rgba(78, 205, 196, 0.5);
  background: rgba(0, 0, 0, 0.7);
}

.holo-input::placeholder {
  color: rgba(78, 205, 196, 0.5);
}

.transparent-panel {
  background: rgba(255, 255, 255, 0.05);
  backdrop-filter: blur(20px);
  border: 1px solid rgba(255, 255, 255, 0.1);
  border-radius: 15px;
  padding: 2rem;
  position: relative;
}

.transparent-panel::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 1px;
  background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.5), transparent);
  animation: topGlow 3s ease-in-out infinite;
}

@keyframes topGlow {
  0%, 100% { opacity: 0.3; }
  50% { opacity: 1; }
}

.glowing-border {
  position: relative;
  border: 2px solid transparent;
  border-radius: 10px;
  background: linear-gradient(45deg, rgba(78, 205, 196, 0.1), rgba(255, 215, 0, 0.1));
  background-clip: padding-box;
}

.glowing-border::before {
  content: '';
  position: absolute;
  top: -2px;
  left: -2px;
  right: -2px;
  bottom: -2px;
  background: linear-gradient(45deg, #4ecdc4, #ffd700, #ff6b6b, #4ecdc4);
  border-radius: 10px;
  z-index: -1;
  animation: borderRotate 4s linear infinite;
}

@keyframes borderRotate {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}

.hologram-effect {
  position: relative;
  color: #4ecdc4;
}

.hologram-effect::before {
  content: attr(data-text);
  position: absolute;
  top: 0;
  left: 2px;
  color: #ff6b6b;
  opacity: 0.8;
  animation: hologramGlitch 0.3s linear infinite;
}

.hologram-effect::after {
  content: attr(data-text);
  position: absolute;
  top: 0;
  left: -2px;
  color: #ffd93d;
  opacity: 0.8;
  animation: hologramGlitch 0.3s linear infinite reverse;
}

@keyframes hologramGlitch {
  0%, 100% { transform: translateX(0); }
  20% { transform: translateX(-2px); }
  40% { transform: translateX(2px); }
  60% { transform: translateX(-1px); }
  80% { transform: translateX(1px); }
}

.holo-card {
  background: rgba(0, 0, 0, 0.4);
  border: 1px solid rgba(78, 205, 196, 0.3);
  border-radius: 15px;
  padding: 1.5rem;
  position: relative;
  backdrop-filter: blur(10px);
  transition: all 0.3s ease;
}

.holo-card:hover {
  border-color: #4ecdc4;
  box-shadow: 0 0 25px rgba(78, 205, 196, 0.3);
  transform: translateY(-5px);
}

.holo-card::before {
  content: '';
  position: absolute;
  top: 10px;
  left: 10px;
  right: 10px;
  height: 1px;
  background: linear-gradient(90deg, transparent, rgba(78, 205, 196, 0.5), transparent);
  animation: cardScanLine 2s linear infinite;
}

@keyframes cardScanLine {
  0% { transform: translateY(0); opacity: 1; }
  100% { transform: translateY(200px); opacity: 0; }
}

.holo-progress {
  width: 100%;
  height: 20px;
  background: rgba(0, 0, 0, 0.5);
  border: 1px solid rgba(78, 205, 196, 0.3);
  border-radius: 10px;
  overflow: hidden;
  position: relative;
}

.holo-progress-fill {
  height: 100%;
  background: linear-gradient(90deg, #4ecdc4, #ffd93d);
  border-radius: 10px;
  position: relative;
  transition: width 0.5s ease;
}

.holo-progress-fill::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
  animation: progressGlow 2s linear infinite;
}

@keyframes progressGlow {
  0% { transform: translateX(-100%); }
  100% { transform: translateX(100%); }
}

.holo-menu {
  background: rgba(0, 0, 0, 0.8);
  border: 1px solid rgba(78, 205, 196, 0.5);
  border-radius: 10px;
  backdrop-filter: blur(15px);
  overflow: hidden;
}

.holo-menu-item {
  padding: 1rem 1.5rem;
  color: #4ecdc4;
  cursor: pointer;
  transition: all 0.3s ease;
  border-bottom: 1px solid rgba(78, 205, 196, 0.1);
  position: relative;
}

.holo-menu-item:hover {
  background: rgba(78, 205, 196, 0.1);
  color: #ffffff;
}

.holo-menu-item::before {
  content: '';
  position: absolute;
  left: 0;
  top: 0;
  bottom: 0;
  width: 3px;
  background: #4ecdc4;
  transform: scaleY(0);
  transition: transform 0.3s ease;
}

.holo-menu-item:hover::before {
  transform: scaleY(1);
}

.holo-tooltip {
  position: absolute;
  background: rgba(0, 0, 0, 0.9);
  border: 1px solid #4ecdc4;
  border-radius: 5px;
  padding: 0.5rem 1rem;
  color: #4ecdc4;
  font-size: 0.9rem;
  backdrop-filter: blur(10px);
  z-index: 1000;
  animation: tooltipFadeIn 0.3s ease;
}

@keyframes tooltipFadeIn {
  from { opacity: 0; transform: translateY(10px); }
  to { opacity: 1; transform: translateY(0); }
}

.holo-tooltip::after {
  content: '';
  position: absolute;
  top: 100%;
  left: 50%;
  transform: translateX(-50%);
  border: 5px solid transparent;
  border-top-color: #4ecdc4;
}

.holo-grid {
  display: grid;
  gap: 1rem;
  position: relative;
}

.holo-grid::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-image: 
    linear-gradient(rgba(78, 205, 196, 0.1) 1px, transparent 1px),
    linear-gradient(90deg, rgba(78, 205, 196, 0.1) 1px, transparent 1px);
  background-size: 20px 20px;
  pointer-events: none;
  animation: gridPulse 4s ease-in-out infinite;
}

@keyframes gridPulse {
  0%, 100% { opacity: 0.3; }
  50% { opacity: 0.6; }
}

.holo-loading {
  display: inline-block;
  width: 40px;
  height: 40px;
  border: 3px solid rgba(78, 205, 196, 0.3);
  border-top: 3px solid #4ecdc4;
  border-radius: 50%;
  animation: holoSpin 1s linear infinite;
}

@keyframes holoSpin {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}

.holo-badge {
  display: inline-block;
  padding: 0.25rem 0.75rem;
  background: rgba(78, 205, 196, 0.2);
  border: 1px solid #4ecdc4;
  border-radius: 15px;
  color: #4ecdc4;
  font-size: 0.8rem;
  font-weight: bold;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  animation: badgeGlow 3s ease-in-out infinite;
}

@keyframes badgeGlow {
  0%, 100% { box-shadow: 0 0 5px rgba(78, 205, 196, 0.3); }
  50% { box-shadow: 0 0 15px rgba(78, 205, 196, 0.6); }
}

.holo-divider {
  height: 1px;
  background: linear-gradient(90deg, transparent, #4ecdc4, transparent);
  margin: 1rem 0;
  animation: dividerPulse 2s ease-in-out infinite;
}

@keyframes dividerPulse {
  0%, 100% { opacity: 0.5; }
  50% { opacity: 1; }
}
11. QuestSystem.css
.quest-system {
  padding: 2rem;
  background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
  border-radius: 20px;
  color: white;
  position: relative;
  overflow: hidden;
}

.quest-background {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  opacity: 0.1;
  background-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><path d="M50 10 L60 40 L90 40 L70 60 L80 90 L50 70 L20 90 L30 60 L10 40 L40 40 Z" fill="white"/></svg>');
  background-size: 30px 30px;
  animation: questStars 20s linear infinite;
}

@keyframes questStars {
  from { transform: translateY(0); }
  to { transform: translateY(-30px); }
}

.quest-header {
  text-align: center;
  margin-bottom: 2rem;
  position: relative;
  z-index: 2;
}

.quest-title {
  font-size: 2.5rem;
  margin-bottom: 0.5rem;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 0.5rem;
  text-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
}

.quest-icon {
  animation: questIconFloat 3s ease-in-out infinite;
}

@keyframes questIconFloat {
  0%, 100% { transform: translateY(0) rotate(0deg); }
  50% { transform: translateY(-10px) rotate(10deg); }
}

.quest-subtitle {
  opacity: 0.9;
  font-size: 1.1rem;
}

.quest-dashboard {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 2rem;
  margin-bottom: 2rem;
}

.active-quests {
  background: rgba(255, 255, 255, 0.05);
  border-radius: 15px;
  padding: 1.5rem;
  backdrop-filter: blur(10px);
  border: 1px solid rgba(255, 255, 255, 0.1);
}

.section-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 1rem;
  padding-bottom: 0.5rem;
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.section-title {
  font-size: 1.3rem;
  font-weight: bold;
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.quest-count {
  background: rgba(52, 152, 219, 0.3);
  color: #3498db;
  padding: 0.25rem 0.75rem;
  border-radius: 15px;
  font-size: 0.8rem;
  font-weight: bold;
}

.quest-list {
  display: flex;
  flex-direction: column;
  gap: 1rem;
}

.