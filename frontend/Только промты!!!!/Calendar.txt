конкретный промт для разработки. Вот подробный план создания динамичного модуля календаря событий:

🚀 ПРОМТ: Модуль «Календарь событий» для тревел-проекта
📋 КОНЦЕПЦИЯ МОДУЛЯ
Название: EventsTimeline (Временная лента событий) Тип: Интерактивная временная шкала с карточками событий Расположение: Левое окно (технический раздел)

🎯 ОСНОВНЫЕ ПРИНЦИПЫ ДИЗАЙНА
Временной подход вместо классического календаря
Карточная система для каждого события
Живая анимация при взаимодействии
Модульная архитектура для простой интеграции
Адаптивные состояния (создание → активное → завершённое → архив)
🏗️ Архитектура компонентов
EventsCalendar/
├── EventsTimeline.jsx          // Основной контейнер
├── TimelineNavigation.jsx      // Навигация по времени
├── EventCard.jsx              // Карточка события
├── EventCreator.jsx           // Модальное окно создания
├── EventDetails.jsx           // Детальный вид события
├── ParticipantsPanel.jsx      // Панель участников
├── EventArchive.jsx           // Архив событий
├── IntegrationHub.jsx         // Центр интеграций
└── hooks/
    ├── useEventState.js       // Состояние событий
    ├── useTimelineNavigation.js
    └── useIntegrations.js     // Связь с другими модулями
🎨 Концепция UI/UX
Основной вид:

Вертикальная шкала времени с плавающими карточками
Каждая карточка = отдельное путешествие/событие
Цветовая кодировка по статусам (планируется/активно/завершено)
Анимированные переходы между состояниями
Карточка события содержит:

Заголовок и даты
Миниатюра маршрута (связь с планировщиком)
Аватары участников (первые 3–4)
Индикатор активности чата
Прогресс-бар подготовки
Быстрые действия (присоединиться/выйти/чат)
⚙️ ФУНКЦИОНАЛЬНЫЕ ТРЕБОВАНИЯ
Создание события:
const eventStructure = {
  id: uuid(),
  title: string,
  description: string,
  dateRange: { start: Date, end: Date },
  location: { coordinates, address },
  participants: {
    organizer: userId,
    members: [userIds],
    maxCapacity: number,
    joinRequests: [userIds]
  },
  integrations: {
    routeId: string,        // Связь с планировщиком
    chatRoomId: string,     // Автосоздание чата
    mapMarkerId: string,    // Связь с картой
    blogId: string          // Связь с блогом
  },
  status: 'planning' | 'active' | 'completed' | 'archived',
  metadata: {
    budget: number,
    difficulty: string,
    tags: [strings]
  }
}
Интеграции с модулями:
Карта: Автоматическое создание метки при создании события
Планировщик: Импорт готового маршрута в событие
Чаты: Автосоздание приватной комнаты для участников
Лента: Публикация активности события
Блоги: Привязка отчетов к завершенным событиям
🔄 ЖИЗНЕННЫЙ ЦИКЛ СОБЫТИЯ
Planning (Планирование):

Создание события
Набор участников
Планирование маршрута
Обсуждение в чате
Active (Активное):

Событие началось
Трекинг прогресса
Живое общение
Обновления в ленте
Completed (Завершенное):

Создание отчета/блога
Оценки и отзывы
Фото и воспоминания
Archived (Архивное):

Возможность пересоздания
Просмотр истории
Статистика
💻 ТЕХНИЧЕСКАЯ РЕАЛИЗАЦИЯ
State Management:
// useEventState.js
const useEventState = () => {
  const [events, setEvents] = useState([]);
  const [activeEvent, setActiveEvent] = useState(null);
  const [timelineView, setTimelineView] = useState('month');
  
  const createEvent = async (eventData) => {
    // Создание события + автоинтеграции
  };
  
  const joinEvent = async (eventId, userId) => {
    // Логика присоединения
  };
  
  return { events, activeEvent, createEvent, joinEvent };
};
Интеграционный хаб:
// useIntegrations.js
const useIntegrations = () => {
  const createEventIntegrations = async (eventData) => {
    // Создание метки на карте
    await mapService.createMarker(eventData.location);
    
    // Создание чат-комнаты
    const chatRoom = await chatService.createRoom({
      name: `${eventData.title} - Чат`,
      participants: eventData.participants.members,
      type: 'event'
    });
    
    // Уведомление в ленту
    await activityService.publish({
      type: 'event_created',
      data: eventData
    });
    
    return { chatRoomId: chatRoom.id };
  };
};
🎭 АНИМАЦИИ И ЭФФЕКТЫ
Появление карточек: Плавное всплытие снизу
Переходы состояний: Морфинг цветов и иконок
Hover-эффекты: Подъем карточки с тенью
Загрузка: Скелетон-анимация
Создание события: Модальное окно с пошаговой анимацией
📱 АДАПТИВНОСТЬ
Desktop: Полная функциональность в левом окне
Tablet: Компактный вид с свайпами
Mobile: Вертикальная лента на весь экран
🔧 ПЛАН ПОЭТАПНОЙ РАЗРАБОТКИ
Этап 1 (MVP):

Базовая временная шкала
Создание/просмотр событий
Интеграция с чатами
Этап 2:

Система участников
Интеграция с картой и планировщиком
Базовые анимации
Этап 3:

Архив событий
Расширенная интеграция с лентой и блогами
Продвинутые анимации
Этап 4:

Аналитика и статистика
Рекомендательная система
Экспорт/импорт событий
Этот промт даст вам четкую дорожную карту для создания действительно динамичного и интегрированного календаря событий!

Допиши мне все коды для календаря, сегодня внедрю в проект
Отлично! Вот полный код для динамического календаря событий:

📁 Структура файлов
src/components/EventsCalendar/
├── EventsTimeline.jsx
├── TimelineNavigation.jsx
├── EventCard.jsx
├── EventCreator.jsx
├── EventDetails.jsx
├── ParticipantsPanel.jsx
├── EventArchive.jsx
├── IntegrationHub.jsx
├── hooks/
│   ├── useEventState.js
│   ├── useTimelineNavigation.js
│   └── useIntegrations.js
├── utils/
│   ├── eventUtils.js
│   └── dateUtils.js
└── styles/
    └── EventsCalendar.css
🎯 1. Основной компонент — EventsTimeline.jsx
import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import TimelineNavigation from './TimelineNavigation';
import EventCard from './EventCard';
import EventCreator from './EventCreator';
import EventDetails from './EventDetails';
import EventArchive from './EventArchive';
import { useEventState } from './hooks/useEventState';
import { useTimelineNavigation } from './hooks/useTimelineNavigation';
import './styles/EventsCalendar.css';

const EventsTimeline = ({ isFullScreen = false }) => {
  const [showCreator, setShowCreator] = useState(false);
  const [selectedEvent, setSelectedEvent] = useState(null);
  const [showArchive, setShowArchive] = useState(false);
  
  const {
    events,
    activeEvents,
    completedEvents,
    createEvent,
    updateEvent,
    joinEvent,
    leaveEvent,
    loading
  } = useEventState();
  
  const {
    currentPeriod,
    viewMode,
    setViewMode,
    navigatePeriod,
    filteredEvents
  } = useTimelineNavigation(events);

  const handleCreateEvent = async (eventData) => {
    try {
      await createEvent(eventData);
      setShowCreator(false);
    } catch (error) {
      console.error('Error creating event:', error);
    }
  };

  const handleEventClick = (event) => {
    setSelectedEvent(event);
  };

  return (
    <div className={`events-timeline ${isFullScreen ? 'fullscreen' : ''}`}>
      {/* Header */}
      <div className="timeline-header">
        <div className="header-controls">
          <h2>События и Путешествия</h2>
          <div className="header-actions">
            <button 
              className="btn-archive"
              onClick={() => setShowArchive(true)}
            >
              📚 Архив
            </button>
            <button 
              className="btn-create"
              onClick={() => setShowCreator(true)}
            >
              ✨ Создать событие
            </button>
          </div>
        </div>
        
        <TimelineNavigation
          currentPeriod={currentPeriod}
          viewMode={viewMode}
          onViewModeChange={setViewMode}
          onNavigate={navigatePeriod}
        />
      </div>

      {/* Timeline Content */}
      <div className="timeline-content">
        {loading ? (
          <div className="timeline-skeleton">
            {[...Array(3)].map((_, i) => (
              <div key={i} className="skeleton-card" />
            ))}
          </div>
        ) : (
          <AnimatePresence>
            <div className="timeline-track">
              {filteredEvents.map((event, index) => (
                <motion.div
                  key={event.id}
                  initial={{ opacity: 0, y: 50 }}
                  animate={{ opacity: 1, y: 0 }}
                  exit={{ opacity: 0, y: -50 }}
                  transition={{ delay: index * 0.1 }}
                  className="timeline-item"
                >
                  <div className="timeline-date">
                    {new Date(event.dateRange.start).toLocaleDateString('ru-RU', {
                      day: 'numeric',
                      month: 'short'
                    })}
                  </div>
                  <EventCard
                    event={event}
                    onClick={() => handleEventClick(event)}
                    onJoin={joinEvent}
                    onLeave={leaveEvent}
                  />
                </motion.div>
              ))}
            </div>
          </AnimatePresence>
        )}

        {filteredEvents.length === 0 && !loading && (
          <div className="empty-state">
            <div className="empty-icon">🗓️</div>
            <h3>Нет событий</h3>
            <p>Создайте первое путешествие!</p>
            <button 
              className="btn-create-empty"
              onClick={() => setShowCreator(true)}
            >
              Создать событие
            </button>
          </div>
        )}
      </div>

      {/* Modals */}
      <AnimatePresence>
        {showCreator && (
          <EventCreator
            onClose={() => setShowCreator(false)}
            onSubmit={handleCreateEvent}
          />
        )}
        
        {selectedEvent && (
          <EventDetails
            event={selectedEvent}
            onClose={() => setSelectedEvent(null)}
            onUpdate={updateEvent}
            onJoin={joinEvent}
            onLeave={leaveEvent}
          />
        )}
        
        {showArchive && (
          <EventArchive
            events={completedEvents}
            onClose={() => setShowArchive(false)}
            onRecreate={createEvent}
          />
        )}
      </AnimatePresence>
    </div>
  );
};

export default EventsTimeline;
🧭 2. Навигация — TimelineNavigation.jsx
import React from 'react';
import { motion } from 'framer-motion';

const TimelineNavigation = ({ 
  currentPeriod, 
  viewMode, 
  onViewModeChange, 
  onNavigate 
}) => {
  const viewModes = [
    { key: 'week', label: 'Неделя', icon: '📅' },
    { key: 'month', label: 'Месяц', icon: '🗓️' },
    { key: 'year', label: 'Год', icon: '📆' }
  ];

  const formatPeriod = () => {
    const date = new Date(currentPeriod);
    switch (viewMode) {
      case 'week':
        return `${date.toLocaleDateString('ru-RU', { day: 'numeric', month: 'short' })} - ${new Date(date.getTime() + 6 * 24 * 60 * 60 * 1000).toLocaleDateString('ru-RU', { day: 'numeric', month: 'short' })}`;
      case 'month':
        return date.toLocaleDateString('ru-RU', { month: 'long', year: 'numeric' });
      case 'year':
        return date.getFullYear().toString();
      default:
        return '';
    }
  };

  return (
    <div className="timeline-navigation">
      {/* Period Navigation */}
      <div className="period-nav">
        <button 
          className="nav-btn"
          onClick={() => onNavigate('prev')}
        >
          ←
        </button>
        
        <div className="current-period">
          {formatPeriod()}
        </div>
        
        <button 
          className="nav-btn"
          onClick={() => onNavigate('next')}
        >
          →
        </button>
        
        <button 
          className="nav-btn today"
          onClick={() => onNavigate('today')}
        >
          Сегодня
        </button>
      </div>

      {/* View Mode Selector */}
      <div className="view-modes">
        {viewModes.map((mode) => (
          <motion.button
            key={mode.key}
            className={`view-mode ${viewMode === mode.key ? 'active' : ''}`}
            onClick={() => onViewModeChange(mode.key)}
            whileHover={{ scale: 1.05 }}
            whileTap={{ scale: 0.95 }}
          >
            <span className="mode-icon">{mode.icon}</span>
            <span className="mode-label">{mode.label}</span>
          </motion.button>
        ))}
      </div>

      {/* Quick Filters */}
      <div className="quick-filters">
        <button className="filter-btn active">Все</button>
        <button className="filter-btn">Активные</button>
        <button className="filter-btn">Мои</button>
      </div>
    </div>
  );
};

export default TimelineNavigation;
🎴 3. Карточка события — EventCard.jsx
import React, { useState } from 'react';
import { motion } from 'framer-motion';
import ParticipantsPanel from './ParticipantsPanel';
import { formatDateRange, getEventStatus } from './utils/dateUtils';

const EventCard = ({ event, onClick, onJoin, onLeave }) => {
  const [isHovered, setIsHovered] = useState(false);
  const status = getEventStatus(event);
  const isParticipant = event.participants.members.includes('currentUserId'); // Replace with actual user ID

  const statusConfig = {
    planning: { color: '#3B82F6', icon: '🎯', label: 'Планируется' },
    active: { color: '#10B981', icon: '🚀', label: 'Активно' },
    completed: { color: '#8B5CF6', icon: '✅', label: 'Завершено' },
    archived: { color: '#6B7280', icon: '📚', label: 'Архив' }
  };

  const currentStatus = statusConfig[status];

  const handleQuickAction = (e, action) => {
    e.stopPropagation();
    if (action === 'join') {
      onJoin(event.id, 'currentUserId');
    } else if (action === 'leave') {
      onLeave(event.id, 'currentUserId');
    }
  };

  return (
    <motion.div
      className={`event-card ${status}`}
      onClick={onClick}
      onHoverStart={() => setIsHovered(true)}
      onHoverEnd={() => setIsHovered(false)}
      whileHover={{ 
        y: -8, 
        boxShadow: '0 20px 40px rgba(0,0,0,0.15)' 
      }}
      whileTap={{ scale: 0.98 }}
      style={{ '--status-color': currentStatus.color }}
    >
      {/* Status Indicator */}
      <div className="card-status">
        <span className="status-icon">{currentStatus.icon}</span>
        <span className="status-label">{currentStatus.label}</span>
      </div>

      {/* Main Content */}
      <div className="card-content">
        <div className="card-header">
          <h3 className="event-title">{event.title}</h3>
          <div className="event-dates">
            {formatDateRange(event.dateRange)}
          </div>
        </div>

        <div className="card-body">
          <p className="event-description">{event.description}</p>
          
          {/* Location */}
          <div className="event-location">
            <span className="location-icon">📍</span>
            <span>{event.location.address}</span>
          </div>

          {/* Route Preview */}
          {event.integrations.routeId && (
            <div className="route-preview">
              <span className="route-icon">🗺️</span>
              <span>Маршрут готов</span>
            </div>
          )}
        </div>

        {/* Participants */}
        <ParticipantsPanel 
          participants={event.participants}
          compact={true}
        />

        {/* Progress Bar */}
        {status === 'planning' && (
          <div className="preparation-progress">
            <div className="progress-label">Подготовка</div>
            <div className="progress-bar">
              <div 
                className="progress-fill"
                style={{ width: `${event.preparationProgress || 0}%` }}
              />
            </div>
          </div>
        )}
      </div>

      {/* Quick Actions */}
      <motion.div 
        className="card-actions"
        initial={{ opacity: 0 }}
        animate={{ opacity: isHovered ? 1 : 0 }}
      >
        {!isParticipant ? (
          <button 
            className="action-btn join"
            onClick={(e) => handleQuickAction(e, 'join')}
          >
            Присоединиться
          </button>
        ) : (
          <button 
            className="action-btn leave"
            onClick={(e) => handleQuickAction(e, 'leave')}
          >
            Покинуть
          </button>
        )}
        
        {event.integrations.chatRoomId && (
          <button className="action-btn chat">
            💬 Чат
          </button>
        )}
      </motion.div>

      {/* Activity Indicator */}
      {event.hasRecentActivity && (
        <div className="activity-indicator">
          <div className="activity-pulse" />
        </div>
      )}
    </motion.div>
  );
};

export default EventCard;
✨ 4. Создание события — EventCreator.jsx
import React, { useState } from 'react';
import { motion } from 'framer-motion';
import { useIntegrations } from './hooks/useIntegrations';

const EventCreator = ({ onClose, onSubmit }) => {
  const [step, setStep] = useState(1);
  const [formData, setFormData] = useState({
    title: '',
    description: '',
    dateRange: { start: '', end: '' },
    location: { address: '', coordinates: null },
    maxCapacity: 10,
    tags: [],
    budget: '',
    difficulty: 'medium'
  });

  const { 
    availableRoutes, 
    createIntegratedEvent,
    loading 
  } = useIntegrations();

  const steps = [
    { title: 'Основная информация', icon: '📝' },
    { title: 'Место и время', icon: '📍' },
    { title: 'Участники', icon: '👥' },
    { title: 'Интеграции', icon: '🔗' }
  ];

  const handleInputChange = (field, value) => {
    setFormData(prev => ({
      ...prev,
      [field]: value
    }));
  };

  const handleSubmit = async () => {
    try {
      await createIntegratedEvent(formData);
      onSubmit(formData);
    } catch (error) {
      console.error('Error creating event:', error);
    }
  };

  const renderStep = () => {
    switch (step) {
      case 1:
        return (
          <div className="form-step">
            <div className="form-group">
              <label>Название события</label>
              <input
                type="text"
                value={formData.title}
                onChange={(e) => handleInputChange('title', e.target.value)}
                placeholder="Поездка в горы..."
                className="form-input"
              />
            </div>
            
            <div className="form-group">
              <label>Описание</label>
              <textarea
                value={formData.description}
                onChange={(e) => handleInputChange('description', e.target.value)}
                placeholder="Расскажите о вашем путешествии..."
                className="form-textarea"
                rows={4}
              />
            </div>

            <div className="form-row">
              <div className="form-group">
                <label>Сложность</label>
                <select
                  value={formData.difficulty}
                  onChange={(e) => handleInputChange('difficulty', e.target.value)}
                  className="form-select"
                >
                  <option value="easy">Легкая</option>
                  <option value="medium">Средняя</option>
                  <option value="hard">Сложная</option>
                </select>
              </div>
              
              <div className="form-group">
                <label>Бюджет (₽)</label>
                <input
                  type="number"
                  value={formData.budget}
                  onChange={(e) => handleInputChange('budget', e.target.value)}
                  placeholder="10000"
                  className="form-input"
                />
              </div>
            </div>
          </div>
        );

      case 2:
        return (
          <div className="form-step">
            <div className="form-group">
              <label>Место проведения</label>
              <input
                type="text"
                value={formData.location.address}
                onChange={(e) => handleInputChange('location', {
                  ...formData.location,
                  address: e.target.value
                })}
                placeholder="Красная Поляна, Сочи"
                className="form-input"
              />
            </div>

            <div className="form-row">
              <div className="form-group">
                <label>Дата начала</label>
                <input
                  type="datetime-local"
                  value={formData.dateRange.start}
                  onChange={(e) => handleInputChange('dateRange', {
                    ...formData.dateRange,
                    start: e.target.value
                  })}
                  className="form-input"
                />
              </div>
              
              <div className="form-group">
                <label>Дата окончания</label>
                <input
                  type="datetime-local"
                  value={formData.dateRange.end}
                  onChange={(e) => handleInputChange('dateRange', {
                    ...formData.dateRange,
                    end: e.target.value
                  })}
                  className="form-input"
                />
              </div>
            </div>

            <div className="map-preview">
              <div className="map-placeholder">
                🗺️ Предварительный просмотр карты
              </div>
            </div>
          </div>
        );

      case 3:
        return (
          <div className="form-step">
            <div className="form-group">
              <label>Максимальное количество участников</label>
              <input
                type="number"
                value={formData.maxCapacity}
                onChange={(e) => handleInputChange('maxCapacity', parseInt(e.target.value))}
                min="2"
                max="50"
                className="form-input"
              />
            </div>

            <div className="form-group">
              <label>Теги</label>
              <div className="tags-input">
                <input
                  type="text"
                  placeholder="Добавить тег..."
                  className="form-input"
                  onKeyPress={(e) => {
                    if (e.key === 'Enter' && e.target.value.trim()) {
                      handleInputChange('tags', [...formData.tags, e.target.value.trim()]);
                      e.target.value = '';
                    }
                  }}
                />
                <div className="tags-list">
                  {formData.tags.map((tag, index) => (
                    <span key={index} className="tag">
                      {tag}
                      <button
                        onClick={() => handleInputChange('tags', 
                          formData.tags.filter((_, i) => i !== index)
                        )}
                      >
                        ×
                      </button>
                    </span>
                  ))}
                </div>
              </div>
            </div>

            <div className="participants-preview">
              <h4>Участники будут приглашены после создания</h4>
              <div className="invite-options">
                <label className="checkbox-label">
                  <input type="checkbox" />
                  Открытое событие (любой может присоединиться)
                </label>
                <label className="checkbox-label">
                  <input type="checkbox" />
                  Требуется подтверждение организатора
                </label>
              </div>
            </div>
          </div>
        );

      case 4:
        return (
          <div className="form-step">
            <h3>Интеграции с другими разделами</h3>
            
            <div className="integration-option">
              <div className="integration-header">
                <span className="integration-icon">🗺️</span>
                <span>Создать метку на карте</span>
                <input type="checkbox" defaultChecked />
              </div>
              <p>Автоматически создаст метку в указанном месте</p>
            </div>

            <div className="integration-option">
              <div className="integration-header">
                <span className="integration-icon">💬</span>
                <span>Создать чат-комнату</span>
                <input type="checkbox" defaultChecked />
              </div>
              <p>Приватный чат для участников события</p>
            </div>

            <div className="integration-option">
              <div className="integration-header">
                <span className="integration-icon">📱</span>
                <span>Опубликовать в ленте активности</span>
                <input type="checkbox" defaultChecked />
              </div>
              <p>Уведомить подписчиков о новом событии</p>
            </div>

            <div className="integration-option">
              <div className="integration-header">
                <span className="integration-icon">🛣️</span>
                <span>Импортировать маршрут</span>
                <input type="checkbox" />
              </div>
              {availableRoutes.length > 0 && (
                <select className="form-select">
                  <option>Выберите маршрут...</option>
                  {availableRoutes.map(route => (
                    <option key={route.id} value={route.id}>
                      {route.name}
                    </option>
                  ))}
                </select>
              )}
            </div>
          </div>
        );

      default:
        return null;
    }
  };

  return (
    <motion.div
      className="modal-overlay"
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
      exit={{ opacity: 0 }}
      onClick={onClose}
    >
      <motion.div
        className="event-creator-modal"
        initial={{ scale: 0.9, opacity: 0 }}
        animate={{ scale: 1, opacity: 1 }}
        exit={{ scale: 0.9, opacity: 0 }}
        onClick={(e) => e.stopPropagation()}
      >
        {/* Header */}
        <div className="modal-header">
          <h2>Создать новое событие</h2>
          <button className="close-btn" onClick={onClose}>×</button>
        </div>

        {/* Progress Steps */}
        <div className="steps-progress">
          {steps.map((stepInfo, index) => (
            <div
              key={index}
              className={`step ${index + 1 <= step ? 'active' : ''} ${index + 1 === step ? 'current' : ''}`}
            >
              <div className="step-icon">{stepInfo.icon}</div>
              <div className="step-title">{stepInfo.title}</div>
            </div>
          ))}
        </div>

        {/* Form Content */}
        <div className="modal-content">
          {renderStep()}
        </div>

        {/* Footer */}
        <div className="modal-footer">
          <button
            className="btn-secondary"
            onClick={() => step > 1 ? setStep(step - 1) : onClose()}
          >
            {step > 1 ? 'Назад' : 'Отмена'}
          </button>
          
          {step < steps.length ? (
            <button
              className="btn-primary"
              onClick={() => setStep(step + 1)}
              disabled={!formData.title || !formData.description}
            >
              Далее
            </button>
          ) : (
            <button
              className="btn-primary"
              onClick={handleSubmit}
              disabled={loading}
            >
              {loading ? 'Создание...' : 'Создать событие'}
            </button>
          )}
        </div>
      </motion.div>
    </motion.div>
  );
};

export default EventCreator;
📋 5. Подробности события — EventDetails.jsx
import React, { useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import ParticipantsPanel from './ParticipantsPanel';
import { formatDateRange, getEventStatus } from './utils/dateUtils';

const EventDetails = ({ event, onClose, onUpdate, onJoin, onLeave }) => {
  const [activeTab, setActiveTab] = useState('overview');
  const [isEditing, setIsEditing] = useState(false);
  const status = getEventStatus(event);
  const isParticipant = event.participants.members.includes('currentUserId');
  const isOrganizer = event.participants.organizer === 'currentUserId';

  const tabs = [
    { key: 'overview', label: 'Обзор', icon: '📋' },
    { key: 'participants', label: 'Участники', icon: '👥' },
    { key: 'chat', label: 'Чат', icon: '💬' },
    { key: 'route', label: 'Маршрут', icon: '🗺️' },
    { key: 'blog', label: 'Блог', icon: '📝' }
  ];

  const renderTabContent = () => {
    switch (activeTab) {
      case 'overview':
        return (
          <div className="tab-content overview">
            <div className="event-header-details">
              <h1>{event.title}</h1>
              <div className="event-meta">
                <span className="event-dates">{formatDateRange(event.dateRange)}</span>
                <span className="event-location">📍 {event.location.address}</span>
                <span className={`event-status ${status}`}>
                  {status === 'planning' && '🎯 Планируется'}
                  {status === 'active' && '🚀 Активно'}
                  {status === 'completed' && '✅ Завершено'}
                </span>
              </div>
            </div>

            <div className="event-description">
              <h3>Описание</h3>
              <p>{event.description}</p>
            </div>

            <div className="event-details-grid">
              <div className="detail-card">
                <h4>💰 Бюджет</h4>
                <p>{event.metadata.budget ? `${event.metadata.budget} ₽` : 'Не указан'}</p>
              </div>
              
              <div className="detail-card">
                <h4>⚡ Сложность</h4>
                <p>
                  {event.metadata.difficulty === 'easy' && 'Легкая'}
                  {event.metadata.difficulty === 'medium' && 'Средняя'}
                  {event.metadata.difficulty === 'hard' && 'Сложная'}
                </p>
              </div>
              
              <div className="detail-card">
                <h4>👥 Участники</h4>
                <p>{event.participants.members.length} / {event.participants.maxCapacity}</p>
              </div>
            </div>

            {event.metadata.tags.length > 0 && (
              <div className="event-tags">
                <h4>Теги</h4>
                <div className="tags-list">
                  {event.metadata.tags.map((tag, index) => (
                    <span key={index} className="tag">{tag}</span>
                  ))}
                </div>
              </div>
            )}

            {status === 'planning' && (
              <div className="preparation-status">
                <h4>Статус подготовки</h4>
                <div className="progress-bar">
                  <div 
                    className="progress-fill"
                    style={{ width: `${event.preparationProgress || 0}%` }}
                  />
                </div>
                <div className="preparation-checklist">
                  <div className="checklist-item completed">✅ Место определено</div>
                  <div className="checklist-item completed">✅ Даты согласованы</div>
                  <div className="checklist-item">⏳ Маршрут планируется</div>
                  <div className="checklist-item">⏳ Участники набираются</div>
                </div>
              </div>
            )}
          </div>
        );

      case 'participants':
        return (
          <div className="tab-content participants">
            <ParticipantsPanel 
              participants={event.participants}
              compact={false}
              showActions={isOrganizer}
            />
          </div>
        );

      case 'chat':
        return (
          <div className="tab-content chat">
            <div className="chat-integration">
              <div className="chat-preview">
                <h3>Чат события</h3>
                <p>Здесь будет интеграция с модулем чатов</p>
                <button className="btn-primary">Открыть чат в правом окне</button>
              </div>
            </div>
          </div>
        );

      case 'route':
        return (
          <div className="tab-content route">
            <div className="route-integration">
              {event.integrations.routeId ? (
                <div className="route-preview">
                  <h3>Маршрут готов</h3>
                  <div className="route-stats">
                    <div className="stat">📏 Расстояние: 45 км</div>
                    <div className="stat">⏱️ Время: 3 дня</div>
                    <div className="stat">📈 Сложность: Средняя</div>
                  </div>
                  <button className="btn-primary">Открыть в планировщике</button>
                </div>
              ) : (
                <div className="no-route">
                  <h3>Маршрут не создан</h3>
                  <p>Создайте маршрут в планировщике и привяжите к событию</p>
                  <button className="btn-primary">Создать маршрут</button>
                </div>
              )}
            </div>
          </div>
        );

      case 'blog':
        return (
          <div className="tab-content blog">
            <div className="blog-integration">
              {status === 'completed' ? (
                <div className="blog-section">
                  <h3>Отчет о путешествии</h3>
                  {event.integrations.blogId ? (
                    <div className="blog-preview">
                      <div className="blog-card">
                        <h4>Поездка в горы - незабываемые впечатления</h4>
                        <p>Краткое описание блога...</p>
                        <div className="blog-stats">
                          <span>👀 245 просмотров</span>
                          <span>❤️ 23 лайка</span>
                          <span>💬 8 комментариев</span>
                        </div>
                      </div>
                      <button className="btn-primary">Открыть блог</button>
                    </div>
                  ) : (
                    <div className="create-blog">
                      <p>Поделитесь впечатлениями о путешествии</p>
                      <button className="btn-primary">Создать отчет</button>
                    </div>
                  )}
                </div>
              ) : (
                <div className="blog-placeholder">
                  <h3>Блог будет доступен после завершения события</h3>
                  <p>После путешествия вы сможете создать отчет и поделиться впечатлениями</p>
                </div>
              )}
            </div>
          </div>
        );

      default:
        return null;
    }
  };

  return (
    <motion.div
      className="modal-overlay"
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
      exit={{ opacity: 0 }}
      onClick={onClose}
    >
      <motion.div
        className="event-details-modal"
        initial={{ scale: 0.9, opacity: 0 }}
        animate={{ scale: 1, opacity: 1 }}
        exit={{ scale: 0.9, opacity: 0 }}
        onClick={(e) => e.stopPropagation()}
      >
        {/* Header */}
        <div className="modal-header">
          <div className="header-left">
            <h2>{event.title}</h2>
            <div className="header-actions">
              {isOrganizer && (
                <button 
                  className="btn-edit"
                  onClick={() => setIsEditing(!isEditing)}
                >
                  ✏️ Редактировать
                </button>
              )}
            </div>
          </div>
          <button className="close-btn" onClick={onClose}>×</button>
        </div>

        {/* Action Bar */}
        <div className="action-bar">
          {!isParticipant ? (
            <button 
              className="btn-join"
              onClick={() => onJoin(event.id, 'currentUserId')}
            >
              🚀 Присоединиться
            </button>
          ) : (
            <button 
              className="btn-leave"
              onClick={() => onLeave(event.id, 'currentUserId')}
            >
              👋 Покинуть
            </button>
          )}
          
          <button className="btn-share">📤 Поделиться</button>
          <button className="btn-favorite">⭐ В избранное</button>
        </div>

        {/* Tabs */}
        <div className="tabs-container">
          <div className="tabs-nav">
            {tabs.map((tab) => (
              <button
                key={tab.key}
                className={`tab-btn ${activeTab === tab.key ? 'active' : ''}`}
                onClick={() => setActiveTab(tab.key)}
              >
                <span className="tab-icon">{tab.icon}</span>
                <span className="tab-label">{tab.label}</span>
              </button>
            ))}
          </div>

          <div className="tabs-content">
            <AnimatePresence mode="wait">
              <motion.div
                key={activeTab}
                initial={{ opacity: 0, x: 20 }}
                animate={{ opacity: 1, x: 0 }}
                exit={{ opacity: 0, x: -20 }}
                transition={{ duration: 0.2 }}
              >
                {renderTabContent()}
              </motion.div>
            </AnimatePresence>
          </div>
        </div>
      </motion.div>
    </motion.div>
  );
};

export default EventDetails;
👥 6. Панель участников — ParticipantsPanel.jsx
import React, { useState } from 'react';
import { motion } from 'framer-motion';

const ParticipantsPanel = ({ participants, compact = false, showActions = false }) => {
  const [showAll, setShowAll] = useState(false);
  
  const { organizer, members, maxCapacity, joinRequests = [] } = participants;
  const displayLimit = compact ? 3 : 8;
  const displayMembers = showAll ? members : members.slice(0, displayLimit);

  const mockUsers = {
    'user1': { name: 'Анна Петрова', avatar: '👩‍🦰', status: 'online' },
    'user2': { name: 'Михаил Иванов', avatar: '👨‍💼', status: 'offline' },
    'user3': { name: 'Елена Сидорова', avatar: '👩‍🎨', status: 'online' },
    'user4': { name: 'Дмитрий Козлов', avatar: '👨‍🔬', status: 'away' },
    'user5': { name: 'Ольга Морозова', avatar: '👩‍💻', status: 'online' }
  };

  const getUserInfo = (userId) => mockUsers[userId] || { 
    name: 'Пользователь', 
    avatar: '👤', 
    status: 'offline' 
  };

  if (compact) {
    return (
      <div className="participants-compact">
        <div className="participants-avatars">
          {displayMembers.map((userId, index) => {
            const user = getUserInfo(userId);
            return (
              <motion.div
                key={userId}
                className={`participant-avatar ${user.status}`}
                initial={{ scale: 0 }}
                animate={{ scale: 1 }}
                transition={{ delay: index * 0.1 }}
                title={user.name}
              >
                {user.avatar}
                {userId === organizer && <div className="organizer-badge">👑</div>}
              </motion.div>
            );
          })}
          
          {members.length > displayLimit && (
            <div className="more-participants">
              +{members.length - displayLimit}
            </div>
          )}
        </div>
        
        <div className="participants-count">
          {members.length} / {maxCapacity}
        </div>
      </div>
    );
  }

  return (
    <div className="participants-panel">
      <div className="panel-header">
        <h3>Участники ({members.length}/{maxCapacity})</h3>
        {showActions && (
          <button className="btn-invite">
            ➕ Пригласить
          </button>
        )}
      </div>

      {/* Organizer */}
      <div className="organizer-section">
        <h4>Организатор</h4>
        <div className="participant-item organizer">
          <div className="participant-info">
            <div className={`participant-avatar ${getUserInfo(organizer).status}`}>
              {getUserInfo(organizer).avatar}
              <div className="organizer-badge">👑</div>
            </div>
            <div className="participant-details">
              <div className="participant-name">{getUserInfo(organizer).name}</div>
              <div className="participant-role">Организатор</div>
            </div>
          </div>
          <div className="participant-actions">
            <button className="action-btn">💬</button>
          </div>
        </div>
      </div>

      {/* Members */}
      <div className="members-section">
        <h4>Участники</h4>
        <div className="participants-list">
          {displayMembers
            .filter(userId => userId !== organizer)
            .map((userId, index) => {
              const user = getUserInfo(userId);
              return (
                <motion.div
                  key={userId}
                  className="participant-item"
                  initial={{ opacity: 0, y: 20 }}
                  animate={{ opacity: 1, y: 0 }}
                  transition={{ delay: index * 0.1 }}
                >
                  <div className="participant-info">
                    <div className={`participant-avatar ${user.status}`}>
                      {user.avatar}
                    </div>
                    <div className="participant-details">
                      <div className="participant-name">{user.name}</div>
                      <div className="participant-status">
                        {user.status === 'online' && '🟢 В сети'}
                        {user.status === 'offline' && '⚫ Не в сети'}
                        {user.status === 'away' && '🟡 Отошел'}
                      </div>
                    </div>
                  </div>
                  <div className="participant-actions">
                    <button className="action-btn">💬</button>
                    {showActions && (
                      <button className="action-btn remove">🗑️</button>
                    )}
                  </div>
                </motion.div>
              );
            })}
        </div>

        {members.length > displayLimit && (
          <button 
            className="show-more-btn"
            onClick={() => setShowAll(!showAll)}
          >
            {showAll ? 'Скрыть' : `Показать еще ${members.length - displayLimit}`}
          </button>
        )}
      </div>

      {/* Join Requests */}
      {joinRequests.length > 0 && showActions && (
        <div className="requests-section">
          <h4>Заявки на участие ({joinRequests.length})</h4>
          <div className="requests-list">
            {joinRequests.map((userId) => {
              const user = getUserInfo(userId);
              return (
                <div key={userId} className="request-item">
                  <div className="participant-info">
                    <div className="participant-avatar">
                      {user.avatar}
                    </div>
                    <div className="participant-details">
                      <div className="participant-name">{user.name}</div>
                      <div className="request-time">2 часа назад</div>
                    </div>
                  </div>
                  <div className="request-actions">
                    <button className="btn-approve">✅</button>
                    <button className="btn-reject">❌</button>
                  </div>
                </div>
              );
            })}
          </div>
        </div>
      )}

      {/* Capacity Warning */}
      {members.length >= maxCapacity * 0.8 && (
        <div className="capacity-warning">
          ⚠️ Осталось мест: {maxCapacity - members.length}
        </div>
      )}
    </div>
  );
};

export default ParticipantsPanel;
📚 7. Архив событий — EventArchive.jsx
import React, { useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { formatDateRange } from './utils/dateUtils';

const EventArchive = ({ events, onClose, onRecreate }) => {
  const [selectedYear, setSelectedYear] = useState(new Date().getFullYear());
  const [searchTerm, setSearchTerm] = useState('');
  const [sortBy, setSortBy] = useState('date');

  // Group events by year
  const eventsByYear = events.reduce((acc, event) => {
    const year = new Date(event.dateRange.start).getFullYear();
    if (!acc[year]) acc[year] = [];
    acc[year].push(event);
    return acc;
  }, {});

  const availableYears = Object.keys(eventsByYear).sort((a, b) => b - a);

  // Filter and sort events
  const filteredEvents = (eventsByYear[selectedYear] || [])
    .filter(event => 
      event.title.toLowerCase().includes(searchTerm.toLowerCase()) ||
      event.description.toLowerCase().includes(searchTerm.toLowerCase())
    )
    .sort((a, b) => {
      switch (sortBy) {
        case 'date':
          return new Date(b.dateRange.start) - new Date(a.dateRange.start);
        case 'title':
          return a.title.localeCompare(b.title);
        case 'participants':
          return b.participants.members.length - a.participants.members.length;
        default:
          return 0;
      }
    });

  const handleRecreate = (event) => {
    const newEvent = {
      ...event,
      id: undefined,
      dateRange: { start: '', end: '' },
      participants: {
        organizer: 'currentUserId',
        members: ['currentUserId'],
        maxCapacity: event.participants.maxCapacity,
        joinRequests: []
      },
      status: 'planning',
      title: `${event.title} (повтор)`
    };
    onRecreate(newEvent);
    onClose();
  };

  return (
    <motion.div
      className="modal-overlay"
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
      exit={{ opacity: 0 }}
      onClick={onClose}
    >
      <motion.div
        className="archive-modal"
        initial={{ scale: 0.9, opacity: 0 }}
        animate={{ scale: 1, opacity: 1 }}
        exit={{ scale: 0.9, opacity: 0 }}
        onClick={(e) => e.stopPropagation()}
      >
        {/* Header */}
        <div className="modal-header">
          <h2>📚 Архив событий</h2>
          <button className="close-btn" onClick={onClose}>×</button>
        </div>

        {/* Controls */}
        <div className="archive-controls">
          <div className="year-selector">
            <label>Год:</label>
            <select 
              value={selectedYear} 
              onChange={(e) => setSelectedYear(parseInt(e.target.value))}
              className="form-select"
            >
              {availableYears.map(year => (
                <option key={year} value={year}>{year}</option>
              ))}
            </select>
          </div>

          <div className="search-box">
            <input
              type="text"
              placeholder="Поиск событий..."
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
              className="form-input"
            />
          </div>

          <div className="sort-selector">
            <label>Сортировка:</label>
            <select 
              value={sortBy} 
              onChange={(e) => setSortBy(e.target.value)}
              className="form-select"
            >
              <option value="date">По дате</option>
              <option value="title">По названию</option>
              <option value="participants">По участникам</option>
            </select>
          </div>
        </div>

        {/* Statistics */}
        <div className="archive-stats">
          <div className="stat-card">
            <div className="stat-number">{events.length}</div>
            <div className="stat-label">Всего событий</div>
          </div>
          <div className="stat-card">
            <div className="stat-number">{availableYears.length}</div>
            <div className="stat-label">Лет активности</div>
          </div>
          <div className="stat-card">
            <div className="stat-number">
              {events.reduce((sum, event) => sum + event.participants.members.length, 0)}
            </div>
            <div className="stat-label">Участников</div>
          </div>
          <div className="stat-card">
            <div className="stat-number">
              {events.filter(event => event.integrations.blogId).length}
            </div>
            <div className="stat-label">С отчетами</div>
          </div>
        </div>

        {/* Events List */}
        <div className="archive-content">
          {filteredEvents.length === 0 ? (
            <div className="empty-archive">
              <div className="empty-icon">📭</div>
              <h3>Нет событий</h3>
              <p>
                {searchTerm 
                  ? 'По вашему запросу ничего не найдено' 
                  : `В ${selectedYear} году событий не было`
                }
              </p>
            </div>
          ) : (
            <div className="archive-grid">
              <AnimatePresence>
                {filteredEvents.map((event, index) => (
                  <motion.div
                    key={event.id}
                    className="archive-card"
                    initial={{ opacity: 0, y: 20 }}
                    animate={{ opacity: 1, y: 0 }}
                    exit={{ opacity: 0, y: -20 }}
                    transition={{ delay: index * 0.05 }}
                    whileHover={{ y: -5, boxShadow: '0 10px 30px rgba(0,0,0,0.1)' }}
                  >
                    <div className="card-header">
                      <h3>{event.title}</h3>
                      <div className="event-date">
                        {formatDateRange(event.dateRange)}
                      </div>
                    </div>

                    <div className="card-content">
                      <p className="event-description">{event.description}</p>
                      
                      <div className="event-meta">
                        <div className="meta-item">
                          <span className="meta-icon">📍</span>
                          <span>{event.location.address}</span>
                        </div>
                        <div className="meta-item">
                          <span className="meta-icon">👥</span>
                          <span>{event.participants.members.length} участников</span>
                        </div>
                        {event.metadata.budget && (
                          <div className="meta-item">
                            <span className="meta-icon">💰</span>
                            <span>{event.metadata.budget} ₽</span>
                          </div>
                        )}
                      </div>

                      {event.metadata.tags.length > 0 && (
                        <div className="event-tags">
                          {event.metadata.tags.slice(0, 3).map((tag, i) => (
                            <span key={i} className="tag">{tag}</span>
                          ))}
                          {event.metadata.tags.length > 3 && (
                            <span className="tag more">+{event.metadata.tags.length - 3}</span>
                          )}
                        </div>
                      )}
                    </div>

                    <div className="card-footer">
                      <div className="integrations">
                        {event.integrations.routeId && (
                          <span className="integration-badge" title="Есть маршрут">🗺️</span>
                        )}
                        {event.integrations.chatRoomId && (
                          <span className="integration-badge" title="Есть чат">💬</span>
                        )}
                        {event.integrations.blogId && (
                          <span className="integration-badge" title="Есть отчет">📝</span>
                        )}
                      </div>

                      <div className="card-actions">
                        <button 
                          className="btn-recreate"
                          onClick={() => handleRecreate(event)}
                          title="Создать похожее событие"
                        >
                          🔄 Повторить
                        </button>
                        <button 
                          className="btn-view"
                          title="Просмотр деталей"
                        >
                          👁️ Просмотр
                        </button>
                      </div>
                    </div>

                    {/* Success indicator */}
                    <div className="success-indicator">
                      <div className="success-score">
                        ⭐ {Math.floor(Math.random() * 2) + 4}.{Math.floor(Math.random() * 10)}
                      </div>
                    </div>
                  </motion.div>
                ))}
              </AnimatePresence>
            </div>
          )}
        </div>

        {/* Timeline View Toggle */}
        <div className="view-toggle">
          <button className="toggle-btn active">📋 Сетка</button>
          <button className="toggle-btn">📈 Временная шкала</button>
        </div>
      </motion.div>
    </motion.div>
  );
};

export default EventArchive;
🔗 8. Хук состояния событий — hooks/useEventState.js
import { useState, useEffect, useCallback } from 'react';
import { v4 as uuidv4 } from 'uuid';

export const useEventState = () => {
  const [events, setEvents] = useState([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  // Mock data for development
  const mockEvents = [
    {
      id: '1',
      title: 'Поход в Карелию',
      description: 'Незабываемое путешествие по карельским озерам и лесам',
      dateRange: {
        start: '2024-07-15T10:00:00',
        end: '2024-07-20T18:00:00'
      },
      location: {
        address: 'Карелия, озеро Ладожское',
        coordinates: { lat: 61.7849, lng: 34.3469 }
      },
      participants: {
        organizer: 'user1',
        members: ['user1', 'user2', 'user3'],
        maxCapacity: 8,
        joinRequests: ['user4']
      },
      integrations: {
        routeId: 'route1',
        chatRoomId: 'chat1',
        mapMarkerId: 'marker1',
        blogId: null
      },
      status: 'planning',
      metadata: {
        budget: 15000,
        difficulty: 'medium',
        tags: ['природа', 'озера', 'рыбалка']
      },
      preparationProgress: 65,
      hasRecentActivity: true,
      createdAt: '2024-06-01T12:00:00'
    },
    {
      id: '2',
      title: 'Восхождение на Эльбрус',
      description: 'Покорение высочайшей вершины России',
      dateRange: {
        start: '2024-08-10T06:00:00',
        end: '2024-08-18T20:00:00'
      },
      location: {
        address: 'Кабардино-Балкария, Эльбрус',
        coordinates: { lat: 43.3499, lng: 42.4453 }
      },
      participants: {
        organizer: 'user2',
        members: ['user2', 'user3', 'user5'],
        maxCapacity: 6,
        joinRequests: []
      },
      integrations: {
        routeId: 'route2',
        chatRoomId: 'chat2',
        mapMarkerId: 'marker2',
        blogId: null
      },
      status: 'active',
      metadata: {
        budget: 35000,
        difficulty: 'hard',
        tags: ['горы', 'альпинизм', 'вызов']
      },
      preparationProgress: 100,
      hasRecentActivity: false,
      createdAt: '2024-05-15T14:30:00'
    }
  ];

  useEffect(() => {
    // Initialize with mock data
    setEvents(mockEvents);
  }, []);

  const createEvent = useCallback(async (eventData) => {
    setLoading(true);
    setError(null);
    
    try {
      const newEvent = {
        id: uuidv4(),
        ...eventData,
        participants: {
          organizer: 'currentUserId',
          members: ['currentUserId'],
          maxCapacity: eventData.maxCapacity || 10,
          joinRequests: []
        },
        integrations: {
          routeId: null,
          chatRoomId: null,
          mapMarkerId: null,
          blogId: null
        },
        status: 'planning',
        preparationProgress: 0,
        hasRecentActivity: true,
        createdAt: new Date().toISOString()
      };

      // Simulate API call
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      setEvents(prev => [newEvent, ...prev]);
      return newEvent;
    } catch (err) {
      setError(err.message);
      throw err;
    } finally {
      setLoading(false);
    }
  }, []);

  const updateEvent = useCallback(async (eventId, updates) => {
    setLoading(true);
    setError(null);
    
    try {
      await new Promise(resolve => setTimeout(resolve, 500));
      
      setEvents(prev => prev.map(event => 
        event.id === eventId 
          ? { ...event, ...updates }
          : event
      ));
    } catch (err) {
      setError(err.message);
      throw err;
    } finally {
      setLoading(false);
    }
  }, []);

  const joinEvent = useCallback(async (eventId, userId) => {
    try {
      setEvents(prev => prev.map(event => {
        if (event.id === eventId) {
          const isAlreadyMember = event.participants.members.includes(userId);
          const isAtCapacity = event.participants.members.length >= event.participants.maxCapacity;
          
          if (isAlreadyMember) return event;
          
          if (isAtCapacity) {
            // Add to join requests
            return {
              ...event,
              participants: {
                ...event.participants,
                joinRequests: [...event.participants.joinRequests, userId]
              }
            };
          } else {
            // Add directly to members
            return {
              ...event,
              participants: {
                ...event.participants,
                members: [...event.participants.members, userId],
                joinRequests: event.participants.joinRequests.filter(id => id !== userId)
              }
            };
          }
        }
        return event;
      }));
    } catch (err) {
      setError(err.message);
      throw err;
    }
  }, []);

  const leaveEvent = useCallback(async (eventId, userId) => {
    try {
      setEvents(prev => prev.map(event => {
        if (event.id === eventId) {
          return {
            ...event,
            participants: {
              ...event.participants,
              members: event.participants.members.filter(id => id !== userId),
              joinRequests: event.participants.joinRequests.filter(id => id !== userId)
            }
          };
        }
        return event;
      }));
    } catch (err) {
      setError(err.message);
      throw err;
    }
  }, []);

  const deleteEvent = useCallback(async (eventId) => {
    setLoading(true);
    setError(null);
    
    try {
      await new Promise(resolve => setTimeout(resolve, 500));
      setEvents(prev => prev.filter(event => event.id !== eventId));
    } catch (err) {
      setError(err.message);
      throw err;
    } finally {
      setLoading(false);
    }
  }, []);

  // Computed values
  const activeEvents = events.filter(event => 
    event.status === 'planning' || event.status === 'active'
  );
  
  const completedEvents = events.filter(event => 
    event.status === 'completed' || event.status === 'archived'
  );
  
  const myEvents = events.filter(event => 
    event.participants.organizer === 'currentUserId' || 
    event.participants.members.includes('currentUserId')
  );

  return {
    events,
    activeEvents,
    completedEvents,
    myEvents,
    loading,
    error,
    createEvent,
    updateEvent,
    joinEvent,
    leaveEvent,
    deleteEvent
  };
};
🧭 9. Хук навигации по времени — hooks/useTimelineNavigation.js
import { useState, useMemo, useCallback } from 'react';
import { 
  startOfWeek, 
  endOfWeek, 
  startOfMonth, 
  endOfMonth, 
  startOfYear, 
  endOfYear,
  addWeeks,
  addMonths,
  addYears,
  isWithinInterval
} from 'date-fns';

export const useTimelineNavigation = (events) => {
  const [currentPeriod, setCurrentPeriod] = useState(new Date());
  const [viewMode, setViewMode] = useState('month'); // 'week', 'month', 'year'

  const getPeriodBounds = useCallback((date, mode) => {
    switch (mode) {
      case 'week':
        return {
          start: startOfWeek(date, { weekStartsOn: 1 }),
          end: endOfWeek(date, { weekStartsOn: 1 })
        };
      case 'month':
        return {
          start: startOfMonth(date),
          end: endOfMonth(date)
        };
      case 'year':
        return {
          start: startOfYear(date),
          end: endOfYear(date)
        };
      default:
        return {
          start: startOfMonth(date),
          end: endOfMonth(date)
        };
    }
  }, []);

  const navigatePeriod = useCallback((direction) => {
    setCurrentPeriod(prev => {
      switch (direction) {
        case 'prev':
          switch (viewMode) {
            case 'week':
              return addWeeks(prev, -1);
            case 'month':
              return addMonths(prev, -1);
            case 'year':
              return addYears(prev, -1);
            default:
              return prev;
          }
        case 'next':
          switch (viewMode) {
            case 'week':
              return addWeeks(prev, 1);
            case 'month':
              return addMonths(prev, 1);
            case 'year':
              return addYears(prev, 1);
            default:
              return prev;
          }
        case 'today':
          return new Date();
        default:
          return prev;
      }
    });
  }, [viewMode]);

  const filteredEvents = useMemo(() => {
    const bounds = getPeriodBounds(currentPeriod, viewMode);
    
    return events.filter(event => {
      const eventStart = new Date(event.dateRange.start);
      const eventEnd = new Date(event.dateRange.end);
      
      // Check if event overlaps with current period
      return isWithinInterval(eventStart, bounds) || 
             isWithinInterval(eventEnd, bounds) ||
             (eventStart <= bounds.start && eventEnd >= bounds.end);
    }).sort((a, b) => new Date(a.dateRange.start) - new Date(b.dateRange.start));
  }, [events, currentPeriod, viewMode, getPeriodBounds]);

  const periodStats = useMemo(() => {
    return {
      totalEvents: filteredEvents.length,
      activeEvents: filteredEvents.filter(e => e.status === 'active').length,
      planningEvents: filteredEvents.filter(e => e.status === 'planning').length,
      completedEvents: filteredEvents.filter(e => e.status === 'completed').length
    };
  }, [filteredEvents]);

  return {
    currentPeriod,
    viewMode,
    setViewMode,
    navigatePeriod,
    filteredEvents,
    periodStats,
    getPeriodBounds
  };
};
🔗 10. Хук интеграций — hooks/useIntegrations.js
import { useState, useCallback } from 'react';

export const useIntegrations = () => {
  const [loading, setLoading] = useState(false);
  const [availableRoutes] = useState([
    { id: 'route1', name: 'Маршрут по Карелии', distance: '45 км' },
    { id: 'route2', name: 'Восхождение на Эльбрус', distance: '12 км' },
    { id: 'route3', name: 'Поход по Алтаю', distance: '78 км' }
  ]);

  const createMapMarker = useCallback(async (location) => {
    // Integration with map module
    console.log('Creating map marker:', location);
    return `marker_${Date.now()}`;
  }, []);

  const createChatRoom = useCallback(async (eventData) => {
    // Integration with chat module
    console.log('Creating chat room for event:', eventData.title);
    return `chat_${Date.now()}`;
  }, []);

  const publishToActivity = useCallback(async (eventData) => {
    // Integration with activity feed
    console.log('Publishing to activity feed:', eventData.title);
    return true;
  }, []);

  const createBlogPost = useCallback(async (eventData) => {
    // Integration with blog module
    console.log('Creating blog post for:', eventData.title);
    return `blog_${Date.now()}`;
  }, []);

  const createIntegratedEvent = useCallback(async (eventData) => {
    setLoading(true);
    
    try {
      const integrations = {};

      // Create map marker
      if (eventData.location.address) {
        integrations.mapMarkerId = await createMapMarker(eventData.location);
      }

      // Create chat room
      integrations.chatRoomId = await createChatRoom(eventData);

      // Publish to activity feed
      await publishToActivity(eventData);

      // If event is completed, create blog post
      if (eventData.status === 'completed') {
        integrations.blogId = await createBlogPost(eventData);
      }

      return {
        ...eventData,
        integrations
      };
    } catch (error) {
      console.error('Integration error:', error);
      throw error;
    } finally {
      setLoading(false);
    }
  }, [createMapMarker, createChatRoom, publishToActivity, createBlogPost]);

  const openInModule = useCallback((moduleType, id) => {
    // This would trigger opening the module in the right panel
    switch (moduleType) {
      case 'chat':
        console.log('Opening chat room:', id);
        // window.postMessage({ type: 'OPEN_CHAT', chatId: id }, '*');
        break;
      case 'map':
        console.log('Opening map marker:', id);
        // window.postMessage({ type: 'OPEN_MAP', markerId: id }, '*');
        break;
      case 'route':
        console.log('Opening route planner:', id);
        // window.postMessage({ type: 'OPEN_ROUTE', routeId: id }, '*');
        break;
      case 'blog':
        console.log('Opening blog post:', id);
        // window.postMessage({ type: 'OPEN_BLOG', blogId: id }, '*');
        break;
      default:
        console.warn('Unknown module type:', moduleType);
    }
  }, []);

  return {
    loading,
    availableRoutes,
    createIntegratedEvent,
    openInModule,
    createMapMarker,
    createChatRoom,
    publishToActivity,
    createBlogPost
  };
};
🛠️ 11. Утилиты — utils/dateUtils.js
import { format, formatDistanceToNow, isToday, isTomorrow, isYesterday } from 'date-fns';
import { ru } from 'date-fns/locale';

export const formatDateRange = (dateRange) => {
  const start = new Date(dateRange.start);
  const end = new Date(dateRange.end);
  
  const startDate = format(start, 'd MMM', { locale: ru });
  const endDate = format(end, 'd MMM yyyy', { locale: ru });
  
  if (format(start, 'yyyy-MM-dd') === format(end, 'yyyy-MM-dd')) {
    return format(start, 'd MMMM yyyy', { locale: ru });
  }
  
  return `${startDate} - ${endDate}`;
};

export const formatRelativeTime = (date) => {
  const targetDate = new Date(date);
  
  if (isToday(targetDate)) {
    return 'Сегодня';
  }
  
  if (isTomorrow(targetDate)) {
    return 'Завтра';
  }
  
  if (isYesterday(targetDate)) {
    return 'Вчера';
  }
  
  return formatDistanceToNow(targetDate, { 
    addSuffix: true, 
    locale: ru 
  });
};

export const getEventStatus = (event) => {
  const now = new Date();
  const start = new Date(event.dateRange.start);
  const end = new Date(event.dateRange.end);
  
  if (now < start) {
    return 'planning';
  } else if (now >= start && now <= end) {
    return 'active';
  } else {
    return 'completed';
  }
};

export const getDaysUntilEvent = (eventDate) => {
  const now = new Date();
  const event = new Date(eventDate);
  const diffTime = event - now;
  const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
  
  return diffDays;
};

export const getEventDuration = (dateRange) => {
  const start = new Date(dateRange.start);
  const end = new Date(dateRange.end);
  const diffTime = end - start;
  const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
  
  if (diffDays === 1) {
    return '1 день';
  } else if (diffDays < 5) {
    return `${diffDays} дня`;
  } else {
    return `${diffDays} дней`;
  }
};
🛠️ 12. Утилиты для работы с событиями — utils/eventUtils.js
export const generateEventId = () => {
  return `event_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
};

export const validateEventData = (eventData) => {
  const errors = [];
  
  if (!eventData.title || eventData.title.trim().length < 3) {
    errors.push('Название события должно содержать минимум 3 символа');
  }
  
  if (!eventData.description || eventData.description.trim().length < 10) {
    errors.push('Описание должно содержать минимум 10 символов');
  }
  
  if (!eventData.dateRange.start) {
    errors.push('Укажите дату начала события');
  }
  
  if (!eventData.dateRange.end) {
    errors.push('Укажите дату окончания события');
  }
  
  if (eventData.dateRange.start && eventData.dateRange.end) {
    const start = new Date(eventData.dateRange.start);
    const end = new Date(eventData.dateRange.end);
    
    if (start >= end) {
      errors.push('Дата окончания должна быть позже даты начала');
    }
    
    if (start < new Date()) {
      errors.push('Дата начала не может быть в прошлом');
    }
  }
  
  if (!eventData.location.address || eventData.location.address.trim().length < 3) {
    errors.push('Укажите место проведения события');
  }
  
  if (eventData.maxCapacity < 2 || eventData.maxCapacity > 100) {
    errors.push('Количество участников должно быть от 2 до 100');
  }
  
  return errors;
};

export const calculateEventProgress = (event) => {
  const now = new Date();
  const start = new Date(event.dateRange.start);
  const end = new Date(event.dateRange.end);
  
  if (now < start) {
    // Event hasn't started - calculate preparation progress
    const createdAt = new Date(event.createdAt);
    const totalPrepTime = start - createdAt;
    const elapsedPrepTime = now - createdAt;
    
    return Math.min(Math.max((elapsedPrepTime / totalPrepTime) * 100, 0), 100);
  } else if (now >= start && now <= end) {
    // Event is active - calculate completion progress
    const totalEventTime = end - start;
    const elapsedEventTime = now - start;
    
    return Math.min(Math.max((elapsedEventTime / totalEventTime) * 100, 0), 100);
  } else {
    // Event is completed
    return 100;
  }
};

export const getEventPriority = (event) => {
  const daysUntil = getDaysUntilEvent(event.dateRange.start);
  const participantRatio = event.participants.members.length / event.participants.maxCapacity;
  
  if (daysUntil <= 3) return 'high';
  if (daysUntil <= 7 && participantRatio > 0.8) return 'high';
  if (daysUntil <= 14) return 'medium';
  return 'low';
};

export const canUserJoinEvent = (event, userId) => {
  const isAlreadyMember = event.participants.members.includes(userId);
  const isAtCapacity = event.participants.members.length >= event.participants.maxCapacity;
  const hasJoinRequest = event.participants.joinRequests.includes(userId);
  const isEventActive = ['planning', 'active'].includes(event.status);
  
  return {
    canJoin: !isAlreadyMember && !hasJoinRequest && isEventActive,
    needsApproval: isAtCapacity,
    reason: isAlreadyMember ? 'already_member' : 
            hasJoinRequest ? 'request_pending' :
            !isEventActive ? 'event_not_active' :
            isAtCapacity ? 'at_capacity' : 'can_join'
  };
};

export const getEventNotifications = (event, userId) => {
  const notifications = [];
  const now = new Date();
  const start = new Date(event.dateRange.start);
  const daysUntil = Math.ceil((start - now) / (1000 * 60 * 60 * 24));
  
  if (event.participants.members.includes(userId)) {
    if (daysUntil === 1) {
      notifications.push({
        type: 'reminder',
        message: 'Событие начинается завтра!',
        priority: 'high'
      });
    } else if (daysUntil === 7) {
      notifications.push({
        type: 'reminder',
        message: 'Событие начинается через неделю',
        priority: 'medium'
      });
    }
  }
  
  if (event.participants.organizer === userId) {
    const participantRatio = event.participants.members.length / event.participants.maxCapacity;
    
    if (participantRatio < 0.5 && daysUntil <= 14) {
      notifications.push({
        type: 'warning',
        message: 'Мало участников для события',
        priority: 'medium'
      });
    }
    
    if (event.participants.joinRequests.length > 0) {
      notifications.push({
        type: 'action',
        message: `${event.participants.joinRequests.length} новых заявок`,
        priority: 'high'
      });
    }
  }
  
  return notifications;
};
🎨 13. Стили — styles/EventsCalendar.css
/* Main Timeline Container */
.events-timeline {
  display: flex;
  flex-direction: column;
  height: 100%;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  border-radius: 20px;
  overflow: hidden;
  position: relative;
}

.events-timeline.fullscreen {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  z-index: 1000;
  border-radius: 0;
}

/* Header */
.timeline-header {
  background: rgba(255, 255, 255, 0.1);
  backdrop-filter: blur(20px);
  padding: 20px;
  border-bottom: 1px solid rgba(255, 255, 255, 0.2);
}

.header-controls {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
}

.header-controls h2 {
  color: white;
  font-size: 24px;
  font-weight: 600;
  margin: 0;
}

.header-actions {
  display: flex;
  gap: 12px;
}

.btn-archive, .btn-create {
  padding: 10px 16px;
  border: none;
  border-radius: 12px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.3s ease;
  backdrop-filter: blur(10px);
}

.btn-archive {
  background: rgba(255, 255, 255, 0.2);
  color: white;
}


.btn-create {
  background: linear-gradient(45deg, #ff6b6b, #ee5a24);
  color: white;
  box-shadow: 0 4px 15px rgba(238, 90, 36, 0.4);
}

.btn-archive:hover, .btn-create:hover {
  transform: translateY(-2px);
  box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
}

/* Timeline Navigation */
.timeline-navigation {
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex-wrap: wrap;
  gap: 16px;
}

.period-nav {
  display: flex;
  align-items: center;
  gap: 12px;
  background: rgba(255, 255, 255, 0.1);
  padding: 8px 16px;
  border-radius: 12px;
  backdrop-filter: blur(10px);
}

.nav-btn {
  background: none;
  border: none;
  color: white;
  font-size: 16px;
  padding: 8px 12px;
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.nav-btn:hover {
  background: rgba(255, 255, 255, 0.2);
}

.nav-btn.today {
  background: rgba(255, 255, 255, 0.2);
  font-weight: 500;
}

.current-period {
  color: white;
  font-weight: 600;
  font-size: 16px;
  min-width: 200px;
  text-align: center;
}

.view-modes {
  display: flex;
  gap: 8px;
  background: rgba(255, 255, 255, 0.1);
  padding: 4px;
  border-radius: 12px;
  backdrop-filter: blur(10px);
}

.view-mode {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 8px 12px;
  border: none;
  background: none;
  color: rgba(255, 255, 255, 0.7);
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.2s ease;
  font-size: 14px;
}

.view-mode.active {
  background: rgba(255, 255, 255, 0.2);
  color: white;
}

.view-mode:hover {
  color: white;
  background: rgba(255, 255, 255, 0.1);
}

.quick-filters {
  display: flex;
  gap: 8px;
}

.filter-btn {
  padding: 6px 12px;
  border: 1px solid rgba(255, 255, 255, 0.3);
  background: none;
  color: rgba(255, 255, 255, 0.7);
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.2s ease;
  font-size: 12px;
}

.filter-btn.active, .filter-btn:hover {
  background: rgba(255, 255, 255, 0.2);
  color: white;
}

/* Timeline Content */
.timeline-content {
  flex: 1;
  padding: 20px;
  overflow-y: auto;
  position: relative;
}

.timeline-track {
  position: relative;
  max-width: 800px;
  margin: 0 auto;
}

.timeline-item {
  display: flex;
  align-items: flex-start;
  margin-bottom: 30px;
  position: relative;
}

.timeline-item::before {
  content: '';
  position: absolute;
  left: 80px;
  top: 20px;
  bottom: -30px;
  width: 2px;
  background: linear-gradient(to bottom, rgba(255, 255, 255, 0.3), transparent);
}

.timeline-item:last-child::before {
  display: none;
}

.timeline-date {
  width: 70px;
  text-align: right;
  color: rgba(255, 255, 255, 0.8);
  font-size: 12px;
  font-weight: 500;
  padding-top: 8px;
  position: relative;
}

.timeline-date::after {
  content: '';
  position: absolute;
  right: -11px;
  top: 12px;
  width: 8px;
  height: 8px;
  background: white;
  border-radius: 50%;
  box-shadow: 0 0 0 3px rgba(255, 255, 255, 0.3);
}

/* Event Card */
.event-card {
  flex: 1;
  margin-left: 30px;
  background: rgba(255, 255, 255, 0.95);
  border-radius: 16px;
  padding: 20px;
  cursor: pointer;
  transition: all 0.3s ease;
  position: relative;
  overflow: hidden;
  backdrop-filter: blur(20px);
  border: 1px solid rgba(255, 255, 255, 0.2);
}

.event-card::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 4px;
  background: var(--status-color);
}

.event-card.planning {
  border-left: 4px solid #3B82F6;
}

.event-card.active {
  border-left: 4px solid #10B981;
  box-shadow: 0 0 20px rgba(16, 185, 129, 0.3);
}

.event-card.completed {
  border-left: 4px solid #8B5CF6;
}

.card-status {
  display: flex;
  align-items: center;
  gap: 6px;
  margin-bottom: 12px;
  font-size: 12px;
  font-weight: 500;
  color: var(--status-color);
}

.status-icon {
  font-size: 14px;
}

.card-content {
  position: relative;
}

.card-header {
  margin-bottom: 12px;
}

.event-title {
  font-size: 18px;
  font-weight: 600;
  color: #1a1a1a;
  margin: 0 0 4px 0;
  line-height: 1.3;
}

.event-dates {
  font-size: 12px;
  color: #666;
  font-weight: 500;
}

.card-body {
  margin-bottom: 16px;
}

.event-description {
  color: #4a4a4a;
  font-size: 14px;
  line-height: 1.5;
  margin-bottom: 12px;
}

.event-location, .route-preview {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 12px;
  color: #666;
  margin-bottom: 8px;
}

.location-icon, .route-icon {
  font-size: 14px;
}

.preparation-progress {
  margin-top: 12px;
}

.progress-label {
  font-size: 12px;
  color: #666;
  margin-bottom: 4px;
}

.progress-bar {
  height: 4px;
  background: #e5e7eb;
  border-radius: 2px;
  overflow: hidden;
}

.progress-fill {
  height: 100%;
  background: linear-gradient(90deg, #3B82F6, #10B981);
  border-radius: 2px;
  transition: width 0.3s ease;
}

.card-actions {
  position: absolute;
  top: 16px;
  right: 16px;
  display: flex;
  gap: 8px;
}

.action-btn {
  padding: 6px 12px;
  border: none;
  border-radius: 8px;
  font-size: 12px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;
}

.action-btn.join {
  background: #10B981;
  color: white;
}

.action-btn.leave {
  background: #ef4444;
  color: white;
}

.action-btn.chat {
  background: #3B82F6;
  color: white;
}

.action-btn:hover {
  transform: translateY(-1px);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
}

.activity-indicator {
  position: absolute;
  top: 12px;
  left: 12px;
  width: 8px;
  height: 8px;
}

.activity-pulse {
  width: 100%;
  height: 100%;
  background: #10B981;
  border-radius: 50%;
  animation: pulse 2s infinite;
}

@keyframes pulse {
  0% {
    transform: scale(0.95);
    box-shadow: 0 0 0 0 rgba(16, 185, 129, 0.7);
  }
  70% {
    transform: scale(1);
    box-shadow: 0 0 0 10px rgba(16, 185, 129, 0);
  }
  100% {
    transform: scale(0.95);
    box-shadow: 0 0 0 0 rgba(16, 185, 129, 0);
  }
}

/* Participants Panel */
.participants-compact {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-top: 12px;
}

.participants-avatars {
  display: flex;
  align-items: center;
  gap: -8px;
}

.participant-avatar {
  width: 32px;
  height: 32px;
  border-radius: 50%;
  background: #f3f4f6;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 16px;
  border: 2px solid white;
  position: relative;
  margin-left: -8px;
}

.participant-avatar:first-child {
  margin-left: 0;
}

.participant-avatar.online::after {
  content: '';
  position: absolute;
  bottom: 0;
  right: 0;
  width: 8px;
  height: 8px;
  background: #10B981;
  border: 2px solid white;
  border-radius: 50%;
}

.organizer-badge {
  position: absolute;
  top: -4px;
  right: -4px;
  font-size: 10px;
  background: #fbbf24;
  border-radius: 50%;
  width: 16px;
  height: 16px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.more-participants {
  width: 32px;
  height: 32px;
  border-radius: 50%;
  background: #e5e7eb;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 10px;
  font-weight: 600;
  color: #6b7280;
  border: 2px solid white;
  margin-left: -8px;
}

.participants-count {
  font-size: 12px;
  color: #666;
  font-weight: 500;
}

/* Full Participants Panel */
.participants-panel {
  padding: 20px;
}

.panel-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
}

.panel-header h3 {
  margin: 0;
  font-size: 16px;
  font-weight: 600;
}

.btn-invite {
  padding: 8px 16px;
  background: #3B82F6;
  color: white;
  border: none;
  border-radius: 8px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.btn-invite:hover {
  background: #2563eb;
  transform: translateY(-1px);
}

.organizer-section, .members-section, .requests-section {
  margin-bottom: 24px;
}

.organizer-section h4, .members-section h4, .requests-section h4 {
  font-size: 14px;
  font-weight: 600;
  margin-bottom: 12px;
  color: #374151;
}

.participant-item {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 12px;
  border-radius: 12px;
  margin-bottom: 8px;
  transition: all 0.2s ease;
}

.participant-item:hover {
  background: #f9fafb;
}

.participant-item.organizer {
  background: linear-gradient(135deg, #fbbf24, #f59e0b);
  color: white;
}

.participant-info {
  display: flex;
  align-items: center;
  gap: 12px;
}

.participant-details {
  flex: 1;
}

.participant-name {
  font-weight: 500;
  font-size: 14px;
}

.participant-role, .participant-status {
  font-size: 12px;
  opacity: 0.8;
}

.participant-actions {
  display: flex;
  gap: 8px;
}

.action-btn {
  width: 32px;
  height: 32px;
  border: none;
  border-radius: 8px;
  background: rgba(0, 0, 0, 0.1);
  cursor: pointer;
  transition: all 0.2s ease;
  display: flex;
  align-items: center;
  justify-content: center;
}

.action-btn:hover {
  background: rgba(0, 0, 0, 0.2);
  transform: scale(1.1);
}

.action-btn.remove {
  background: #ef4444;
  color: white;
}

.show-more-btn {
  width: 100%;
  padding: 8px;
  border: 1px dashed #d1d5db;
  background: none;
  color: #6b7280;
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.show-more-btn:hover {
  background: #f9fafb;
  border-color: #9ca3af;
}

.capacity-warning {
  background: #fef3c7;
  color: #92400e;
  padding: 12px;
  border-radius: 8px;
  font-size: 12px;
  text-align: center;
  margin-top: 16px;
}

/* Empty State */
.empty-state {
  text-align: center;
  padding: 60px 20px;
  color: rgba(255, 255, 255, 0.8);
}

.empty-icon {
  font-size: 48px;
  margin-bottom: 16px;
}

.empty-state h3 {
  font-size: 20px;
  font-weight: 600;
  margin-bottom: 8px;
  color: white;
}

.empty-state p {
  font-size: 14px;
  margin-bottom: 24px;
  opacity: 0.8;
}

.btn-create-empty {
  padding: 12px 24px;
  background: linear-gradient(45deg, #ff6b6b, #ee5a24);
  color: white;
  border: none;
  border-radius: 12px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.3s ease;
}

.btn-create-empty:hover {
  transform: translateY(-2px);
  box-shadow: 0 8px 25px rgba(238, 90, 36, 0.4);
}

/* Loading Skeleton */
.timeline-skeleton {
  max-width: 800px;
  margin: 0 auto;
}

.skeleton-card {
  background: rgba(255, 255, 255, 0.1);
  border-radius: 16px;
  height: 200px;
  margin-bottom: 30px;
  position: relative;
  overflow: hidden;
}

.skeleton-card::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
  animation: skeleton-loading 1.5s infinite;
}

@keyframes skeleton-loading {
  0% { left: -100%; }
  100% { left: 100%; }
}

/* Modal Styles */
.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.5);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  backdrop-filter: blur(5px);
}

.event-creator-modal, .event-details-modal, .archive-modal {
  background: white;
  border-radius: 20px;
  max-width: 600px;
  width: 90%;
  max-height: 90vh;
  overflow: hidden;
  display: flex;
  flex-direction: column;
  box-shadow: 0 25px 50px rgba(0, 0, 0, 0.3);
}

.archive-modal {
  max-width: 1000px;
}

.modal-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 24px;
  border-bottom: 1px solid #e5e7eb;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
}

.modal-header h2 {
  margin: 0;
  font-size: 20px;
  font-weight: 600;
}

.header-left {
  display: flex;
  align-items: center;
  gap: 16px;
}

.btn-edit {
  padding: 6px 12px;
  background: rgba(255, 255, 255, 0.2);
  color: white;
  border: none;
  border-radius: 8px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.btn-edit:hover {
  background: rgba(255, 255, 255, 0.3);
}

.close-btn {
  background: none;
  border: none;
  color: white;
  font-size: 24px;
  cursor: pointer;
  padding: 4px;
  border-radius: 4px;
  transition: all 0.2s ease;
}

.close-btn:hover {
  background: rgba(255, 255, 255, 0.2);
}

.modal-content {
  flex: 1;
  overflow-y: auto;
  padding: 24px;
}

.modal-footer {
  display: flex;
  justify-content: space-between;
  padding: 20px 24px;
  border-top: 1px solid #e5e7eb;
  background: #f9fafb;
}

/* Steps Progress */
.steps-progress {
  display: flex;
  justify-content: space-between;
  padding: 20px 24px;
  background: #f9fafb;
  border-bottom: 1px solid #e5e7eb;
}

.step {
  display: flex;
  flex-direction: column;
  align-items: center;
  flex: 1;
  position: relative;
  opacity: 0.5;
  transition: all 0.3s ease;
}

.step.active {
  opacity: 1;
}

.step.current {
  opacity: 1;
  color: #3B82F6;
}

.step:not(:last-child)::after {
  content: '';
  position: absolute;
  top: 16px;
  left: 60%;
  right: -40%;
  height: 2px;
  background: #e5e7eb;
  z-index: 1;
}

.step.active:not(:last-child)::after {
  background: #3B82F6;
}

.step-icon {
  width: 32px;
  height: 32px;
  border-radius: 50%;
  background: #e5e7eb;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 16px;
  margin-bottom: 8px;
  position: relative;
  z-index: 2;
}

.step.active .step-icon {
  background: #3B82F6;
  color: white;
}

.step-title {
  font-size: 12px;
  font-weight: 500;
  text-align: center;
}

/* Form Styles */
.form-step {
  animation: slideIn 0.3s ease;
}

@keyframes slideIn {
  from {
    opacity: 0;
    transform: translateX(20px);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}

.form-group {
  margin-bottom: 20px;
}

.form-group label {
  display: block;
  font-weight: 500;
  margin-bottom: 6px;
  color: #374151;
  font-size: 14px;
}

.form-input, .form-textarea, .form-select {
  width: 100%;
  padding: 12px 16px;
  border: 2px solid #e5e7eb;
  border-radius: 12px;
  font-size: 14px;
  transition: all 0.2s ease;
  background: white;
}

.form-input:focus, .form-textarea:focus, .form-select:focus {
  outline: none;
  border-color: #3B82F6;
  box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
}

.form-textarea {
  resize: vertical;
  min-height: 100px;
}

.form-row {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 16px;
}

.tags-input {
  position: relative;
}

.tags-list {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  margin-top: 8px;
}

.tag {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  padding: 4px 8px;
  background: #e0e7ff;
  color: #3730a3;
  border-radius: 6px;
  font-size: 12px;
  font-weight: 500;
}

.tag button {
  background: none;
  border: none;
  color: #3730a3;
  cursor: pointer;
  font-size: 14px;
  padding: 0;
  margin-left: 4px;
}

.map-preview {
  height: 200px;
  background: #f3f4f6;
  border-radius: 12px;
  display: flex;
  align-items: center;
  justify-content: center;
  color: #6b7280;
  font-size: 14px;
  margin-top: 12px;
}

.participants-preview {
  background: #f9fafb;
  padding: 16px;
  border-radius: 12px;
  margin-top: 16px;
}

.participants-preview h4 {
  margin: 0 0 12px 0;
  font-size: 14px;
  color: #374151;
}

.invite-options {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.checkbox-label {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 14px;
  color: #4b5563;
  cursor: pointer;
}

.checkbox-label input[type="checkbox"] {
  width: 16px;
  height: 16px;
}

.integration-option {
  background: #f9fafb;
  padding: 16px;
  border-radius: 12px;
  margin-bottom: 12px;
  border: 2px solid transparent;
  transition: all 0.2s ease;
}

.integration-option:hover {
  border-color: #e5e7eb;
}

.integration-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 8px;
}

.integration-header span {
  display: flex;
  align-items: center;
  gap: 8px;
  font-weight: 500;
  color: #374151;
}

.integration-icon {
  font-size: 18px;
}

.integration-option p {
  margin: 0;
  font-size: 12px;
  color: #6b7280;
}

/* Button Styles */
.btn-primary, .btn-secondary {
  padding: 12px 24px;
  border: none;
  border-radius: 12px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;
  font-size: 14px;
}

.btn-primary {
  background: linear-gradient(45deg, #3B82F6, #1d4ed8);
  color: white;
}

.btn-primary:hover:not(:disabled) {
  transform: translateY(-1px);
  box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
}

.btn-primary:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.btn-secondary {
  background: #f3f4f6;
  color: #374151;
  border: 1px solid #d1d5db;
}

.btn-secondary:hover {
  background: #e5e7eb;
}

/* Action Bar */
.action-bar {
  display: flex;
  gap: 12px;
  padding: 16px 24px;
  background: #f9fafb;
  border-bottom: 1px solid #e5e7eb;
}

.btn-join, .btn-leave, .btn-share, .btn-favorite {
  padding: 10px 16px;
  border: none;
  border-radius: 10px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;
  font-size: 14px;
}

.btn-join {
  background: linear-gradient(45deg, #10B981, #059669);
  color: white;
}

.btn-leave {
  background: linear-gradient(45deg, #ef4444, #dc2626);
  color: white;
}

.btn-share, .btn-favorite {
  background: #f3f4f6;
  color: #374151;
  border: 1px solid #d1d5db;
}

.btn-join:hover, .btn-leave:hover, .btn-share:hover, .btn-favorite:hover {
  transform: translateY(-1px);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
}

/* Tabs */
.tabs-container {
  flex: 1;
  display: flex;
  flex-direction: column;
}

.tabs-nav {
  display: flex;
  background: #f9fafb;
  border-bottom: 1px solid #e5e7eb;
  overflow-x: auto;
}

.tab-btn {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 16px 20px;
  border: none;
  background: none;
  color: #6b7280;
  cursor: pointer;
  transition: all 0.2s ease;
  border-bottom: 2px solid transparent;
  white-space: nowrap;
  font-size: 14px;
}

.tab-btn.active {
  color: #3B82F6;
  border-bottom-color: #3B82F6;
  background: white;
}

.tab-btn:hover {
  color: #374151;
  background: rgba(0, 0, 0, 0.02);
}

.tabs-content {
  flex: 1;
  overflow-y: auto;
}

.tab-content {
  padding: 24px;
}

/* Event Details Content */
.event-header-details {
  margin-bottom: 24px;
}

.event-header-details h1 {
  font-size: 24px;
  font-weight: 600;
  margin: 0 0 8px 0;
  color: #1a1a1a;
}

.event-meta {
  display: flex;
  flex-wrap: wrap;
  gap: 16px;
  font-size: 14px;
  color: #6b7280;
}

.event-meta span {
  display: flex;
  align-items: center;
  gap: 4px;
}

.event-status {
  padding: 4px 8px;
  border-radius: 6px;
  font-weight: 500;
  font-size: 12px;
}

.event-status.planning {
  background: #dbeafe;
  color: #1e40af;
}

.event-status.active {
  background: #d1fae5;
  color: #065f46;
}

.event-status.completed {
  background: #e0e7ff;
  color: #3730a3;
}

.event-description {
  margin-bottom: 24px;
}

.event-description h3 {
  font-size: 16px;
  font-weight: 600;
  margin-bottom: 8px;
  color: #374151;
}

.event-description p {
  color: #4b5563;
  line-height: 1.6;
}

.event-details-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 16px;
  margin-bottom: 24px;
}

.detail-card {
  background: #f9fafb;
  padding: 16px;
  border-radius: 12px;
  border: 1px solid #e5e7eb;
}

.detail-card h4 {
  font-size: 14px;
  font-weight: 600;
  margin: 0 0 4px 0;
  color: #374151;
}

.detail-card p {
  margin: 0;
  color: #6b7280;
  font-size: 14px;
}

.event-tags h4 {
  font-size: 16px;
  font-weight: 600;
  margin-bottom: 12px;
  color: #374151;
}

.preparation-status {
  background: #f0f9ff;
  padding: 20px;
  border-radius: 12px;
  border: 1px solid #bae6fd;
  margin-top: 24px;
}

.preparation-status h4 {
  font-size: 16px;
  font-weight: 600;
  margin-bottom: 12px;
  color: #0c4a6e;
}

.preparation-checklist {
  margin-top: 16px;
}

.checklist-item {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px 0;
  font-size: 14px;
}

.checklist-item.completed {
  color: #059669;
}

/* Integration Content */
.chat-integration, .route-integration, .blog-integration {
  text-align: center;
  padding: 40px 20px;
}

.chat-preview, .route-preview, .blog-preview, .no-route, .create-blog, .blog-placeholder {
  background: #f9fafb;
  padding: 24px;
  border-radius: 12px;
  border: 1px solid #e5e7eb;
}

.route-stats {
  display: flex;
  justify-content: space-around;
  margin: 16px 0;
  padding: 16px;
  background: white;
  border-radius: 8px;
}

.stat {
  font-size: 14px;
  color: #4b5563;
}

.blog-card {
  background: white;
  padding: 20px;
  border-radius: 12px;
  margin-bottom: 16px;
  text-align: left;
}

.blog-card h4 {
  font-size: 16px;
  font-weight: 600;
  margin-bottom: 8px;
  color: #1a1a1a;
}

.blog-stats {
  display: flex;
  gap: 16px;
  margin-top: 12px;
  font-size: 12px;
  color: #6b7280;
}

/* Archive Styles */
.archive-controls {
  display: flex;
  gap: 16px;
  align-items: center;
  padding: 20px 24px;
  background: #f9fafb;
  border-bottom: 1px solid #e5e7eb;
  flex-wrap: wrap;
}

.year-selector, .sort-selector {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 14px;
}

.year-selector label, .sort-selector label {
  font-weight: 500;
  color: #374151;
}

.search-box {
  flex: 1;
  min-width: 200px;
}

.archive-stats {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
  gap: 16px;
  padding: 20px 24px;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
}

.stat-card {
  text-align: center;
  padding: 16px;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 12px;
  backdrop-filter: blur(10px);
}

.stat-number {
  font-size: 24px;
  font-weight: 700;
  margin-bottom: 4px;
}

.stat-label {
  font-size: 12px;
  opacity: 0.9;
}

.archive-content {
  flex: 1;
  overflow-y: auto;
  padding: 24px;
}

.empty-archive {
  text-align: center;
  padding: 60px 20px;
  color: #6b7280;
}

.empty-archive .empty-icon {
  font-size: 48px;
  margin-bottom: 16px;
}

.empty-archive h3 {
  font-size: 18px;
  font-weight: 600;
  margin-bottom: 8px;
  color: #374151;
}

.archive-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
  gap: 20px;
}

.archive-card {
  background: white;
  border-radius: 16px;
  padding: 20px;
  border: 1px solid #e5e7eb;
  transition: all 0.3s ease;
  position: relative;
  overflow: hidden;
}

.archive-card .card-header {
  margin-bottom: 16px;
}

.archive-card .card-header h3 {
  font-size: 16px;
  font-weight: 600;
  margin: 0 0 4px 0;
  color: #1a1a1a;
}

.archive-card .event-date {
  font-size: 12px;
  color: #6b7280;
}

.archive-card .card-content {
  margin-bottom: 16px;
}

.archive-card .event-description {
  font-size: 14px;
  color: #4b5563;
  line-height: 1.5;
  margin-bottom: 12px;
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
  overflow: hidden;
}

.archive-card .event-meta {
  display: flex;
  flex-direction: column;
  gap: 6px;
  margin-bottom: 12px;
}

.archive-card .meta-item {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 12px;
  color: #6b7280;
}

.meta-icon {
  font-size: 14px;
}

.archive-card .event-tags {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
}

.archive-card .tag {
  padding: 2px 6px;
  background: #f3f4f6;
  color: #4b5563;
  border-radius: 4px;
  font-size: 10px;
}

.archive-card .tag.more {
  background: #e5e7eb;
  color: #6b7280;
}

.archive-card .card-footer {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-top: 16px;
  padding-top: 16px;
  border-top: 1px solid #f3f4f6;
}

.integrations {
  display: flex;
  gap: 8px;
}

.integration-badge {
  font-size: 16px;
  opacity: 0.7;
  transition: all 0.2s ease;
}

.integration-badge:hover {
  opacity: 1;
  transform: scale(1.2);
}

.card-actions {
  display: flex;
  gap: 8px;
}

.btn-recreate, .btn-view {
  padding: 6px 12px;
  border: none;
  border-radius: 8px;
  font-size: 12px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;
}

.btn-recreate {
  background: #10B981;
  color: white;
}

.btn-view {
  background: #f3f4f6;
  color: #374151;
  border: 1px solid #d1d5db;
}

.btn-recreate:hover, .btn-view:hover {
  transform: translateY(-1px);
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
}

.success-indicator {
  position: absolute;
  top: 12px;
  right: 12px;
}

.success-score {
  background: rgba(16, 185, 129, 0.1);
  color: #059669;
  padding: 4px 8px;
  border-radius: 6px;
  font-size: 10px;
  font-weight: 600;
}

.view-toggle {
  display: flex;
  justify-content: center;
  gap: 8px;
  padding: 16px 24px;
  background: #f9fafb;
  border-top: 1px solid #e5e7eb;
}

.toggle-btn {
  padding: 8px 16px;
  border: 1px solid #d1d5db;
  background: white;
  color: #6b7280;
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.2s ease;
  font-size: 12px;
}

.toggle-btn.active {
  background: #3B82F6;
  color: white;
  border-color: #3B82F6;
}

.toggle-btn:hover {
  border-color: #9ca3af;
}

/* Responsive Design */
@media (max-width: 768px) {
  .timeline-header {
    padding: 16px;
  }
  
  .header-controls {
    flex-direction: column;
    gap: 16px;
    align-items: stretch;
  }
  
  .header-actions {
    justify-content: center;
  }
  
  .timeline-navigation {
    flex-direction: column;
    gap: 12px;
  }
  
  .period-nav {
    justify-content: center;
  }
  
  .view-modes {
    justify-content: center;
  }
  
  .timeline-content {
    padding: 16px;
  }
  
  .timeline-item {
    flex-direction: column;
    align-items: stretch;
  }
  
  .timeline-item::before {
    display: none;
  }
  
  .timeline-date {
    width: auto;
    text-align: left;
    margin-bottom: 8px;
  }
  
  .timeline-date::after {
    display: none;
  }
  
  .event-card {
    margin-left: 0;
  }
  
  .form-row {
    grid-template-columns: 1fr;
  }
  
  .archive-controls {
    flex-direction: column;
    align-items: stretch;
  }
  
  .archive-grid {
    grid-template-columns: 1fr;
  }
  
  .event-details-grid {
    grid-template-columns: 1fr;
  }
  
  .tabs-nav {
    justify-content: center;
  }
  
  .tab-btn {
    flex: 1;
    justify-content: center;
  }
}

@media (max-width: 480px) {
  .event-creator-modal, .event-details-modal, .archive-modal {
    width: 95%;
    margin: 10px;
  }
  
  .modal-header {
    padding: 16px;
  }
  
  .modal-content {
    padding: 16px;
  }
  
  .steps-progress {
    padding: 16px;
  }
  
  .step-title {
    display: none;
  }
  
  .participants-avatars {
    gap: -4px;
  }
  
  .participant-avatar {
    width: 28px;
    height: 28px;
    font-size: 14px;
    margin-left: -4px;
  }
  
  .more-participants {
    width: 28px;
    height: 28px;
    margin-left: -4px;
  }
}

/* Dark Mode Support */
@media (prefers-color-scheme: dark) {
  .event-card {
    background: rgba(30, 30, 30, 0.95);
    color: #e5e7eb;
  }
  
  .event-title {
    color: #f9fafb;
  }
  
  .event-description {
    color: #d1d5db;
  }
  
  .detail-card {
    background: #374151;
    border-color: #4b5563;
  }
  
  .detail-card h4 {
    color: #f9fafb;
  }
  
  .detail-card p {
    color: #d1d5db;
  }
  
  .archive-card {
    background: #1f2937;
    border-color: #374151;
  }
  
  .archive-card .card-header h3 {
    color: #f9fafb;
  }
  
  .archive-card .event-description {
    color: #d1d5db;
  }
}

/* Print Styles */
@media print {
  .events-timeline {
    background: white !important;
    color: black !important;
  }
  
  .timeline-header {
    background: white !important;
    color: black !important;
  }
  
  .event-card {
    background: white !important;
    border: 1px solid #ccc !important;
    box-shadow: none !important;
  }
  
  .card-actions, .action-bar, .close-btn {
    display: none !important;
  }
}
🚀 14. Основной экспортный файл — index.js
// src/components/EventsCalendar/index.js
export { default as EventsTimeline } from './EventsTimeline';
export { default as EventCard } from './EventCard';
export { default as EventCreator } from './EventCreator';
export { default as EventDetails } from './EventDetails';
export { default as ParticipantsPanel } from './ParticipantsPanel';
export { default as EventArchive } from './EventArchive';

// Hooks
export { useEventState } from './hooks/useEventState';
export { useTimelineNavigation } from './hooks/useTimelineNavigation';
export { useIntegrations } from './hooks/useIntegrations';

// Utils
export * from './utils/dateUtils';
export * from './utils/eventUtils';
📦 15. Зависимости в Package.json
{
  "dependencies": {
    "framer-motion": "^10.16.4",
    "date-fns": "^2.30.0",
    "uuid": "^9.0.1"
  }
}
🎯 16. Пример использования в вашем проекте

// App.js или ваш основной компонент
import React, { useState } from 'react';
import { EventsTimeline } from './components/EventsCalendar';
import './components/EventsCalendar/styles/EventsCalendar.css';

const App = () => {
  const [leftPanelContent, setLeftPanelContent] = useState('calendar');
  const [rightPanelContent, setRightPanelContent] = useState('activity');
  const [isFullScreen, setIsFullScreen] = useState(false);

  return (
    <div className="app-container">
      {/* Двухоконная структура */}
      <div className="panels-container">
        {/* Левая панель - технические разделы */}
        <div className="left-panel">
          {leftPanelContent === 'calendar' && (
            <EventsTimeline 
              isFullScreen={isFullScreen}
              onFullScreenToggle={setIsFullScreen}
            />
          )}
          {leftPanelContent === 'map' && (
            <div>Компонент карты</div>
          )}
          {leftPanelContent === 'planner' && (
            <div>Компонент планировщика</div>
          )}
        </div>

        {/* Правая панель - коммуникационные разделы */}
        {!isFullScreen && (
          <div className="right-panel">
            {rightPanelContent === 'activity' && (
              <div>Лента активности</div>
            )}
            {rightPanelContent === 'chat' && (
              <div>Чаты</div>
            )}
            {rightPanelContent === 'blog' && (
              <div>Блоги</div>
            )}
          </div>
        )}
      </div>

      {/* Навигация между разделами */}
      <div className="navigation-bar">
        <div className="nav-section">
          <h4>Технические</h4>
          <button 
            className={leftPanelContent === 'calendar' ? 'active' : ''}
            onClick={() => setLeftPanelContent('calendar')}
          >
            📅 События
          </button>
          <button 
            className={leftPanelContent === 'map' ? 'active' : ''}
            onClick={() => setLeftPanelContent('map')}
          >
            🗺️ Карта
          </button>
          <button 
            className={leftPanelContent === 'planner' ? 'active' : ''}
            onClick={() => setLeftPanelContent('planner')}
          >
            🛣️ Планировщик
          </button>
        </div>

        <div className="nav-section">
          <h4>Общение</h4>
          <button 
            className={rightPanelContent === 'activity' ? 'active' : ''}
            onClick={() => setRightPanelContent('activity')}
          >
            📱 Лента
          </button>
          <button 
            className={rightPanelContent === 'chat' ? 'active' : ''}
            onClick={() => setRightPanelContent('chat')}
          >
            💬 Чаты
          </button>
          <button 
            className={rightPanelContent === 'blog' ? 'active' : ''}
            onClick={() => setRightPanelContent('blog')}
          >
            📝 Блоги
          </button>
        </div>
      </div>
    </div>
  );
};

export default App;
🎨 17. Стили для основного приложения
/* App.css */
.app-container {
  height: 100vh;
  display: flex;
  flex-direction: column;
  background: #f8fafc;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
}

.panels-container {
  flex: 1;
  display: flex;
  gap: 20px;
  padding: 20px;
  overflow: hidden;
}

.left-panel {
  flex: 1;
  min-width: 400px;
  background: white;
  border-radius: 20px;
  box-shadow: 0 10px 40px rgba(0, 0, 0, 0.1);
  overflow: hidden;
}

.right-panel {
  flex: 1;
  min-width: 400px;
  background: white;
  border-radius: 20px;
  box-shadow: 0 10px 40px rgba(0, 0, 0, 0.1);
  overflow: hidden;
  padding: 20px;
}

.navigation-bar {
  display: flex;
  justify-content: center;
  gap: 40px;
  padding: 16px 20px;
  background: white;
  border-top: 1px solid #e5e7eb;
  box-shadow: 0 -5px 20px rgba(0, 0, 0, 0.05);
}

.nav-section {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
}

.nav-section h4 {
  margin: 0;
  font-size: 12px;
  color: #6b7280;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.nav-section button {
  padding: 8px 16px;
  border: none;
  background: #f3f4f6;
  color: #4b5563;
  border-radius: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
  font-size: 12px;
  font-weight: 500;
  min-width: 100px;
}

.nav-section button.active {
  background: linear-gradient(45deg, #3B82F6, #1d4ed8);
  color: white;
  box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
}

.nav-section button:hover {
  transform: translateY(-1px);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
}

@media (max-width: 768px) {
  .panels-container {
    flex-direction: column;
    padding: 10px;
    gap: 10px;
  }
  
  .left-panel, .right-panel {
    min-width: auto;
  }
  
  .navigation-bar {
    flex-direction: column;
    gap: 20px;
  }
  
  .nav-section {
    flex-direction: row;
    flex-wrap: wrap;
    justify-content: center;
  }
}
🔧 18. Интеграционный сервис для связи
// src/services/integrationService.js
class IntegrationService {
  constructor() {
    this.listeners = new Map();
    this.setupMessageListener();
  }

  setupMessageListener() {
    window.addEventListener('message', (event) => {
      if (event.data.type && this.listeners.has(event.data.type)) {
        this.listeners.get(event.data.type).forEach(callback => {
          callback(event.data);
        });
      }
    });
  }

  // Подписка на события от других модулей
  subscribe(eventType, callback) {
    if (!this.listeners.has(eventType)) {
      this.listeners.set(eventType, []);
    }
    this.listeners.get(eventType).push(callback);
  }

  // Отправка события в другие модули
  emit(eventType, data) {
    window.postMessage({ type: eventType, ...data }, '*');
  }

  // Интеграция с картой
  createMapMarker(location, eventData) {
    this.emit('MAP_CREATE_MARKER', {
      location,
      eventData,
      markerId: `event_${eventData.id}`
    });
  }

  openMapLocation(markerId) {
    this.emit('MAP_OPEN_LOCATION', { markerId });
  }

  // Интеграция с чатами
  createEventChat(eventData) {
    this.emit('CHAT_CREATE_ROOM', {
      roomName: `${eventData.title} - Чат`,
      participants: eventData.participants.members,
      eventId: eventData.id,
      roomType: 'event'
    });
  }

  openEventChat(chatRoomId) {
    this.emit('CHAT_OPEN_ROOM', { roomId: chatRoomId });
  }

  // Интеграция с лентой активности
  publishEventActivity(eventData, activityType) {
    this.emit('ACTIVITY_PUBLISH', {
      type: activityType,
      eventId: eventData.id,
      title: eventData.title,
      description: eventData.description,
      participants: eventData.participants,
      timestamp: new Date().toISOString()
    });
  }

  // Интеграция с планировщиком маршрутов
  createEventRoute(eventData) {
    this.emit('PLANNER_CREATE_ROUTE', {
      eventId: eventData.id,
      startLocation: eventData.location,
      title: `Маршрут: ${eventData.title}`,
      dates: eventData.dateRange
    });
  }

  importRouteToEvent(routeId, eventId) {
    this.emit('PLANNER_EXPORT_ROUTE', { routeId, eventId });
  }

  // Интеграция с блогами
  createEventBlog(eventData) {
    this.emit('BLOG_CREATE_POST', {
      eventId: eventData.id,
      title: `Отчет: ${eventData.title}`,
      location: eventData.location,
      participants: eventData.participants,
      tags: eventData.metadata.tags
    });
  }

  openEventBlog(blogId) {
    this.emit('BLOG_OPEN_POST', { blogId });
  }
}

export const integrationService = new IntegrationService();
🎯 19. Обновлённый х
// src/components/EventsCalendar/hooks/useIntegrations.js (обновленная версия)
import { useState, useCallback, useEffect } from 'react';
import { integrationService } from '../../../services/integrationService';

export const useIntegrations = () => {
  const [loading, setLoading] = useState(false);
  const [availableRoutes, setAvailableRoutes] = useState([]);

  useEffect(() => {
    // Подписка на события от планировщика маршрутов
    integrationService.subscribe('PLANNER_ROUTES_LIST', (data) => {
      setAvailableRoutes(data.routes);
    });

    // Подписка на успешное создание чата
    integrationService.subscribe('CHAT_ROOM_CREATED', (data) => {
      console.log('Chat room created:', data.roomId);
    });

    // Подписка на создание метки на карте
    integrationService.subscribe('MAP_MARKER_CREATED', (data) => {
      console.log('Map marker created:', data.markerId);
    });

    // Запрос списка доступных маршрутов
    integrationService.emit('PLANNER_GET_ROUTES', {});
  }, []);

  const createIntegratedEvent = useCallback(async (eventData) => {
    setLoading(true);
    
    try {
      const integrations = {};

      // Создание метки на карте
      if (eventData.location.address) {
        integrationService.createMapMarker(eventData.location, eventData);
        integrations.mapMarkerId = `event_${eventData.id}`;
      }

      // Создание чат-комнаты
      integrationService.createEventChat(eventData);
      integrations.chatRoomId = `event_chat_${eventData.id}`;

      // Публикация в ленту активности
      integrationService.publishEventActivity(eventData, 'EVENT_CREATED');

      // Создание маршрута (если выбран)
      if (eventData.selectedRouteId) {
        integrationService.importRouteToEvent(eventData.selectedRouteId, eventData.id);
        integrations.routeId = eventData.selectedRouteId;
      }

      return {
        ...eventData,
        integrations
      };
    } catch (error) {
      console.error('Integration error:', error);
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  const openInModule = useCallback((moduleType, id, eventData) => {
    switch (moduleType) {
      case 'chat':
        integrationService.openEventChat(id);
        break;
      case 'map':
        integrationService.openMapLocation(id);
        break;
      case 'route':
        integrationService.emit('PLANNER_OPEN_ROUTE', { routeId: id });
        break;
      case 'blog':
        integrationService.openEventBlog(id);
        break;
      case 'activity':
        integrationService.emit('ACTIVITY_SHOW_EVENT', { eventId: eventData.id });
        break;
      default:
        console.warn('Unknown module type:', moduleType);
    }
  }, []);

  const createEventBlog = useCallback((eventData) => {
    integrationService.createEventBlog(eventData);
  }, []);

  return {
    loading,
    availableRoutes,
    createIntegratedEvent,
    openInModule,
    createEventBlog
  };
};
🚀 20. Заключительная инструкция по установке
# 1. Установите зависимости
npm install framer-motion date-fns uuid

# 2. Скопируйте все файлы в папку src/components/EventsCalendar/

# 3. Импортируйте стили в ваш main CSS файл
@import './components/EventsCalendar/styles/EventsCalendar.css';

# 4. Используйте компонент в вашем приложении
import { EventsTimeline } from './components/EventsCalendar';
✨ Готово!
Теперь у вас есть полностью функциональный и динамичный календарь событий с:

🎯 Временная шкала вместо класса
🎴 Анимированные карточки событий
👥 Система участников с ролями
🔗 Интеграция со всеми вашими модулями
📚 Архив событий с возможностью повтора
📱 Адаптивный дизайн для всех устройств
⚡ Живая анимация и эффекты
Календарь готов к внедрению в ваш проект уже сегодня! Все интеграции настроены через сервис сообщений, поэтому он легко подключится к вашим существующим модулям.