coderabbitai[bot] <notifications@github.com>
17:37 (4 –º–∏–Ω—É—Ç—ã –Ω–∞–∑–∞–¥)
–∫–æ–º—É: Simamakis/GeoBlogRF, –º–Ω–µ, Author

–ü–æ—Ö–æ–∂–µ, —á—Ç–æ —è–∑—ã–∫ –ø–∏—Å—å–º–∞: –∞–Ω–≥–ª–∏–π—Å–∫–∏–π
@coderabbitai[bot] commented on this pull request.

Actionable comments posted: 6

ü§ñ Fix all issues with AI agents
In `@frontend/src/components/Blog/SimplifiedMap.tsx`:
- Around line 218-223: The created marker (via mapFacade().createMarker) is
never added to the map so it remains invisible; after creating the icon with
mapFacade().createDivIcon and the marker with
mapFacade().createMarker([selectedMarker.latitude, selectedMarker.longitude], {
icon }), ensure you add the marker to the map by calling the appropriate facade
method (e.g., mapFacade().addMarker(marker) or mapFacade().addLayer(marker)
depending on our facade API) immediately after binding the popup
(marker.bindPopup?.(popupContent)); also preserve existing try/catch behavior
and handle any add-to-map errors similarly.

In `@frontend/src/components/Events/MiniEventMap.tsx`:
- Around line 39-113: The init async function can continue after the component
unmounts because the destroyed flag isn't checked after awaiting renderer.init;
update init (the function that calls await renderer.init(...)) to immediately
return if destroyed is true right after the await (before calling
renderer.getMap(), setting mapInstanceRef.current, assigning
clickHandlerRef/current handlers, or creating markers), and if destroyed is true
ensure rendererRef.current is cleaned up (call renderer.destroy()) and do not
attach map event listeners; this prevents race conditions between renderer.init,
the cleanup in the useEffect return, and subsequent operations that set
mapInstanceRef, markerRef, and clickHandlerRef.

In `@frontend/src/components/Maps/PostMap.tsx`:
- Around line 131-138: The useEffect that reads initializedRef.current is dead
code because refs don't trigger re-renders and the effect body contains only a
comment; remove the entire useEffect block (including the timer and cleanup)
from PostMap.tsx. If you intended to run logic when initialization changes,
replace initializedRef with a piece of state (e.g. isInitialized) or listen to
the proper initialization event and call mapFacade().getMap() where needed, but
otherwise delete the useEffect and its comment referencing mapRef/mapFacade to
avoid confusion.

In `@frontend/src/components/YandexMap/YandexMap.tsx`:
- Around line 515-522: The indentation around the map readiness check is
inconsistent; fix the formatting so the if/else block and nested timeout
callback are properly aligned and readable. Locate the resolveMapInstance() call
(mapInst), the conditional that checks mapInst && mapInst.geoObjects, the
updateMarkers() call, and the else branch that creates timeoutId and the inner
callback referencing destroyed and m; re-indent those lines so the else,
setTimeout callback, and inner if are nested consistently with the surrounding
code style.

In `@frontend/src/services/map_facade/MapContextFacade.ts`:
- Around line 65-74: The moveStart/zoomStart handlers are double-fired because
bindRendererEventHandlers adds a dispatcher that iterates
moveStartHandlers/zoomStartHandlers while onMapMoveStart/onMapZoomStart also
attach each wrapper directly to the renderer; refactor by extracting the
dispatcher callbacks (a single dispatcher function per event) as static
properties and ensure renderer-switch logic in bindRendererEventHandlers
detaches the dispatcher from the old renderer and attaches it to the new
renderer exactly once; change onMapMoveStart/onMapZoomStart to only create/store
the wrapper in moveStartHandlerMap/zoomStartHandlerMap and push the original
into moveStartHandlers/zoomStartHandlers (no direct renderer.attach there), and
update unsubscribe logic to remove wrappers from both the maps and the arrays so
each handler fires exactly once.

In `@patches/0002-refactor-mini-event-map.patch`:
- Around line 152-153: Typo in the inline comment near the map click
subscription should be fixed: change "L hander" to "L handler" in the comment
that accompanies the onMapClick fallback logic (the comment that starts with
"–ü–æ–¥–ø–∏—Å—ã–≤–∞–µ–º—Å—è –Ω–∞ –∫–ª–∏–∫–∏. –ï—Å–ª–∏ —Ä–µ–Ω–¥–µ—Ä–µ—Ä –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç onMapClick, –∏—Å–ø–æ–ª—å–∑—É–µ–º L
hander."). Update that comment text only; no code changes are required.
üßπ Nitpick comments (10)
frontend/tsconfig.tsbuildinfo (1)
1-1: Avoid committing tsbuildinfo artifacts.

Now that frontend/tsconfig.tsbuildinfo is ignored, it should be removed from version control to prevent stale build metadata from lingering in the repo. Consider deleting it and (optionally) adding it to .git/info/exclude for local use.

frontend/src/components/Map/useMapMarkers.tsx (1)
201-201: Consider splitting this dense one-liner for readability.

The nested try-catch blocks on a single line reduce debuggability. Breaking it apart would make the cleanup flow clearer.

‚ôªÔ∏è Suggested refactor for readability
-        try { if (markerClusterGroupRef.current) { try { mapFacade().removeLayer(markerClusterGroupRef.current); } catch (e) { } markerClusterGroupRef.current = null; } } catch (e) { }
+        try {
+          if (markerClusterGroupRef.current) {
+            try {
+              mapFacade().removeLayer(markerClusterGroupRef.current);
+            } catch (e) { /* ignore removal errors */ }
+            markerClusterGroupRef.current = null;
+          }
+        } catch (e) { /* ignore */ }
frontend/src/services/map_facade/adapters/__tests__/YandexPlannerRenderer.test.ts (1)
115-124: Incomplete test coverage for event registration.

The on/off test only verifies no errors are thrown but doesn't confirm the handler was actually registered/unregistered. Consider capturing registered handlers and asserting state changes.

üí° Suggested improvement
 it('on/off registers and unregisters events', async () => {
   const r = new YandexPlannerRenderer();
   await r.init('yandex-test-container');
   const handler = vi.fn();
   r.on('click', handler);
-  // simulate event firing through ymaps.events implementation not available here; check wrappers stored
-  // We don't have direct access to handlers object, but ensure no error on off
+  // Verify handler is stored internally
+  const map = r.getMap() as any;
+  // Trigger the event to verify registration
+  // Note: Would need to expose handlers in fake Map for full verification
   r.off('click', handler);
-  // should not throw
+  // Verify handler was removed - second off should be a no-op
+  expect(() => r.off('click', handler)).not.toThrow();
 });
frontend/src/components/Maps/PostMap.tsx (2)
300-302: High-frequency polling may cause performance issues.

A 16ms interval (~60fps) alongside MutationObserver and facade move/zoom events creates redundant update triggers. Consider removing the interval since the other mechanisms should suffice.

‚ö° Suggested optimization
-      const intervalId = setInterval(() => {
-        if (miniPopup && miniPopup.markerElement) updatePosition();
-      }, 16);

       return () => {
         try { mapFacade().offMapMove(updatePosition); } catch (e) { }
         try { mapFacade().offMapZoom(updatePosition); } catch (e) { }
         observer.disconnect();
-        clearInterval(intervalId);
         if (rafId) cancelAnimationFrame(rafId);
       };
343-345: Same high-frequency polling concern applies here.

Consider removing this interval as well for consistency.

frontend/src/components/Events/MiniEventMap.tsx (2)
146-146: Unnecessary dependency in useEffect.

The effect uses onMarkerPositionChangeRef.current (a ref) but lists onMarkerPositionChange as a dependency. Since the ref pattern is specifically to avoid re-running the effect when the callback changes, this dependency is redundant.

‚ôªÔ∏è Suggested fix
-  }, [markerPosition, onMarkerPositionChange]);
+  }, [markerPosition]);
149-151: Terse nested try/catch reduces readability.

Consider spreading this across multiple lines for clarity.

üìñ Suggested improvement
   // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ü–µ–Ω—Ç—Ä–∞ –∫–∞—Ä—Ç—ã
   useEffect(() => {
-    try { rendererRef.current?.setView(center, zoom); } catch (e) { try { mapInstanceRef.current?.setView(center, zoom); } catch (err) { } }
+    try {
+      rendererRef.current?.setView(center, zoom);
+    } catch (e) {
+      try { mapInstanceRef.current?.setView(center, zoom); } catch (err) { /* ignore */ }
+    }
   }, [center, zoom]);
frontend/src/components/Map/Map.tsx (1)
949-956: Type annotation inconsistency with any declaration.

Line 949 uses L.Layer type but L is declared as any at Line 14, so this type annotation has no effect and may mislead readers.

üìù Suggested fix
-      mapFacade()?.eachLayer((layer: L.Layer) => {
+      mapFacade()?.eachLayer((layer: any) => {
         if ((layer as any).isRouteLayer) {
           try { mapFacade()?.removeLayer(layer); } catch (e) { }
         }
       });
frontend/src/components/YandexMap/YandexMap.tsx (1)
504-504: Extremely long line reduces readability.

This 200+ character line with nested try/catch blocks is difficult to read and maintain.

üìñ Suggested improvement
-            try { mapFacade().fitBounds({ southWest: [newBounds[0][1], newBounds[0][0]], northEast: [newBounds[1][1], newBounds[1][0]] }, { padding: 50 }); } catch (e) { const mapInst = resolveMapInstance(); try { mapInst?.setBounds(newBounds, { checkZoomRange: true, duration: 300 }); } catch (err) { /* ignore */ } }
+            try {
+              mapFacade().fitBounds(
+                { southWest: [newBounds[0][1], newBounds[0][0]], northEast: [newBounds[1][1], newBounds[1][0]] },
+                { padding: 50 }
+              );
+            } catch (e) {
+              const mapInst = resolveMapInstance();
+              try {
+                mapInst?.setBounds(newBounds, { checkZoomRange: true, duration: 300 });
+              } catch (err) { /* ignore */ }
+            }
frontend/src/services/map_facade/adapters/YandexPlannerRenderer.ts (1)
216-224: Fallback return value may cause silent failures.

Returning [0, 0] when the map isn't ready could cause confusing behavior downstream. Consider returning null or throwing to make the error explicit.

üí° Alternative approach
-  getCenter(): DomainGeoPoint {
-    if (!this.map) return [0, 0];
+  getCenter(): DomainGeoPoint | null {
+    if (!this.map) return null;
     try {
       const c = this.map.getCenter();
       return [c[0], c[1]];
     } catch (e) {
-      return [0, 0];
+      return null;
     }
   }
Note: This would require updating IMapRenderer interface and callers.

In frontend/src/components/Blog/SimplifiedMap.tsx:

> +        // Add marker via facade using createMarker and bind popup (avoids direct map API usage)
+        try {
+          const icon = mapFacade().createDivIcon({ className: 'simplified-marker-icon', html: '<div class="simplified-marker" />', iconSize: [34, 44], iconAnchor: [17, 44] });
+          const marker = mapFacade().createMarker([selectedMarker.latitude, selectedMarker.longitude], { icon });
+          try { marker.bindPopup?.(popupContent); } catch (e) { }
+        } catch (e) { }
‚ö†Ô∏è Potential issue | üü† Major

Marker created but not added to the map.

The marker is created via createMarker and popup is bound, but the marker is never added to the map. This will result in an invisible marker.

üêõ Proposed fix to add marker to map
         try {
           const icon = mapFacade().createDivIcon({ className: 'simplified-marker-icon', html: '<div class="simplified-marker" />', iconSize: [34, 44], iconAnchor: [17, 44] });
           const marker = mapFacade().createMarker([selectedMarker.latitude, selectedMarker.longitude], { icon });
           try { marker.bindPopup?.(popupContent); } catch (e) { }
+          try {
+            const map = mapFacade().getMap?.();
+            if (map) marker.addTo(map);
+            markersRef.current.push(marker);
+          } catch (e) { }
         } catch (e) { }
ü§ñ Prompt for AI Agents
In `@frontend/src/components/Blog/SimplifiedMap.tsx` around lines 218 - 223, The
created marker (via mapFacade().createMarker) is never added to the map so it
remains invisible; after creating the icon with mapFacade().createDivIcon and
the marker with mapFacade().createMarker([selectedMarker.latitude,
selectedMarker.longitude], { icon }), ensure you add the marker to the map by
calling the appropriate facade method (e.g., mapFacade().addMarker(marker) or
mapFacade().addLayer(marker) depending on our facade API) immediately after
binding the popup (marker.bindPopup?.(popupContent)); also preserve existing
try/catch behavior and handle any add-to-map errors similarly.
In frontend/src/components/Events/MiniEventMap.tsx:

> -    // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–ª–∏–∫–∞ –Ω–∞ –∫–∞—Ä—Ç—É
-    map.on('click', (e: L.LeafletMouseEvent) => {
-      const position: [number, number] = [e.latlng.lat, e.latlng.lng];
-      
-      // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é –º–∞—Ä–∫–µ—Ä–∞
-      if (markerRef.current) {
-        markerRef.current.setLatLng(e.latlng);
-      } else {
-        // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π –º–∞—Ä–∫–µ—Ä
-        const marker = L.marker(e.latlng, {
-          draggable: true,
-        }).addTo(map);
-        
-        marker.on('dragend', () => {
-          const pos = marker.getLatLng();
-          const newPosition: [number, number] = [pos.lat, pos.lng];
-          onMarkerPositionChange?.(newPosition);
-        });
-        
-        markerRef.current = marker;
+    let destroyed = false;
+
+    const renderer = new OSMMapRenderer();
+    rendererRef.current = renderer;
+
+    const containerEl = mapRef.current;
+    const containerId = containerEl.id || (containerEl.id = 'mini-event-map-' + Math.random().toString(36).slice(2, 9));
+
+    const init = async () => {
+      try {
+        await renderer.init(containerId, { center, zoom });
+        const map = renderer.getMap();
+        mapInstanceRef.current = map;
+
+        // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–ª–∏–∫–∞ –Ω–∞ –∫–∞—Ä—Ç—É —á–µ—Ä–µ–∑ renderer
+        const clickHandler = (e: any) => {
+          try {
+            const position: [number, number] = [e.latlng.lat, e.latlng.lng];
+
+            // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é –º–∞—Ä–∫–µ—Ä–∞
+            if (markerRef.current) {
+              try { markerRef.current.setLatLng(e.latlng); } catch (err) { }
+            } else {
+              // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π –º–∞—Ä–∫–µ—Ä –ª–æ–∫–∞–ª—å–Ω–æ
+              const marker = L.marker(e.latlng, {
+                draggable: true,
+              }).addTo(map);
+
+              marker.on('dragend', () => {
+                try {
+                  const pos = marker.getLatLng();
+                  const newPosition: [number, number] = [pos.lat, pos.lng];
+                  onMarkerPositionChangeRef.current?.(newPosition);
+                } catch (err) { }
+              });
+
+              markerRef.current = marker;
+            }
+
+            onMarkerPositionChangeRef.current?.(position);
+            onMapClickRef.current?.(position);
+          } catch (err) { }
+        };
+
+        // –ü–æ–¥–ø–∏—Å—ã–≤–∞–µ–º—Å—è –Ω–∞ –∫–ª–∏–∫–∏. –ï—Å–ª–∏ —Ä–µ–Ω–¥–µ—Ä–µ—Ä –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç onMapClick, –∏—Å–ø–æ–ª—å–∑—É–µ–º L handler.
+        try { renderer.onMapClick?.(clickHandler); } catch (e) { map.on('click', clickHandler); }
+        clickHandlerRef.current = clickHandler;
+      } catch (err) {
+        console.warn('[MiniEventMap] Failed to initialize renderer', err);
       }
-      
-      onMarkerPositionChange?.(position);
-      onMapClick?.(position);
-    });
+    };
+
+    init();
 
     return () => {
-      if (mapInstanceRef.current) {
-        mapInstanceRef.current.remove();
+      destroyed = true;
+      try {
+        const clickHandler = clickHandlerRef.current;
+        const map = mapInstanceRef.current;
+        if (map && clickHandler) {
+          try { map.off('click', clickHandler); } catch (e) { }
+        }
+
+        if (rendererRef.current) {
+          try { rendererRef.current.destroy(); } catch (e) { }
+          rendererRef.current = null;
+        }
+
         mapInstanceRef.current = null;
-      }
+        markerRef.current = null;
+      } catch (e) { }
     };
   }, []);
‚ö†Ô∏è Potential issue | üü° Minor

Async initialization race condition - destroyed flag not checked after await.

The destroyed flag is set in cleanup but never checked after await renderer.init(). If the component unmounts during initialization, the code continues executing and may cause errors.

üõ°Ô∏è Proposed fix
     const init = async () => {
       try {
         await renderer.init(containerId, { center, zoom });
+        if (destroyed) return;
         const map = renderer.getMap();
         mapInstanceRef.current = map;
üìù Committable suggestion
‚ÄºÔ∏è IMPORTANT
Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.

‚¨áÔ∏è Suggested change
-  useEffect(() => {
-    if (!mapRef.current || mapInstanceRef.current) return;
-
-    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–∞—Ä—Ç—ã
-    const map = L.map(mapRef.current, {
-      center,
-      zoom,
-      zoomControl: true,
-      attributionControl: false,
-    });
-
-    // –î–æ–±–∞–≤–ª—è–µ–º —Ç–∞–π–ª—ã OpenStreetMap
-    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
-      attribution: '¬© OpenStreetMap contributors',
-      maxZoom: 19,
-    }).addTo(map);
-
-    mapInstanceRef.current = map;
-
-    // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–ª–∏–∫–∞ –Ω–∞ –∫–∞—Ä—Ç—É
-    map.on('click', (e: L.LeafletMouseEvent) => {
-      const position: [number, number] = [e.latlng.lat, e.latlng.lng];
-      
-      // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é –º–∞—Ä–∫–µ—Ä–∞
-      if (markerRef.current) {
-        markerRef.current.setLatLng(e.latlng);
-      } else {
-        // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π –º–∞—Ä–∫–µ—Ä
-        const marker = L.marker(e.latlng, {
-          draggable: true,
-        }).addTo(map);
-        
-        marker.on('dragend', () => {
-          const pos = marker.getLatLng();
-          const newPosition: [number, number] = [pos.lat, pos.lng];
-          onMarkerPositionChange?.(newPosition);
-        });
-        
-        markerRef.current = marker;
-    let destroyed = false;
-
-    const renderer = new OSMMapRenderer();
-    rendererRef.current = renderer;
-
-    const containerEl = mapRef.current;
-    const containerId = containerEl.id || (containerEl.id = 'mini-event-map-' + Math.random().toString(36).slice(2, 9));
-
-    const init = async () => {
-      try {
-        await renderer.init(containerId, { center, zoom });
-        const map = renderer.getMap();
-        mapInstanceRef.current = map;
-
-        // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–ª–∏–∫–∞ –Ω–∞ –∫–∞—Ä—Ç—É —á–µ—Ä–µ–∑ renderer
-        const clickHandler = (e: any) => {
-          try {
-            const position: [number, number] = [e.latlng.lat, e.latlng.lng];
-
-            // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é –º–∞—Ä–∫–µ—Ä–∞
-            if (markerRef.current) {
-              try { markerRef.current.setLatLng(e.latlng); } catch (err) { }
-            } else {
-              // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π –º–∞—Ä–∫–µ—Ä –ª–æ–∫–∞–ª—å–Ω–æ
-              const marker = L.marker(e.latlng, {
-                draggable: true,
-              }).addTo(map);
-
-              marker.on('dragend', () => {
-                try {
-                  const pos = marker.getLatLng();
-                  const newPosition: [number, number] = [pos.lat, pos.lng];
-                  onMarkerPositionChangeRef.current?.(newPosition);
-                } catch (err) { }
-              });
-
-              markerRef.current = marker;
-            }
-
-            onMarkerPositionChangeRef.current?.(position);
-            onMapClickRef.current?.(position);
-          } catch (err) { }
-        };
-
-        // –ü–æ–¥–ø–∏—Å—ã–≤–∞–µ–º—Å—è –Ω–∞ –∫–ª–∏–∫–∏. –ï—Å–ª–∏ —Ä–µ–Ω–¥–µ—Ä–µ—Ä –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç onMapClick, –∏—Å–ø–æ–ª—å–∑—É–µ–º L handler.
-        try { renderer.onMapClick?.(clickHandler); } catch (e) { map.on('click', clickHandler); }
-        clickHandlerRef.current = clickHandler;
-      } catch (err) {
-        console.warn('[MiniEventMap] Failed to initialize renderer', err);
-      }
-      
-      onMarkerPositionChange?.(position);
-      onMapClick?.(position);
-    });
-    };
-
-    init();
-
-    return () => {
-      if (mapInstanceRef.current) {
-        mapInstanceRef.current.remove();
-      destroyed = true;
-      try {
-        const clickHandler = clickHandlerRef.current;
-        const map = mapInstanceRef.current;
-        if (map && clickHandler) {
-          try { map.off('click', clickHandler); } catch (e) { }
-        }
-
-        if (rendererRef.current) {
-          try { rendererRef.current.destroy(); } catch (e) { }
-          rendererRef.current = null;
-        }
-
-        mapInstanceRef.current = null;
-      }
-        markerRef.current = null;
-      } catch (e) { }
-    };
-  }, []);
+  useEffect(() => {
+    if (!mapRef.current || mapInstanceRef.current) return;
+    let destroyed = false;
+
+    const renderer = new OSMMapRenderer();
+    rendererRef.current = renderer;
+
+    const containerEl = mapRef.current;
+    const containerId = containerEl.id || (containerEl.id = 'mini-event-map-' + Math.random().toString(36).slice(2, 9));
+
+    const init = async () => {
+      try {
+        await renderer.init(containerId, { center, zoom });
+        if (destroyed) return;
+        const map = renderer.getMap();
+        mapInstanceRef.current = map;
+
+        // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–ª–∏–∫–∞ –Ω–∞ –∫–∞—Ä—Ç—É —á–µ—Ä–µ–∑ renderer
+        const clickHandler = (e: any) => {
+          try {
+            const position: [number, number] = [e.latlng.lat, e.latlng.lng];
+
+            // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é –º–∞—Ä–∫–µ—Ä–∞
+            if (markerRef.current) {
+              try { markerRef.current.setLatLng(e.latlng); } catch (err) { }
+            } else {
+              // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π –º–∞—Ä–∫–µ—Ä –ª–æ–∫–∞–ª—å–Ω–æ
+              const marker = L.marker(e.latlng, {
+                draggable: true,
+              }).addTo(map);
+
+              marker.on('dragend', () => {
+                try {
+                  const pos = marker.getLatLng();
+                  const newPosition: [number, number] = [pos.lat, pos.lng];
+                  onMarkerPositionChangeRef.current?.(newPosition);
+                } catch (err) { }
+              });
+
+              markerRef.current = marker;
+            }
+
+            onMarkerPositionChangeRef.current?.(position);
+            onMapClickRef.current?.(position);
+          } catch (err) { }
+        };
+
+        // –ü–æ–¥–ø–∏—Å—ã–≤–∞–µ–º—Å—è –Ω–∞ –∫–ª–∏–∫–∏. –ï—Å–ª–∏ —Ä–µ–Ω–¥–µ—Ä–µ—Ä –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç onMapClick, –∏—Å–ø–æ–ª—å–∑—É–µ–º L handler.
+        try { renderer.onMapClick?.(clickHandler); } catch (e) { map.on('click', clickHandler); }
+        clickHandlerRef.current = clickHandler;
+      } catch (err) {
+        console.warn('[MiniEventMap] Failed to initialize renderer', err);
+      }
+    };
+
+    init();
+
+    return () => {
+      destroyed = true;
+      try {
+        const clickHandler = clickHandlerRef.current;
+        const map = mapInstanceRef.current;
+        if (map && clickHandler) {
+          try { map.off('click', clickHandler); } catch (e) { }
+        }
+
+        if (rendererRef.current) {
+          try { rendererRef.current.destroy(); } catch (e) { }
+          rendererRef.current = null;
+        }
+
+        mapInstanceRef.current = null;
+        markerRef.current = null;
+      } catch (e) { }
+    };
+  }, []);
ü§ñ Prompt for AI Agents
In `@frontend/src/components/Events/MiniEventMap.tsx` around lines 39 - 113, The
init async function can continue after the component unmounts because the
destroyed flag isn't checked after awaiting renderer.init; update init (the
function that calls await renderer.init(...)) to immediately return if destroyed
is true right after the await (before calling renderer.getMap(), setting
mapInstanceRef.current, assigning clickHandlerRef/current handlers, or creating
markers), and if destroyed is true ensure rendererRef.current is cleaned up
(call renderer.destroy()) and do not attach map event listeners; this prevents
race conditions between renderer.init, the cleanup in the useEffect return, and
subsequent operations that set mapInstanceRef, markerRef, and clickHandlerRef.
In frontend/src/components/Maps/PostMap.tsx:

>    useEffect(() => {
     if (!initializedRef.current) return;
-    const getMapInstance = () => {
-      try {
-        const mapApi = projectManager.getMapApi();
-        const provider = mapApi.providers?.[mapApi.currentProvider];
-        return provider?.map || null;
-      } catch {
-        return null;
-      }
-    };
     const timer = setTimeout(() => {
-      mapRef.current = getMapInstance();
+      // Backwards-compat assignment removed: use `mapFacade()` methods directly in consumers instead of relying on `mapRef`.
+      // If you need the raw map instance, call `mapFacade().getMap?.()` at the callsite.
     }, 200);
     return () => clearTimeout(timer);
   }, [initializedRef.current]);
‚ö†Ô∏è Potential issue | üü° Minor

Ref value in useEffect dependency array won't trigger updates.

Using initializedRef.current as a dependency won't cause the effect to re-run when the ref changes, since refs don't trigger re-renders. The effect body is also empty (just a comment), so this effect appears to be dead code.

üßπ Proposed fix - remove dead code
-  // –ü–æ–ª—É—á–∞–µ–º —Å—Å—ã–ª–∫—É –Ω–∞ –∫–∞—Ä—Ç—É –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –ø–æ–∑–∏—Ü–∏–∏ –ø–æ–ø–∞–ø–∞ (—á–µ—Ä–µ–∑ —Ñ–∞—Å–∞–¥). –û—Å—Ç–∞–≤–ª—è–µ–º mapRef –¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏, –Ω–æ –æ—Å–Ω–æ–≤–Ω–æ–π –∫–æ–¥ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç —Ñ–∞—Å–∞–¥.
-  useEffect(() => {
-    if (!initializedRef.current) return;
-    const timer = setTimeout(() => {
-      // Backwards-compat assignment removed: use `mapFacade()` methods directly in consumers instead of relying on `mapRef`.
-      // If you need the raw map instance, call `mapFacade().getMap?.()` at the callsite.
-    }, 200);
-    return () => clearTimeout(timer);
-  }, [initializedRef.current]);
ü§ñ Prompt for AI Agents
In `@frontend/src/components/Maps/PostMap.tsx` around lines 131 - 138, The
useEffect that reads initializedRef.current is dead code because refs don't
trigger re-renders and the effect body contains only a comment; remove the
entire useEffect block (including the timer and cleanup) from PostMap.tsx. If
you intended to run logic when initialization changes, replace initializedRef
with a piece of state (e.g. isInitialized) or listen to the proper
initialization event and call mapFacade().getMap() where needed, but otherwise
delete the useEffect and its comment referencing mapRef/mapFacade to avoid
confusion.
In frontend/src/components/YandexMap/YandexMap.tsx:

> +const mapInst = resolveMapInstance();
+      if (mapInst && mapInst.geoObjects) {
       updateMarkers();
     } else {
       // –ï—Å–ª–∏ –∫–∞—Ä—Ç–∞ –µ—â–µ –Ω–µ –≥–æ—Ç–æ–≤–∞, –∂–¥–µ–º –Ω–µ–º–Ω–æ–≥–æ –∏ –ø—Ä–æ–±—É–µ–º —Å–Ω–æ–≤–∞
       const timeoutId = setTimeout(() => {
-        if (!destroyed && mapInstanceRef.current && mapInstanceRef.current.geoObjects) {
+        const m = resolveMapInstance();
+        if (!destroyed && m && m.geoObjects) {
‚ö†Ô∏è Potential issue | üü° Minor

Indentation appears broken.

The code at lines 515-522 has inconsistent indentation that breaks the visual structure. This may be a merge artifact.

üìù Suggested fix
-const mapInst = resolveMapInstance();
-      if (mapInst && mapInst.geoObjects) {
+        const mapInst = resolveMapInstance();
+        if (mapInst && mapInst.geoObjects) {
üìù Committable suggestion
‚ÄºÔ∏è IMPORTANT
Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.

‚¨áÔ∏è Suggested change
-const mapInst = resolveMapInstance();
-      if (mapInst && mapInst.geoObjects) {
-      updateMarkers();
-    } else {
-      // –ï—Å–ª–∏ –∫–∞—Ä—Ç–∞ –µ—â–µ –Ω–µ –≥–æ—Ç–æ–≤–∞, –∂–¥–µ–º –Ω–µ–º–Ω–æ–≥–æ –∏ –ø—Ä–æ–±—É–µ–º —Å–Ω–æ–≤–∞
-      const timeoutId = setTimeout(() => {
-        if (!destroyed && mapInstanceRef.current && mapInstanceRef.current.geoObjects) {
-        const m = resolveMapInstance();
-        if (!destroyed && m && m.geoObjects) {
+        const mapInst = resolveMapInstance();
+        if (mapInst && mapInst.geoObjects) {
+      updateMarkers();
+    } else {
+      // –ï—Å–ª–∏ –∫–∞—Ä—Ç–∞ –µ—â–µ –Ω–µ –≥–æ—Ç–æ–≤–∞, –∂–¥–µ–º –Ω–µ–º–Ω–æ–≥–æ –∏ –ø—Ä–æ–±—É–µ–º —Å–Ω–æ–≤–∞
+      const timeoutId = setTimeout(() => {
+        const m = resolveMapInstance();
+        if (!destroyed && m && m.geoObjects) {
ü§ñ Prompt for AI Agents
In `@frontend/src/components/YandexMap/YandexMap.tsx` around lines 515 - 522, The
indentation around the map readiness check is inconsistent; fix the formatting
so the if/else block and nested timeout callback are properly aligned and
readable. Locate the resolveMapInstance() call (mapInst), the conditional that
checks mapInst && mapInst.geoObjects, the updateMarkers() call, and the else
branch that creates timeoutId and the inner callback referencing destroyed and
m; re-indent those lines so the else, setTimeout callback, and inner if are
nested consistently with the surrounding code style.
In frontend/src/services/map_facade/MapContextFacade.ts:

> +  // Start handlers
+  private readonly moveStartHandlers: Array<() => void> = [];
+  private readonly zoomStartHandlers: Array<() => void> = [];
 
   // Maps to keep track of wrappers for unsubscribe
   private readonly clickHandlerMap: Map<(e: any) => void, (coords: [number, number]) => void> = new Map();
   private readonly moveHandlerMap: Map<() => void, () => void> = new Map();
-  private readonly zoomHandlerMap: Map<() => void, () => void> = new Map(); 
+  private readonly zoomHandlerMap: Map<() => void, () => void> = new Map();
+  private readonly moveStartHandlerMap: Map<() => void, () => void> = new Map();
+  private readonly zoomStartHandlerMap: Map<() => void, () => void> = new Map();
‚ö†Ô∏è Potential issue | üü† Major

üß© Analysis chain
üèÅ Script executed:

find . -name "MapContextFacade.ts" -type f
Repository: Simamakis/GeoBlogRF

Length of output: 117

üèÅ Script executed:

wc -l frontend/src/services/map_facade/MapContextFacade.ts
Repository: Simamakis/GeoBlogRF

Length of output: 120

üèÅ Script executed:

sed -n '60,85p' frontend/src/services/map_facade/MapContextFacade.ts
Repository: Simamakis/GeoBlogRF

Length of output: 1413

üèÅ Script executed:

sed -n '260,285p' frontend/src/services/map_facade/MapContextFacade.ts
Repository: Simamakis/GeoBlogRF

Length of output: 1040

üèÅ Script executed:

sed -n '1200,1260p' frontend/src/services/map_facade/MapContextFacade.ts
Repository: Simamakis/GeoBlogRF

Length of output: 2394

üèÅ Script executed:

rg "offMap\w+\s*\?" frontend/src/services/map_facade/MapContextFacade.ts -A 2 | head -30
Repository: Simamakis/GeoBlogRF

Length of output: 335

üèÅ Script executed:

sed -n '1,100p' frontend/src/services/map_facade/MapContextFacade.ts | grep -E "(interface|type).*Renderer"
Repository: Simamakis/GeoBlogRF

Length of output: 45

üèÅ Script executed:

rg "onMapClick|offMapClick|onMapMove|offMapMove|onMapZoom|offMapZoom" frontend/src/services/map_facade/MapContextFacade.ts | head -20
Repository: Simamakis/GeoBlogRF

Length of output: 1134

üèÅ Script executed:

sed -n '1160,1210p' frontend/src/services/map_facade/MapContextFacade.ts
Repository: Simamakis/GeoBlogRF

Length of output: 1526

üèÅ Script executed:

sed -n '1260,1310p' frontend/src/services/map_facade/MapContextFacade.ts
Repository: Simamakis/GeoBlogRF

Length of output: 337

üèÅ Script executed:

sed -n '1160,1175p' frontend/src/services/map_facade/MapContextFacade.ts
Repository: Simamakis/GeoBlogRF

Length of output: 420

üèÅ Script executed:

sed -n '1115,1160p' frontend/src/services/map_facade/MapContextFacade.ts
Repository: Simamakis/GeoBlogRF

Length of output: 1825

üèÅ Script executed:

sed -n '240,280p' frontend/src/services/map_facade/MapContextFacade.ts
Repository: Simamakis/GeoBlogRF

Length of output: 1481

Prevent double-firing of moveStart/zoomStart handlers on renderer switches.
bindRendererEventHandlers attaches a dispatcher that iterates start handlers. However, onMapMoveStart/onMapZoomStart also immediately attach each handler wrapper directly to the renderer. When a handler is registered after a renderer switch, it fires twice‚Äîonce from the dispatcher (iterating the array) and again from direct attachment. Extract the dispatcher callbacks as static properties and manage them on renderer switches to ensure each handler fires exactly once.

This applies to moveStart and zoomStart handlers (lines 263‚Äì278, 1206‚Äì1256).

üõ†Ô∏è Suggested fix: use static dispatchers managed on renderer switch
@@
+  private readonly moveStartDispatcher = () => {
+    this.moveStartHandlers.forEach(h => {
+      try { h(); } catch (error_) { console.debug('[MapContextFacade] moveStart handler error:', error_); }
+    });
+  };
+  private readonly zoomStartDispatcher = () => {
+    this.zoomStartHandlers.forEach(h => {
+      try { h(); } catch (error_) { console.debug('[MapContextFacade] zoomStart handler error:', error_); }
+    });
+  };
@@
-      if (r.onMapMoveStart && this.moveStartHandlers.length > 0) {
-        r.onMapMoveStart(() => {
-          this.moveStartHandlers.forEach(h => {
-            try { h(); } catch (error_) { console.debug('[MapContextFacade] moveStart handler error:', error_); }
-          });
-        });
-      }
+      if (r.onMapMoveStart && this.moveStartHandlers.length > 0) {
+        r.offMapMoveStart?.(this.moveStartDispatcher);
+        r.onMapMoveStart(this.moveStartDispatcher);
+      }
@@
-      if (r.onMapZoomStart && this.zoomStartHandlers.length > 0) {
-        r.onMapZoomStart(() => {
-          this.zoomStartHandlers.forEach(h => {
-            try { h(); } catch (error_) { console.debug('[MapContextFacade] zoomStart handler error:', error_); }
-          });
-        });
-      }
+      if (r.onMapZoomStart && this.zoomStartHandlers.length > 0) {
+        r.offMapZoomStart?.(this.zoomStartDispatcher);
+        r.onMapZoomStart(this.zoomStartDispatcher);
+      }
@@
   onMapMoveStart(handler: () => void): void {
     const wrapper = () => {
       try { handler(); } catch (e) { /* ignore */ }
     };
     this.moveStartHandlers.push(wrapper);
     this.moveStartHandlerMap.set(handler as any, wrapper);
-    try {
-      const r = this.currentRenderer as any;
-      r?.onMapMoveStart?.(wrapper);
-    } catch (error_) { console.debug('[MapContextFacade] onMapMoveStart setup failed:', error_); }
   }
@@
   onMapZoomStart(handler: () => void): void {
     const wrapper = () => {
       try { handler(); } catch (e) { /* ignore */ }
     };
     this.zoomStartHandlers.push(wrapper);
     this.zoomStartHandlerMap.set(handler as any, wrapper);
-    try {
-      const r = this.currentRenderer as any;
-      r?.onMapZoomStart?.(wrapper);
-    } catch (error_) { console.debug('[MapContextFacade] onMapZoomStart setup failed:', error_); }
   }
ü§ñ Prompt for AI Agents
In `@frontend/src/services/map_facade/MapContextFacade.ts` around lines 65 - 74,
The moveStart/zoomStart handlers are double-fired because
bindRendererEventHandlers adds a dispatcher that iterates
moveStartHandlers/zoomStartHandlers while onMapMoveStart/onMapZoomStart also
attach each wrapper directly to the renderer; refactor by extracting the
dispatcher callbacks (a single dispatcher function per event) as static
properties and ensure renderer-switch logic in bindRendererEventHandlers
detaches the dispatcher from the old renderer and attaches it to the new
renderer exactly once; change onMapMoveStart/onMapZoomStart to only create/store
the wrapper in moveStartHandlerMap/zoomStartHandlerMap and push the original
into moveStartHandlers/zoomStartHandlers (no direct renderer.attach there), and
update unsubscribe logic to remove wrappers from both the maps and the arrays so
each handler fires exactly once.
In patches/0002-refactor-mini-event-map.patch:

> ++
++        // –ü–æ–¥–ø–∏—Å—ã–≤–∞–µ–º—Å—è –Ω–∞ –∫–ª–∏–∫–∏. –ï—Å–ª–∏ —Ä–µ–Ω–¥–µ—Ä–µ—Ä –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç onMapClick, –∏—Å–ø–æ–ª—å–∑—É–µ–º L hander.
‚ö†Ô∏è Potential issue | üü° Minor

Typo in comment: "hander" should be "handler".

üìù Fix
-        // –ü–æ–¥–ø–∏—Å—ã–≤–∞–µ–º—Å—è –Ω–∞ –∫–ª–∏–∫–∏. –ï—Å–ª–∏ —Ä–µ–Ω–¥–µ—Ä–µ—Ä –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç onMapClick, –∏—Å–ø–æ–ª—å–∑—É–µ–º L hander.
+        // –ü–æ–¥–ø–∏—Å—ã–≤–∞–µ–º—Å—è –Ω–∞ –∫–ª–∏–∫–∏. –ï—Å–ª–∏ —Ä–µ–Ω–¥–µ—Ä–µ—Ä –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç onMapClick, –∏—Å–ø–æ–ª—å–∑—É–µ–º L handler.
üìù Committable suggestion
‚ÄºÔ∏è IMPORTANT
Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.

‚¨áÔ∏è Suggested change
-+
-+        // –ü–æ–¥–ø–∏—Å—ã–≤–∞–µ–º—Å—è –Ω–∞ –∫–ª–∏–∫–∏. –ï—Å–ª–∏ —Ä–µ–Ω–¥–µ—Ä–µ—Ä –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç onMapClick, –∏—Å–ø–æ–ª—å–∑—É–µ–º L hander.
+
+        // –ü–æ–¥–ø–∏—Å—ã–≤–∞–µ–º—Å—è –Ω–∞ –∫–ª–∏–∫–∏. –ï—Å–ª–∏ —Ä–µ–Ω–¥–µ—Ä–µ—Ä –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç onMapClick, –∏—Å–ø–æ–ª—å–∑—É–µ–º L handler.
ü§ñ Prompt for AI Agents
In `@patches/0002-refactor-mini-event-map.patch` around lines 152 - 153, Typo in
the inline comment near the map click subscription should be fixed: change "L
hander" to "L handler" in the comment that accompanies the onMapClick fallback
logic (the comment that starts with "–ü–æ–¥–ø–∏—Å—ã–≤–∞–µ–º—Å—è –Ω–∞ –∫–ª–∏–∫–∏. –ï—Å–ª–∏ —Ä–µ–Ω–¥–µ—Ä–µ—Ä –Ω–µ
–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç onMapClick, –∏—Å–ø–æ–ª—å–∑—É–µ–º L hander."). Update that comment text only;
no code changes are required.
‚Äî
Reply to this email directly, view it on GitHub, or unsubscribe.
You are receiving this because you authored the thread.

